import { t as e } from "./rolldown-runtime.CXBuSdYp.mjs"; import { A as t, B as n, C as r, F as i, I as a, M as o, N as s, O as c, P as l, R as u, S as d, a as f, b as p, c as m, d as h, f as g, g as _, h as v, i as y, j as b, k as x, l as S, m as C, o as w, p as T, s as E, u as D, v as O, w as k, x as A, y as ee, z as j } from "./react.o6Ry5hDS.mjs"; import { $ as M, A as te, B as ne, C as N, D as re, E as ie, F as ae, G as oe, H as se, I as ce, J as le, K as ue, L as de, M as fe, O as pe, P as me, Q as he, S as P, T as ge, U as _e, V as ve, W as ye, X as F, Y as be, Z as xe, _ as I, a as Se, b as Ce, c as we, d as Te, et as Ee, f as De, g as Oe, h as ke, i as Ae, j as je, k as Me, l as Ne, m as Pe, n as Fe, nt as Ie, o as Le, p as Re, q as ze, r as Be, s as Ve, tt as He, u as Ue, v as We, w as Ge, x as Ke, y as qe, z as Je } from "./motion.CQ5j-3ta.mjs"; function Ye(e) { return typeof e == `function` } function Xe(e) { return typeof e == `boolean` } function L(e) { return typeof e == `string` } function R(e) { return Number.isFinite(e) } function Ze(e) { return Array.isArray(e) } function z(e) { return typeof e == `object` && !!e && !Ze(e) } function Qe(e) { for (let t in e) return !1; return !0 } function $e(e) { return e === void 0 } function et(e) { return e === null } function tt(e) { return e == null } function nt(e) { return e instanceof Date && !Number.isNaN(e.getTime()) } function rt(e) { return z(e) && Ye(e.return) } function it(e) { return z(e) && Ye(e.then) } function at(e) { return e instanceof Promise } function ot(e) { return `url('data:image/svg+xml,${e.replaceAll(`#`, `%23`).replaceAll(`'`, `%27`)}')` } function st(e, t) {
    let n = t instanceof Error ? t.stack ?? t.message : t; return `${e ? `${e}
`: ``}In case the issue persists, report this to the Framer team via https://www.framer.com/contact/${n ? `:
${n}` : `.`}`
} function ct() { if (!Ah) return; let e = document.querySelectorAll(`[rel="modulepreload"][data-framer-lazy]`); for (let t of e) { let e = t.getAttribute(`data-framer-lazy`), n = t.getAttribute(`href`); if (!e || !n) continue; let r = import(n).then(t => (Ph.set(e, t), t)).catch(t => { throw Ph.delete(e), console.warn(`Failed to import lazy module: ${n}`, t), t }); r.catch(kh), Ph.set(e, r) } } function lt(e) { return typeof e == `object` && !!e && !g(e) && Ih in e } function ut(e, t) { if (t in e) return e[t]; throw Error(`Module does not contain export '${t}'`) } function dt(e, t = `default`, n) { let r, i, a, o = () => { if (i || !n || !Ph.has(n)) return; let e = Ph.get(n); at(e) ? c(() => e) : i = ut(e, t) }, c = e => i ? Promise.resolve(i) : (r ||= e().then(e => { let n = ut(e, t); return i = n, n }).catch(e => { a = e }), r), l = !1, u = v(function (t, r) { if (s(() => { l = !0 }, []), a) throw a; if (o(), n !== void 0 && Fh !== void 0 && Fh.add(n), !i) throw c(e); return m(i, { ref: r, ...t }) }); return u.preload = () => (o(), c(e)), u.getStatus = () => ({ hasLoaded: i !== void 0, hasRendered: l }), u } function ft(e, t) { return Object.prototype.hasOwnProperty.call(e, t) } function pt(e) { return e === null || !(Rh in e) ? !1 : typeof e.equals == `function` } function mt(e, t) { return e === t ? !0 : e !== e && t !== t } function ht(e, t) { let n = e.length; if (n !== t.length) return !1; for (let r = n; r-- !== 0;)if (!mt(e[r], t[r])) return !1; return !0 } function gt(e, t) { let n = e.length; if (n !== t.length) return !1; for (let r = n; r-- !== 0;)if (!St(e[r], t[r], !0)) return !1; return !0 } function _t(e, t) { if (e.size !== t.size) return !1; for (let [n, r] of e.entries()) if (!mt(r, t.get(n))) return !1; return !0 } function vt(e, t) { if (e.size !== t.size) return !1; for (let [n, r] of e.entries()) if (!St(r, t.get(n), !0)) return !1; return !0 } function yt(e, t) { if (e.size !== t.size) return !1; for (let n of e.keys()) if (!t.has(n)) return !1; return !0 } function bt(e, t) { let n = Lh(e); if (n.length !== Lh(t).length) return !1; for (let r of n) if (!ft(t, r) || !(r === `_owner` && ft(e, `$$typeof`) && e.$$typeof) && !mt(e[r], t[r])) return !1; return !0 } function xt(e, t) { let n = Lh(e); if (n.length !== Lh(t).length) return !1; for (let r of n) if (!ft(t, r) || !(r === `_owner` && ft(e, `$$typeof`) && e.$$typeof) && !St(e[r], t[r], !0)) return !1; return !0 } function St(e, t, n) { if (e === t) return !0; if (!e || !t) return e !== e && t !== t; let r = typeof e; if (r !== typeof t || r !== `object`) return !1; let i = Array.isArray(e), a = Array.isArray(t); if (i && a) return n ? gt(e, t) : ht(e, t); if (i !== a) return !1; let o = e instanceof Map, s = t instanceof Map; if (o && s) return n ? vt(e, t) : _t(e, t); if (o !== s) return !1; let c = e instanceof Set, l = t instanceof Set; if (c && l) return yt(e, t); if (c !== l) return !1; let u = e instanceof Date, d = t instanceof Date; if (u && d) return e.getTime() === t.getTime(); if (u !== d) return !1; let f = e instanceof RegExp, p = t instanceof RegExp; return f && p ? e.toString() === t.toString() : f === p ? pt(e) && pt(t) ? e.equals(t) : n ? xt(e, t) : bt(e, t) : !1 } function Ct(e, t, n = !0) { try { return St(e, t, n) } catch (e) { if (e instanceof Error && /stack|recursion/iu.exec(e.message)) return console.warn(`Warning: isEqual does not handle circular references.`, e.name, e.message), !1; throw e } } function wt(e) { return p.useCallback(t => e[t], [e]) } function Tt({ api: e, children: t }) { return m(zh.Provider, { value: e, children: t }) } function Et() { return p.useContext(zh) } function Dt({ routes: e, children: t }) { let n = wt(e), r = b(() => ({ getRoute: n }), [n]); return m(zh.Provider, { value: r, children: t }) } function Ot() { let e = Et(), n = t(Bh), r = n?.routeId ?? e.currentRouteId, i = n?.routeId ? n.pathVariables : e.currentPathVariables, a = r ? e.getRoute?.(r) : void 0; return b(() => { if (!(!r || !a)) return { ...a, id: r, pathVariables: i } }, [r, i, a]) } function kt() { let e = Ot(); if (e) return `${e.id}-${JSON.stringify(e.pathVariables)}` } function At(e) { let t = Ot(), n = p.useRef(t); Ct(n.current, t) || !t || (n.current = t, e(t)) } function jt(e) { let t = Et(); if (e) return t.getRoute?.(e) } function Mt(e, t) { if (t && e) return e.elements && t in e.elements ? e.elements[t] : t } function Nt(e) { let t = [`pointerdown`, `pointerup`, `keydown`, `keyup`], n = e => { let n = e.type; t.includes(n) && performance.mark(`framer-navigation-input`, { detail: { type: n } }) }; for (let r = 0; r < t.length; r++)document.addEventListener(t[r], n, { signal: e }); return () => { for (let e = 0; e < t.length; e++)document.removeEventListener(t[e], n) } } function Pt(e, t) { let n = Ot(), r = jt(t) ?? n; return p.useMemo(() => r ? Mt(r, e) : e, [e, r]) } function Ft() { return Ot()?.pathVariables } function B(e, ...t) {
    if (e) return; let n = Error(`Assertion Error` + (t.length > 0 ? `: ` + t.join(` `) : ``)); if (n.stack) try {
        let e = n.stack.split(`
`); e[1]?.includes(`assert`) ? (e.splice(1, 1), n.stack = e.join(`
`)) : e[0]?.includes(`assert`) && (e.splice(0, 1), n.stack = e.join(`
`))
    } catch { } throw n
} function V(e, t) { throw t || Error(e ? `Unexpected value: ${e}` : `Application entered invalid state`) } function It(e) { return Object(e) !== e } function Lt(e) { let t = Object.getPrototypeOf(e); return t === Object.prototype || t === null || Object.getPrototypeOf(t) === null || Object.getOwnPropertyNames(t).sort().join(`\0`) === Yh } function Rt(e) { return Object.prototype.toString.call(e).slice(8, -1) } function zt(e) {
    switch (e) {
        case `"`: return `\\"`; case `<`: return `\\u003C`; case `\\`: return `\\\\`; case `
`: return `\\n`; case `\r`: return `\\r`; case `	`: return `\\t`; case `\b`: return `\\b`; case `\f`: return `\\f`; case `\u2028`: return `\\u2028`; case `\u2029`: return `\\u2029`; default: return e < ` ` ? `\\u${e.charCodeAt(0).toString(16).padStart(4, `0`)}` : ``
    }
} function Bt(e) { let t = ``, n = 0, r = e.length; for (let i = 0; i < r; i += 1) { let r = e[i], a = zt(r); a && (t += e.slice(n, i) + a, n = i + 1) } return `"${n === 0 ? e : t + e.slice(n)}"` } function Vt(e) { return Object.getOwnPropertySymbols(e).filter(t => Object.getOwnPropertyDescriptor(e, t).enumerable) } function Ht(e) { return Xh.test(e) ? `.` + e : `[` + JSON.stringify(e) + `]` } function Ut(e) { let t = new DataView(e), n = ``; for (let r = 0; r < e.byteLength; r++)n += String.fromCharCode(t.getUint8(r)); return Kt(n) } function Wt(e) { let t = Gt(e), n = new ArrayBuffer(t.length), r = new DataView(n); for (let e = 0; e < n.byteLength; e++)r.setUint8(e, t.charCodeAt(e)); return n } function Gt(e) { e.length % 4 == 0 && (e = e.replace(/==?$/, ``)); let t = ``, n = 0, r = 0; for (let i = 0; i < e.length; i++)n <<= 6, n |= Zh.indexOf(e[i]), r += 6, r === 24 && (t += String.fromCharCode((n & 16711680) >> 16), t += String.fromCharCode((n & 65280) >> 8), t += String.fromCharCode(n & 255), n = r = 0); return r === 12 ? (n >>= 4, t += String.fromCharCode(n)) : r === 18 && (n >>= 2, t += String.fromCharCode((n & 65280) >> 8), t += String.fromCharCode(n & 255)), t } function Kt(e) { let t = ``; for (let n = 0; n < e.length; n += 3) { let r = [void 0, void 0, void 0, void 0]; r[0] = e.charCodeAt(n) >> 2, r[1] = (e.charCodeAt(n) & 3) << 4, e.length > n + 1 && (r[1] |= e.charCodeAt(n + 1) >> 4, r[2] = (e.charCodeAt(n + 1) & 15) << 2), e.length > n + 2 && (r[2] |= e.charCodeAt(n + 2) >> 6, r[3] = e.charCodeAt(n + 2) & 63); for (let e = 0; e < r.length; e++)r[e] === void 0 ? t += `=` : t += Zh[r[e]] } return t } function qt(e, t) { return Jt(JSON.parse(e), t) } function Jt(e, t) { if (typeof e == `number`) return a(e, !0); if (!Array.isArray(e) || e.length === 0) throw Error(`Invalid input`); let n = e, r = Array(n.length), i = null; function a(e, o = !1) { if (e === Qh) return; if (e === eg) return NaN; if (e === tg) return 1 / 0; if (e === ng) return -1 / 0; if (e === rg) return -0; if (o || typeof e != `number`) throw Error(`Invalid input`); if (e in r) return r[e]; let s = n[e]; if (!s || typeof s != `object`) r[e] = s; else if (Array.isArray(s)) if (typeof s[0] == `string`) { let o = s[0], c = t && Object.hasOwn(t, o) ? t[o] : void 0; if (c) { let t = s[1]; if (typeof t != `number` && (t = n.push(s[1]) - 1), i ??= new Set, i.has(t)) throw Error(`Invalid circular reference`); return i.add(t), r[e] = c(a(t)), i.delete(t), r[e] } switch (o) { case `Date`: r[e] = new Date(s[1]); break; case `Set`: let t = new Set; r[e] = t; for (let e = 1; e < s.length; e += 1)t.add(a(s[e])); break; case `Map`: let i = new Map; r[e] = i; for (let e = 1; e < s.length; e += 2)i.set(a(s[e]), a(s[e + 1])); break; case `RegExp`: r[e] = new RegExp(s[1], s[2]); break; case `Object`: r[e] = Object(s[1]); break; case `BigInt`: r[e] = BigInt(s[1]); break; case `null`: let c = Object.create(null); r[e] = c; for (let e = 1; e < s.length; e += 2)c[s[e]] = a(s[e + 1]); break; case `Int8Array`: case `Uint8Array`: case `Uint8ClampedArray`: case `Int16Array`: case `Uint16Array`: case `Int32Array`: case `Uint32Array`: case `Float32Array`: case `Float64Array`: case `BigInt64Array`: case `BigUint64Array`: { if (n[s[1]][0] !== `ArrayBuffer`) throw Error(`Invalid data`); let t = globalThis[o], i = new t(a(s[1])); r[e] = s[2] === void 0 ? i : i.subarray(s[2], s[3]); break } case `ArrayBuffer`: { let t = s[1]; if (typeof t != `string`) throw Error(`Invalid ArrayBuffer encoding`); r[e] = Wt(t); break } case `Temporal.Duration`: case `Temporal.Instant`: case `Temporal.PlainDate`: case `Temporal.PlainTime`: case `Temporal.PlainDateTime`: case `Temporal.PlainMonthDay`: case `Temporal.PlainYearMonth`: case `Temporal.ZonedDateTime`: { let t = o.slice(9); r[e] = Temporal[t].from(s[1]); break } case `URL`: r[e] = new URL(s[1]); break; case `URLSearchParams`: r[e] = new URLSearchParams(s[1]); break; default: throw Error(`Unknown type ${o}`) } } else { let t = Array(s.length); r[e] = t; for (let e = 0; e < s.length; e += 1) { let n = s[e]; n !== $h && (t[e] = a(n)) } } else { let t = {}; for (let n in r[e] = t, s) { if (n === `__proto__`) throw Error("Cannot parse an object with a `__proto__` property"); let e = s[n]; t[n] = a(e) } } return r[e] } return a(0) } function Yt(e, t) { let n = [], r = new Map, i = []; if (t) for (let e of Object.getOwnPropertyNames(t)) i.push({ key: e, fn: t[e] }); let a = [], o = 0; function s(t) { if (t === void 0) return Qh; if (Number.isNaN(t)) return eg; if (t === 1 / 0) return tg; if (t === -1 / 0) return ng; if (t === 0 && 1 / t < 0) return rg; if (r.has(t)) return r.get(t); let c = o++; r.set(t, c); for (let { key: e, fn: r } of i) { let i = r(t); if (i) return n[c] = `["${e}",${s(i)}]`, c } if (typeof t == `function`) throw new Jh(`Cannot stringify a function`, a, t, e); let l = ``; if (It(t)) l = Xt(t); else { let n = Rt(t); switch (n) { case `Number`: case `String`: case `Boolean`: l = `["Object",${Xt(t)}]`; break; case `BigInt`: l = `["BigInt",${t}]`; break; case `Date`: l = `["Date","${isNaN(t.getDate()) ? `` : t.toISOString()}"]`; break; case `URL`: l = `["URL",${Bt(t.toString())}]`; break; case `URLSearchParams`: l = `["URLSearchParams",${Bt(t.toString())}]`; break; case `RegExp`: let { source: r, flags: i } = t; l = i ? `["RegExp",${Bt(r)},"${i}"]` : `["RegExp",${Bt(r)}]`; break; case `Array`: l = `[`; for (let e = 0; e < t.length; e += 1)e > 0 && (l += `,`), e in t ? (a.push(`[${e}]`), l += s(t[e]), a.pop()) : l += $h; l += `]`; break; case `Set`: l = `["Set"`; for (let e of t) l += `,${s(e)}`; l += `]`; break; case `Map`: l = `["Map"`; for (let [e, n] of t) a.push(`.get(${It(e) ? Xt(e) : `...`})`), l += `,${s(e)},${s(n)}`, a.pop(); l += `]`; break; case `Int8Array`: case `Uint8Array`: case `Uint8ClampedArray`: case `Int16Array`: case `Uint16Array`: case `Int32Array`: case `Uint32Array`: case `Float32Array`: case `Float64Array`: case `BigInt64Array`: case `BigUint64Array`: { let e = t; l = `["` + n + `",` + s(e.buffer); let r = t.byteOffset, i = r + t.byteLength; if (r > 0 || i !== e.buffer.byteLength) { let e = /(\d+)/.exec(n)[1] / 8; l += `,${r / e},${i / e}` } l += `]`; break } case `ArrayBuffer`: l = `["ArrayBuffer","${Ut(t)}"]`; break; case `Temporal.Duration`: case `Temporal.Instant`: case `Temporal.PlainDate`: case `Temporal.PlainTime`: case `Temporal.PlainDateTime`: case `Temporal.PlainMonthDay`: case `Temporal.PlainYearMonth`: case `Temporal.ZonedDateTime`: l = `["${n}",${Bt(t.toString())}]`; break; default: if (!Lt(t)) throw new Jh(`Cannot stringify arbitrary non-POJOs`, a, t, e); if (Vt(t).length > 0) throw new Jh(`Cannot stringify POJOs with symbolic keys`, a, t, e); if (Object.getPrototypeOf(t) === null) { for (let e in l = `["null"`, t) a.push(Ht(e)), l += `,${Bt(e)},${s(t[e])}`, a.pop(); l += `]` } else { l = `{`; let e = !1; for (let n in t) e && (l += `,`), e = !0, a.push(Ht(n)), l += `${Bt(n)}:${s(t[n])}`, a.pop(); l += `}` } } } return n[c] = l, c } let c = s(e); return c < 0 ? `${c}` : `[${n.join(`,`)}]` } function Xt(e) { let t = typeof e; return t === `string` ? Bt(e) : e instanceof String ? Bt(e.toString()) : e === void 0 ? Qh.toString() : e === 0 && 1 / e < 0 ? rg.toString() : t === `bigint` ? `["BigInt","${e}"]` : String(e) } function Zt(e, t, n = `lazy`) { switch (K.__framer_events?.push([e, t, n]), e) { case `published_site_click`: { let { trackingId: e, href: n } = t; e && document.dispatchEvent(new CustomEvent(`framer:click`, { detail: { trackingId: e, href: n } })); break } case `published_site_form_submit`: { let { trackingId: e } = t; e && document.dispatchEvent(new CustomEvent(`framer:formsubmit`, { detail: { trackingId: e } })); break } case `published_site_pageview`: { let { framerLocale: e } = t; document.dispatchEvent(new CustomEvent(`framer:pageview`, { detail: { framerLocale: e } })); break } case `published_site_trigger_invoke`: { let { trackingId: e } = t; e && document.dispatchEvent(new CustomEvent(`framer:triggerinvoke`, { detail: { trackingId: e } })); break } } } function Qt(e) { return L(e) && (e === `` || ag.test(e)) } function $t() { return { [og.QueryCache]: new Map, [og.CollectionUtilsCache]: new Map } } function en() { if (!Ah) return; if (sg !== void 0) return sg; let e = document.getElementById(`__framer__handoverData`); if (e) { try { sg = qt(e.text) ?? $t() } catch (e) { sg = $t(), console.warn(`Failed to parse handover data. Falling back to network.`, e) } return Nh(() => { e?.remove(), e = null }), sg } } function tn(e, t) { if (console.warn(st(`Failed to resolve raw query result from DOM during hydration for: ${t}. This might make the page load slightly slower.`)), Math.random() < .01) { let t = e instanceof Error && typeof e.stack == `string` ? e.stack : null; Zt(`published_site_load_error`, { message: String(e), stack: t }) } } function nn(e, t) { let n = en(); return n ? n[e].has(t) : !1 } function rn(e, t) { let n = en(); if (!n) return; let r = n[e]; if (!r.has(t)) return; let i = r.get(t); return r.delete(t), i } function an(e) { return e?.id ?? Gh } function on(e, t, n, r) { return `${e}|${t}|${n}|${r}` } function sn(e) { return t => { if (!e) return; let n = e[t]; if (!n) return; if (dg.has(n)) return dg.get(n); let r = new pg(n, t); return dg.set(n, r), r } } function cn({ children: e, collectionUtils: t }) { let n = b(() => ({ get: sn(t) }), [t]); return m(fg.Provider, { value: n, children: e }) } function ln() { return t(fg) } function un() { for (let e of gg) e(); gg.clear() } function dn(e) { return new Promise(t => { if (gg.add(t), document.hidden) { un(); return } document.addEventListener(`visibilitychange`, un), document.addEventListener(`pagehide`, un), ke.read(() => { pn(e).then(() => { gg.delete(t), !e?.signal?.aborted && t() }) }) }) } function fn(e) { return new Promise(t => { setTimeout(t, 100), ke.read(() => { pn(e).then(t) }, !1, !0) }) } function pn(e) { let t = e?.priority; return mg || hg ? t === `background` ? new Promise(e => { setTimeout(e, 1) }) : mg ? K.scheduler.yield(e).catch(kh) : K.scheduler.postTask(() => { }, e).catch(kh) : t === `user-blocking` ? Promise.resolve() : new Promise(e => { setTimeout(e, t === `background` ? 1 : 0) }) } function mn(e) { let { continueAfter: t, ensureContinueBeforeUnload: n, ...r } = e ?? {}; return n ? dn(r) : t === `paint` ? fn(r) : pn(r) } function hn() { let e = ln(), { autobahnNavigation: t } = Wh(), { getRoute: n } = Et(); return o((r, i, a = !0, o = !0) => { if (!r || !n) return; let s = n(r), { pathVariables: c, locale: l } = i; return _n(s, { routeId: r, pathVariables: c, locale: l, collectionUtils: e }, a, o && t) }, [n, e, t]) } function gn(e, t = !0) { let n = hn(); s(() => { if (!(!t || !_g)) for (let t of e) n(t, {}) }, [e, t, n]) } async function _n(e, t, n = !0, r = !0) { if (!_g || !e) return; let i = e.page; if (!(!i || !lt(i))) { n && await mn(); try { let e = await i.preload(); r && t && e && await vn(e, t) } catch { } } } async function vn(e, t) { let n = e.loader; if (!n?.load) return; let r = { signal: t.signal ?? new AbortController().signal, pathVariables: t.pathVariables ?? {}, routeId: t.routeId, locale: t.locale, collectionUtils: t.collectionUtils }; try { await n.load({}, r) } catch { } } function yn(e, t) { if (!e.startsWith(`/`) || !t.startsWith(`/`)) throw Error(`from/to paths are expected to be absolute`); let [n] = bn(e), [r, i] = bn(t), a = xn(n, r); return a === `` && (a = `.`), !a.startsWith(`.`) && !a.startsWith(`/`) && (a = `./` + a), a + `/` + i } function bn(e) { let t = e.lastIndexOf(`/`); return [e.substring(0, t + 1), e.substring(t + 1)] } function xn(e, t) { if (e === t || (e = `/` + Sn(e), t = `/` + Sn(t), e === t)) return ``; let n = e.length, r = n - 1, i = t.length - 1, a = r < i ? r : i, o = -1, s = 0; for (; s < a; s++) { let n = bg(e, 1 + s); if (n !== bg(t, 1 + s)) break; n === yg && (o = s) } if (s === a) if (i > a) { if (bg(t, 1 + s) === yg) return Sg(t, 1 + s + 1); if (s === 0) return Sg(t, 1 + s) } else r > a && (bg(e, 1 + s) === yg ? o = s : s === 0 && (o = 0)); let c = ``; for (s = 1 + o + 1; s <= n; ++s)(s === n || bg(e, s) === yg) && (c += c.length === 0 ? `..` : `/..`); return `${c}${Sg(t, 1 + o)}` } function Sn(e) { let t = ``, n = 0, r = -1, i = 0, a = 0; for (let o = 0; o <= e.length; ++o) { if (o < e.length) a = bg(e, o); else if (Tg(a)) break; else a = yg; if (Tg(a)) { if (!(r === o - 1 || i === 1)) if (i === 2) { if (t.length < 2 || n !== 2 || bg(t, t.length - 1) !== vg || bg(t, t.length - 2) !== vg) { if (t.length > 2) { let e = xg(t, wg); e === -1 ? (t = ``, n = 0) : (t = Sg(t, 0, e), n = t.length - 1 - xg(t, wg)), r = o, i = 0; continue } else if (t.length !== 0) { t = ``, n = 0, r = o, i = 0; continue } } Cg && (t += t.length > 0 ? `${wg}..` : `..`, n = 2) } else t.length > 0 ? t += `${wg}${Sg(e, r + 1, o)}` : t = Sg(e, r + 1, o), n = o - r - 1; r = o, i = 0 } else a === vg && i !== -1 ? ++i : i = -1 } return t } function Cn(e, t) { return e.replace(Dg, (e, n) => { let r = t[n]; return typeof r != `string` || r.length === 0 ? e : encodeURIComponent(r) }) } function wn(e) { let t = n === void 0 ? `` : n.location.search; return t ? Tn(t, e) : e } function Tn(e, t) { let n = t.indexOf(`#`), r = n === -1 ? t : t.substring(0, n), i = n === -1 ? `` : t.substring(n), a = r.indexOf(`?`), o = a === -1 ? r : r.substring(0, a), s = a === -1 ? `` : r.substring(a), c = new URLSearchParams(s), l = new URLSearchParams(e); for (let [e, t] of l) c.has(e) || e !== Og && c.append(e, t); let u = c.toString(); return u === `` ? r + i : o + `?` + u + i } async function En(e, t, n, r, i, a, o) { let s = e, c = !1, l = { ...a }, u = Array.from(s.matchAll(Dg)), d = await Promise.all(u.map(async e => { let s = e?.[0], u = e?.[1]; if (!s || !u) throw Error(`Failed to replace path variables: unexpected regex match group`); let d = a[u]; if (!d || !L(d)) throw Error(`No slug found for path variable ${u}`); let f = o?.get(i); if (!f || !t) return d; let p = f.getRecordIdBySlug(d, t), m = at(p) ? await p : p; if (!m) return d; let h = f.getSlugByRecordId(m, n), g = at(h) ? await h : h; if (!g) { c = !0; let e = f.getSlugByRecordId(m, r), t = at(e) ? await e : e; return t && (l[u] = t), t ?? d } return l[u] = g, g })), f = 0, p = ``, m = !1; for (let e = 0; e < u.length; e++) { let t = u[e], n = d[e]; !t || !n || (p += s.substring(f, t.index), f = (t.index ?? 0) + (t[0]?.length ?? 0), p += d[e], m = !0) } return m && (p += s.substring(f), s = p), { path: s, pathVariables: l, isMissingInLocale: c } } async function Dn({ currentLocale: e, nextLocale: t, defaultLocale: n, route: r, pathVariables: i, collectionUtils: a, preserveQueryParams: o }) { let { path: s, pathLocalized: c } = r, l = c?.[t.id] ?? s, u = { path: l, pathVariables: i, isMissingInLocale: !1 }; if (!l) return u; if (i && r.collectionId) try { u = await En(l, e, t, n, r.collectionId, i, a) } catch { } return t.slug && (u.path = `/` + t.slug + u.path), o && u.path && (u.path = wn(u.path)), u } function On(e) { if (!e) return ``; let t; try { t = new URL(e) } catch { return `` } return t.pathname === `/` || n.location.origin !== t.origin ? `` : t.pathname.endsWith(`/`) ? t.pathname.slice(0, -1) : t.pathname } function kn({ children: e, value: t }) { return m(kg.Provider, { value: t, children: e }) } function An() { return p.useContext(kg) } function jn(e, t, { global: n, routes: r }) { return r[e]?.[t] || n } function Mn(e) { let t = Ag, n = e.next(0), r = [n.value]; for (; !n.done && t < jg;)n = e.next(t), r.push(n.value), t += Ag; return r.length === 1 && r.push(n.value), { easing: `linear(${r.join(`,`)})`, duration: t - Ag } } function Nn(e) { return [parseFloat(e), e.endsWith(`px`) ? `px` : `%`] } function Pn(e) { let { innerWidth: t, innerHeight: r } = n, [i, a] = Nn(e.x), [o, s] = Nn(e.y); return { x: a === `px` ? i : i / 100 * t, y: s === `px` ? o : o / 100 * r } } function Fn(e, t, n, r) {
    let i = `
      opacity: ${e.opacity};
      transform: translate(${e.x}, ${e.y}) scale(${e.scale}) rotateX(${e.rotateX}deg) rotateY(${e.rotateY}deg) rotateZ(${e.rotate}deg);
    `; return e.mask && (i += r?.makeKeyframe?.(e.mask, t, n) || ``), i
} function In(e) { return e ? Ng[e] : void 0 } function Ln(e, { transition: t, ...n }) {
    let r = `view-transition-` + e, i = { duration: `0s`, easing: `linear` }; if (t.type === `tween`) i.duration = t.duration + `s`, i.easing = `cubic-bezier(${t.ease.join(`,`)})`; else if (Rn(t)) { let { easing: e, duration: n } = Mn(re({ keyframes: [0, 1], ...zn(t), restDelta: .001, restSpeed: 1e-4 })); i.duration = n + `ms`, i.easing = e } let a = In(n?.mask?.type), o = Fn(n, `start`, e, a), s = Fn({ ...Pg, mask: n.mask }, `end`, e, a); return e === `exit` && ([o, s] = [s, o]), `
        ${n.mask && a?.makePropertyRules ? a.makePropertyRules(n.mask) : ``}

        @keyframes ${r} {
            0% {
                ${o}
            }

            100% {
                ${s}
            }
        }

        ::view-transition-${e === `enter` ? `new` : `old`}(root) {
            animation-name: ${r};
            animation-duration: ${i.duration};
            animation-delay: ${t.delay}s;
            animation-timing-function: ${i.easing};
            animation-fill-mode: both;
            ${n.mask && a?.makeStyles ? a.makeStyles(n.mask, e) : ``}
        }
    `} function Rn(e) { return e.type === `spring` } function zn(e) { return e.durationBasedSpring ? { duration: e.duration * 1e3, bounce: e.bounce } : { stiffness: e.stiffness, damping: e.damping, mass: e.mass } } function Bn({ exit: e = Ig, enter: t }) {
    let n = document.createElement(`style`); n.id = Fg; let r = `
        @media (prefers-reduced-motion) {
            ::view-transition-group(*),
            ::view-transition-old(*),
            ::view-transition-new(*) {
                animation: none !important;
            }
        }
    `; (e.mask || t.mask || e.opacity || t.opacity || e.transition.delay || t.transition.delay) && (r += `
            ::view-transition-old(*),
            ::view-transition-new(*) {
                mix-blend-mode: normal;
            }
        `), r += `
        ::view-transition-old(*),
        ::view-transition-new(*) {
            backface-visibility: hidden;
        }
    `, r += Ln(`exit`, e), r += Ln(`enter`, t), n.textContent = r, document.head.appendChild(n)
} function Vn() { Nh(() => { ke.render(() => { performance.mark(`framer-vt-remove`); let e = document.getElementById(Fg); e && document.head.removeChild(e) }) }) } function Hn() { return !!document.startViewTransition } function Un(e) { return new Promise(t => { ke.render(() => { performance.mark(`framer-vt-style`), Bn(e), t() }) }) } async function Wn(e, t, n) { if (!Hn()) { e(); return } if (await Un(t), n?.aborted) return; performance.mark(`framer-vt`); let r = document.startViewTransition(async () => { performance.mark(`framer-vt-freeze`), !n?.aborted && (n?.addEventListener(`abort`, () => r.skipTransition()), await e()) }); return r.updateCallbackDone.then(() => { performance.mark(`framer-vt-unfreeze`) }).catch(Lg), Promise.all([r.ready, r.finished]).then(() => { performance.mark(`framer-vt-finished`), Vn() }).catch(Lg), r } function Gn() { let e = An(), t = c(void 0); return s(() => { t.current &&= (t.current(), void 0) }), o((n, r, i, a) => { let o = jn(n, r, e); if (o) { let e = new Promise(e => { t.current = e }); return Wn(async () => { i(), await e }, o, a) } i() }, [e]) } function Kn(e, t) { Nh(() => { let n = document.querySelector(`link[rel='canonical']`); if (!n) return; let r = new URL(e, t); r.search = ``, n.setAttribute(`href`, r.toString()) }) } function qn(e, t, n, r = A) { r(() => { let t = async e => (await mn({ ...n, continueAfter: `paint` }), e()), r = t(e); return () => { (async () => { let e = await r; e && t(e) })() } }, t) } function Jn(e) { let t = c(void 0); return qn(() => { t.current &&= (t.current(), void 0) }, void 0, { priority: `user-blocking` }), o(n => { let r = new Promise(e => { t.current = e }); if (!e) return { promise: r, measureDetail: n, ignore: null }; let i = `${e}-start`, a = `${e}-end`, o = !1; return performance.mark(i), r.finally(() => { o || (performance.mark(a), performance.measure(e, { start: i, end: a, detail: n })) }).catch(e => { console.error(e) }), { promise: r, measureDetail: n, ignore: () => { o = !0, t.current?.(), t.current = void 0 } } }, [e]) } async function Yn(e, t, { currentRoutePath: n, currentRoutePathLocalized: r, currentPathVariables: i, hash: a, pathVariables: o, localeId: s, preserveQueryParams: c, siteCanonicalURL: l }, u = !1) { let { path: d } = t; if (!d) return; let f = nr(t, { currentRoutePath: n, currentRoutePathLocalized: r, currentPathVariables: i, hash: a, pathVariables: o, preserveQueryParams: c, siteCanonicalURL: l, localeId: s }); try { return await Qn({ routeId: e, hash: a, pathVariables: o, localeId: s }, f, u) } catch { } } function Xn(e) { return z(e) && L(e.routeId) } function Zn(e, t, r = !1) { performance.mark(`framer-history-replace`), (r ? n.history.__proto__.replaceState : n.history.replaceState).call(n.history, e, ``, t) } async function Qn(e, t, r = !1) { if (performance.mark(`framer-history-push`), Kn(t, n.location.href), !r) { n.history.pushState(e, ``, t); return } let i = !1, a; Bg && (a = () => { if (i = !0, Vg) return; let e = `Popstate called after intercept(). Please report this to the Framer team.`; console.error(e), Zt(`published_site_load_recoverable_error`, { message: e }) }, n.addEventListener(`popstate`, a, { once: !0 })), Vg && Bg ? n.history.__proto__.pushState.call(n.history, e, ``, t) : n.history.pushState(e, ``, t), Bg && queueMicrotask(() => { i || (Bg = !1, n.removeEventListener(`popstate`, a)) }) } function $n({ disabled: e, routeId: t, initialPathVariables: n, initialLocaleId: r }) { A(() => { e || (performance.mark(`framer-history-set-initial-state`), Zn({ routeId: t, pathVariables: n, localeId: r }, void 0, !0)) }, []) } function er(e, t) { let r = Gn(), i = Jn(`framer-route-change`), a = c(void 0), l = o(async ({ state: o }) => { if (n.navigation?.transition && n.navigation?.transition?.navigationType !== `traverse` || !z(o)) return; let { routeId: s, hash: c, pathVariables: l, localeId: u } = o; if (!L(s)) return; let d = i({ popstate: !0 }), f = Nt(); d.promise.finally(f); let p = await r(e.current, s, () => { t(s, L(u) ? u : void 0, L(c) ? c : void 0, n.location.pathname + n.location.search + n.location.hash, z(l) ? l : void 0, !0, d, !1) }), m = n.navigation?.transition; await (p?.updateCallbackDone ?? Promise.resolve()).then(a.current?.resolve).catch(a.current?.reject), await d.promise; try { await m?.finished } catch (e) { console.warn(`Popstate transition failed`, e) } zg(), Kn(n.location.href) }, [e, i, t, r]), u = o(e => { e.navigationType !== `traverse` || !e.canIntercept || e.intercept({ async handler() { await new Promise((e, t) => { a.current = { resolve: e, reject: t } }), a.current = void 0 }, scroll: `after-transition` }) }, []); s(() => (n.addEventListener(`popstate`, l), Hg && n.navigation.addEventListener(`navigate`, u), () => { n.removeEventListener(`popstate`, l), Hg && n.navigation.removeEventListener(`navigate`, u) }), [l, u]) } function tr(e, t, n) { let r = Mt(t, e); if (!r) return; let i = Object.assign({}, t?.elements, n); return r.replace(Dg, (e, t) => i[t] ?? e) } function nr(e, { currentRoutePath: t, currentRoutePathLocalized: r, currentPathVariables: i, hash: a, pathVariables: o, hashVariables: s, relative: c = !0, preserveQueryParams: l, onlyHash: u = !1, siteCanonicalURL: d, localeId: f }) { let p = tr(a, e, s); if (u) return p ?? ``; let m = t ?? `/`; r && f && (m = r[f] ?? m), i && (m = m.replace(Dg, (e, t) => String(i[t] || e))); let h = (f ? e?.pathLocalized?.[f] : void 0) ?? e?.path ?? `/`; o && (h = h.replace(Dg, (e, t) => String(o[t] || e))); let g = m === h && p; if (c) if (Eg.has(m) && n !== void 0) { let e = On(d); h = yn(n.location.pathname, e + h) } else h = yn(m, h); return (l || g) && (h = wn(h)), p && (h = `${h}#${p}`), h } async function rr(e, t, r) { if (!e.path || !t) return !1; let i = `${r.slug ? `/${r.slug}` : ``}${Cn(e.path, t)}`; return (await fetch(i, { method: `HEAD`, redirect: `manual` })).type === `opaqueredirect` ? (n.location.href = n.location.origin + i, !0) : !1 } function ir() { let e = ln(); return o(t => ar({ ...t, collectionUtils: e }), [e]) } async function ar(e) { let t = await Dn(e); if (t) { try { localStorage.preferredLocale = e.nextLocale.code } catch { } try { if (!L(t.path)) throw Error(`Expected result.path to be a string`); if (t.isMissingInLocale && await rr(e.route, t.pathVariables, e.nextLocale)) return } catch { } return t } } function or() { let e = c(Promise.resolve()), t = c(), r = o(n => { if (n.navigationType === `traverse` || !n.canIntercept) return; let r = t.current; r?.signal.addEventListener(`abort`, () => { r.abort(`user aborted`) }), n.intercept({ handler: () => e.current }) }, []); return o((i, a, o) => { if (!Hg) { a(); return } e.current = i, t.current = o, n.navigation.addEventListener(`navigate`, r), a(!0), i.finally(() => { n.navigation.removeEventListener(`navigate`, r) }) }, [r]) } function sr(e) { let t = 0, n = e.length; for (; t < n && e[t] === `-`;)t++; for (; n > t && e[n - 1] === `-`;)n--; return e.slice(t, n) } function cr(e) { return sr(e.trim().toLowerCase().replace(Ug, `-`)) } function lr({ children: e, value: t }) { return m(Gg.Provider, { value: t, children: e }) } function ur() { return t(Gg) } function dr(e, t) { let n = i(() => ({ inputs: t, result: e() }))[0], r = c(!0), a = c(n), o = r.current || t && a.current.inputs && Ct(t, a.current.inputs, !1) ? a.current : { inputs: t, result: e() }; return s(() => { r.current = !1, a.current = o }, [o]), o.result } function fr(e, t) { return dr(() => e, t) } function pr() { return p.useContext(Jg) } function mr() { return pr().activeLocale?.code ?? `en-US` } function hr({ children: e }) { let [t, r] = i(``), a = ur(); s(() => { if (a === `preview`) return; _(() => { r(n.location.search) }); let e = () => { _(() => { r(n.location.search) }) }; return n.addEventListener(`popstate`, e), () => { n.removeEventListener(`popstate`, e) } }, []); let c = o(async e => { if (a === `preview`) { _(() => { r(t => e(new URLSearchParams(t)).toString()) }); return } await mn({ continueAfter: `paint` }); let t = n.history.state, i = new URL(n.location.href), o = e(i.searchParams).toString(); i.search = o, Zn(t, i.toString()), _(() => { r(o) }) }, []), l = dr(() => ({ urlSearchParams: new URLSearchParams(t), replaceSearchParams: c }), [t, c]); return m(Xg.Provider, { value: l, children: e }) } function gr() { if (!Zg) return; $g = !0, performance.mark(`framer-react-event-handling-start`); let e = { capture: !0 }, t = document.body; Zg.forEach(n => t.addEventListener(n, Qg, e)) } function _r() { return s(() => { if (!$g || !Zg) return; let e = { capture: !0 }, t = document.body; Zg.forEach(n => t.removeEventListener(n, Qg, e)), Zg = void 0, performance.mark(`framer-react-event-handling-end`) }, []), null } function vr(e) { let t = !1; return function (...n) { if (!t) return t = !0, e.apply(this, n) } } function yr(e, t, n) { try { performance.measure(e, t, n) } catch (t) { console.warn(`Could not measure ${e}`, t) } } function br() { y_ = new v_, y_.render.markStart() } function xr() { d(() => { y_?.useInsertionEffects.markRouterStart() }, []), A(() => { y_?.useLayoutEffects.markRouterStart() }, []), s(() => { y_?.useEffects.markRouterStart() }, []) } function Sr() { d(() => { y_?.render.markEnd(), y_?.useInsertionEffects.markStart() }, []), A(() => { if (y_?.useLayoutEffects.markStart(), document.visibilityState !== `visible`) { b_ = !0; return } ke.read(() => { y_?.browserRendering.requestAnimationFrame.markStart(), y_?.unattributedHydrationOverhead.measure() }) }, []), s(() => { y_?.useEffects.markStart(), y_?.browserRendering.hasStarted || (y_?.mutationEffects.measure(), y_?.useEffects.markAreSynchronous()) }, []) } function Cr() { d(() => { y_?.useInsertionEffects.markEnd() }, []), A(() => { y_?.useLayoutEffects.markEnd(), !(b_ || document.visibilityState !== `visible`) && ke.read(() => { y_?.browserRendering.requestAnimationFrame.markEnd(), mn().then(() => { y_?.browserRendering.layoutStylePaint.markEnd() }) }) }, []), s(() => { y_?.useEffects.markEnd() }, []) } function wr() { return Sr(), null } function Tr() { return Cr(), null } function Er(e, t) { let n = { style: t, "data-framer-root": `` }; return p.isValidElement(e) ? p.cloneElement(e, n) : m(e, { ...n }) } function Dr() { return w_ } function Or(e) { if (T_?.lastRoutes !== e) { let t = {}, n = {}, r = [], i = {}, a = e; for (let r in e) { let i = e[r]; B(i, `route must be defined`); let { path: a, pathLocalized: o } = i; if (a && (t[a] = { path: a, depth: jr(a), routeId: r }, o)) for (let e in o) { let t = o[e]; B(t, `localizedPath must be defined`); let i = jr(t), a = n[e] ||= {}; a[t] = { path: t, depth: i, routeId: r } } } for (let e in r = Object.values(t), r.sort(({ depth: e }, { depth: t }) => t - e), n) { let t = n[e]; if (!t) continue; let r = Object.values(t); r.sort(({ depth: e }, { depth: t }) => t - e), i[e] = r } T_ = { pathRoutes: t, pathRoutesLocalized: n, paths: r, pathsLocalized: i, lastRoutes: a } } return { pathRoutes: T_.pathRoutes, paths: T_.paths, pathRoutesLocalized: T_.pathRoutesLocalized, pathsLocalized: T_.pathsLocalized } } function kr(e, t, n = !0, r = Dr()) { return Ar(e, t, r, n) } function Ar(e, t, n, r = !0) { let { pathRoutes: i, paths: a, pathRoutesLocalized: o, pathsLocalized: s } = Or(e), c, l, u = !1; if (n.length > 0) { let e = t.split(`/`).find(Boolean); if (e && (c = n.find(({ slug: t }) => t === e), c && (l = c.id, t = t.substring(c.slug.length + 1), u = !0)), !l) { let e = n.find(({ slug: e }) => e === ``); e && (l = e.id) } } if (l && u) { let e = o[l], n = e ? e[t] : void 0; if (n) { let e = Mr(t, n.path); if (e.isMatch) return { routeId: n.routeId, localeId: l, pathVariables: e.pathVariables } } } let d = i[t]; if (d) { let e = Mr(t, d.path); if (e.isMatch) return { routeId: d.routeId, localeId: l, pathVariables: e.pathVariables } } if (l && u) { let e = s[l]; if (e) for (let { path: n, routeId: r } of e) { let e = Mr(t, n); if (e.isMatch) return { routeId: r, localeId: l, pathVariables: e.pathVariables } } } for (let { path: e, routeId: n } of a) { let r = Mr(t, e); if (r.isMatch) return { routeId: n, localeId: l, pathVariables: r.pathVariables } } if (!r) throw Error(`No exact match found for path`); let f = i[`/`]; if (f) return { routeId: f.routeId, localeId: l }; let p = Object.keys(e)[0]; if (!p) throw Error(`Router should not have undefined routes`); return { routeId: p, localeId: l } } function jr(e) { let t = e.replace(/^\/|\/$/gu, ``); return t === `` ? 0 : t.split(`/`).length } function Mr(e, t) { let n = [], r = Nr(t).replace(Dg, (e, t) => (n.push(t), `([^/]+)`)), i = RegExp(r + `$`), a = e.match(i); if (!a) return { isMatch: !1 }; if (a.length === 1) return { isMatch: !0 }; let o = {}, s = a.slice(1); for (let e = 0; e < n.length; ++e) { let t = n[e]; if (t === void 0) continue; let r = s[e], i = o[t]; if (i) { if (i !== r) return { isMatch: !1 }; continue } if (r === void 0) throw Error(`Path variable values cannot be undefined`); o[t] = r } return { isMatch: !0, pathVariables: o } } function Nr(e) { return e.replace(/[|\\{}()[\]^$+*?.]/gu, `\\$&`).replace(/-/gu, `\\x2d`) } function Pr() { if (`PerformanceServerTiming` in n) { let e = performance.getEntriesByType(`navigation`)[0]?.serverTiming; if (!e || e.length === 0) return new URLSearchParams; let t = e.find(e => e.name === `abtests`); return t ? new URLSearchParams(t.description) : new URLSearchParams } return new URLSearchParams } function Fr(e, t, n) { let r = e[n]; if (!r) return; let i = r.abTestingParentId ?? n; if (!e[i]) return; let { abTestingParentId: a, ...o } = r, s = e[i].elements || r.elements ? { ...e[i].elements, ...r.elements } : void 0; e[i] = { ...o, elements: s, abTestingVariantId: n, abTestId: t } } function Ir(e, t) { for (let [n, r] of t) Fr(e, n, r) } function Lr(e) { for (let t in e) e[t]?.abTestingParentId && delete e[t] } function Rr(e, t) { if (!e[t] || !e[t].abTestingParentId) return; let n = e[t].abTestingParentId, { abTestingParentId: r, ...i } = e[t], a = e[n]?.elements || i.elements ? { ...e[n]?.elements, ...i.elements } : void 0; e[n] = { ...i, elements: a, abTestingVariantId: t } } function zr(e, t) { if (n === void 0) return t; let r = t; if (t) { Rr(e, t); let n = e[t]?.abTestingParentId; n && (r = n) } return Ir(e, Pr()), Lr(e), r } function Br(e) { s(() => { if (e.robots) { let t = document.querySelector(`meta[name="robots"]`); t ? t.setAttribute(`content`, e.robots) : (t = document.createElement(`meta`), t.setAttribute(`name`, `robots`), t.setAttribute(`content`, e.robots), document.head.appendChild(t)) } }, [e.robots]), d(() => { document.title = e.title || ``, e.viewport && document.querySelector(`meta[name="viewport"]`)?.setAttribute(`content`, e.viewport) }, [e.title, e.viewport]) } function Vr(e, ...t) { E_.has(e) || (E_.add(e), console.warn(e, ...t)) } function Hr(e, t, n) { Vr(`Deprecation warning: ${e} will be removed in version ${t}${n ? `, use ${n} instead` : ``}.`) } function Ur(e) { return typeof e == `object` && !!e && k_ in e && e[k_] instanceof Function && A_ in e && e[A_] instanceof Function } function Wr(e, t) { return { interpolate(e, n) { let r = e.get(), i = n.get(), a = O_(r); return e => { let n = t.interpolate(r, i)(e); return a.set(n), a } }, difference(e, n) { let r = e.get(); return t.difference(r, n.get()) } } } function Gr(e, t) { let n = 10 ** Math.round(Math.abs(t)); return Math.round(e * n) / n } function Kr(e, t) { return t === 0 ? Math.round(e) : (t -= t | 0, t < 0 && (t = 1 - t), Math.round(e - t) + t) } function qr(e) { return Math.round(e * 2) / 2 } function Jr(e, t) { return { x: e, y: t } } function Yr(e, t, n, r = !1) { let [i, a] = t, [o, s] = n, c = a - i; if (c === 0) return (s + o) / 2; let l = s - o; if (l === 0) return o; let u = o + (e - i) / c * l; if (r === !0) if (o < s) { if (u < o) return o; if (u > s) return s } else { if (u > o) return o; if (u < s) return s } return u } function Xr(e) { return !Number.isNaN(e) && Number.isFinite(e) } function Zr(e) { let t = Qr(e); return t === void 0 ? 0 : e.includes(`%`) ? t / 100 : t } function Qr(e) { let t = /\d?\.?\d+/u.exec(e); return t ? Number(t[0]) : void 0 } function $r(e, t, n) { return N_.rgb_r = e / 255, N_.rgb_g = t / 255, N_.rgb_b = n / 255, N_.rgbToHsluv(), { h: N_.hsluv_h, s: N_.hsluv_s, l: N_.hsluv_l } } function ei(e, t, n, r = 1) { return N_.hsluv_h = e, N_.hsluv_s = t, N_.hsluv_l = n, N_.hsluvToRgb(), { r: N_.rgb_r * 255, g: N_.rgb_g * 255, b: N_.rgb_b * 255, a: r } } function ti(e, t, n, r) { let i = Math.round(e), a = Math.round(t * 100), o = Math.round(n * 100); return r === void 0 || r === 1 ? `hsv(` + i + `, ` + a + `%, ` + o + `%)` : `hsva(` + i + `, ` + a + `%, ` + o + `%, ` + r + `)` } function ni(e, t, n) { return { r: Xr(e) ? li(e, 255) * 255 : 0, g: Xr(t) ? li(t, 255) * 255 : 0, b: Xr(n) ? li(n, 255) * 255 : 0 } } function ri(e, t, n, r) { let i = [fi(Math.round(e).toString(16)), fi(Math.round(t).toString(16)), fi(Math.round(n).toString(16))]; return r && i[0].charAt(0) === i[0].charAt(1) && i[1].charAt(0) === i[1].charAt(1) && i[2].charAt(0) === i[2].charAt(1) ? i[0].charAt(0) + i[1].charAt(0) + i[2].charAt(0) : i.join(``) } function ii(e, t, n) { let r, i, a = li(e, 255), o = li(t, 255), s = li(n, 255), c = Math.max(a, o, s), l = Math.min(a, o, s), u = i = r = (c + l) / 2; if (c === l) u = i = 0; else { let e = c - l; switch (i = r > .5 ? e / (2 - c - l) : e / (c + l), c) { case a: u = (o - s) / e + (o < s ? 6 : 0); break; case o: u = (s - a) / e + 2; break; case s: u = (a - o) / e + 4; break }u /= 6 } return { h: u * 360, s: i, l: r } } function ai(e, t, n) { return n < 0 && (n += 1), n > 1 && --n, n < 1 / 6 ? e + (t - e) * 6 * n : n < 1 / 2 ? t : n < 2 / 3 ? e + (t - e) * (2 / 3 - n) * 6 : e } function oi(e, t, n) { let r, i, a; if (e = li(e, 360), t = li(t * 100, 100), n = li(n * 100, 100), t === 0) r = i = a = n; else { let o = n < .5 ? n * (1 + t) : n + t - n * t, s = 2 * n - o; r = ai(s, o, e + 1 / 3), i = ai(s, o, e), a = ai(s, o, e - 1 / 3) } return { r: r * 255, g: i * 255, b: a * 255 } } function si(e, t, n) { e = li(e, 255), t = li(t, 255), n = li(n, 255); let r = Math.max(e, t, n), i = Math.min(e, t, n), a = r - i, o = 0, s = r === 0 ? 0 : a / r, c = r; if (r === i) o = 0; else { switch (r) { case e: o = (t - n) / a + (t < n ? 6 : 0); break; case t: o = (n - e) / a + 2; break; case n: o = (e - t) / a + 4; break }o /= 6 } return { h: o, s, v: c } } function ci(e, t, n) { e = li(e, 360) * 6, t = li(t * 100, 100), n = li(n * 100, 100); let r = Math.floor(e), i = e - r, a = n * (1 - t), o = n * (1 - i * t), s = n * (1 - (1 - i) * t), c = r % 6, l = [n, o, a, a, s, n][c], u = [s, n, n, o, a, a][c], d = [a, a, s, n, n, o][c]; return { r: l * 255, g: u * 255, b: d * 255 } } function li(e, t) { let n, r; if (n = typeof t == `string` ? parseFloat(t) : t, typeof e == `string`) { ui(e) && (e = `100%`); let t = di(e); r = Math.min(n, Math.max(0, parseFloat(e))), t && (r = Math.floor(r * n) / 100) } else r = e; return Math.abs(r - n) < 1e-6 ? 1 : r % n / n } function ui(e) { return typeof e == `string` && e.includes(`.`) && parseFloat(e) === 1 } function di(e) { return typeof e == `string` && e.includes(`%`) } function fi(e) { return e.length === 1 ? `0` + e : `` + e } function pi(e) { if (e.includes(`gradient(`) || e.includes(`var(`)) return !1; let t = e.replace(/^[\s,#]+/u, ``).trimEnd().toLowerCase(), n = M_[t]; if (n && (t = n), t === `transparent`) return { r: 0, g: 0, b: 0, a: 0, format: `name` }; let r; return (r = P_.rgb.exec(t)) ? { r: parseInt(r[1] ?? ``), g: parseInt(r[2] ?? ``), b: parseInt(r[3] ?? ``), a: 1, format: `rgb` } : (r = P_.rgba.exec(t)) ? { r: parseInt(r[1] ?? ``), g: parseInt(r[2] ?? ``), b: parseInt(r[3] ?? ``), a: parseFloat(r[4] ?? ``), format: `rgb` } : (r = P_.hsl.exec(t)) ? { h: parseInt(r[1] ?? ``), s: Zr(r[2] ?? ``), l: Zr(r[3] ?? ``), a: 1, format: `hsl` } : (r = P_.hsla.exec(t)) ? { h: parseInt(r[1] ?? ``), s: Zr(r[2] ?? ``), l: Zr(r[3] ?? ``), a: parseFloat(r[4] ?? ``), format: `hsl` } : (r = P_.hsv.exec(t)) ? { h: parseInt(r[1] ?? ``), s: Zr(r[2] ?? ``), v: Zr(r[3] ?? ``), a: 1, format: `hsv` } : (r = P_.hsva.exec(t)) ? { h: parseInt(r[1] ?? ``), s: Zr(r[2] ?? ``), v: Zr(r[3] ?? ``), a: parseFloat(r[4] ?? ``), format: `hsv` } : (r = P_.hex8.exec(t)) ? { r: mi(r[1] ?? ``), g: mi(r[2] ?? ``), b: mi(r[3] ?? ``), a: hi(r[4] ?? ``), format: n ? `name` : `hex` } : (r = P_.hex6.exec(t)) ? { r: mi(r[1] ?? ``), g: mi(r[2] ?? ``), b: mi(r[3] ?? ``), a: 1, format: n ? `name` : `hex` } : (r = P_.hex4.exec(t)) ? { r: mi(`${r[1]}${r[1]}`), g: mi(`${r[2]}${r[2]}`), b: mi(`${r[3]}${r[3]}`), a: hi(r[4] + `` + r[4]), format: n ? `name` : `hex` } : (r = P_.hex3.exec(t)) ? { r: mi(`${r[1]}${r[1]}`), g: mi(`${r[2]}${r[2]}`), b: mi(`${r[3]}${r[3]}`), a: 1, format: n ? `name` : `hex` } : !1 } function mi(e) { return parseInt(e, 16) } function hi(e) { return mi(e) / 255 } function gi(e) { let t = F_.exec(e); if (!t) return null; let { r: n = `0`, g: r = `0`, b: i = `0`, a } = t.groups ?? {}; return { r: parseFloat(n), g: parseFloat(r), b: parseFloat(i), a: a ? parseFloat(a) : 1 } } function _i(e = 0) { let t = Math.abs(e); return t <= .04045 ? e / 12.92 : (Math.sign(e) || 1) * ((t + .055) / 1.055) ** 2.4 } function vi({ r: e, g: t, b: n, a: r }) { return { r: _i(e), g: _i(t), b: _i(n), a: r } } function yi(e = 0) { let t = Math.abs(e); return t > .0031308 ? (Math.sign(e) || 1) * (1.055 * t ** (1 / 2.4) - .055) : e * 12.92 } function bi({ r: e, g: t, b: n, a: r }) { return { r: yi(e), g: yi(t), b: yi(n), a: r } } function xi({ r: e, g: t, b: n, a: r }) { let i = Math.max(e, t, n), a = Math.min(e, t, n), o = { h: 0, s: i === 0 ? 0 : 1 - a / i, v: i, a: r }; return i - a !== 0 && (o.h = (i === e ? (t - n) / (i - a) + (t < n ? 6 : 0) : i === t ? (n - e) / (i - a) + 2 : (e - t) / (i - a) + 4) * 60), o } function Si(e) { return (e %= 360) < 0 ? e + 360 : e } function Ci({ h: e = 0, s: t = 0, v: n = 0, a: r = 1 }) { let i = Si(e), a = Math.abs(i / 60 % 2 - 1); switch (Math.floor(i / 60)) { case 0: return { r: n, g: n * (1 - t * a), b: n * (1 - t), a: r }; case 1: return { r: n * (1 - t * a), g: n, b: n * (1 - t), a: r }; case 2: return { r: n * (1 - t), g: n, b: n * (1 - t * a), a: r }; case 3: return { r: n * (1 - t), g: n * (1 - t * a), b: n, a: r }; case 4: return { r: n * (1 - t * a), g: n * (1 - t), b: n, a: r }; case 5: return { r: n, g: n * (1 - t), b: n * (1 - t * a), a: r }; default: return { r: n * (1 - t), g: n * (1 - t), b: n * (1 - t), a: r } } } function wi(e) { return z_(R_(e)) } function Ti(e) { return L_(I_(e)) } function Ei(e, t, n, r = 1) { let i; return typeof e == `number` && !Number.isNaN(e) && typeof t == `number` && !Number.isNaN(t) && typeof n == `number` && !Number.isNaN(n) ? i = ki({ r: e, g: t, b: n, a: r }) : typeof e == `string` ? i = Di(e) : typeof e == `object` && (i = e.hasOwnProperty(`r`) && e.hasOwnProperty(`g`) && e.hasOwnProperty(`b`) ? ki(e) : Ai(e)), i } function Di(e) { let t = pi(e); if (t) return t.format === `hsl` ? Ai(t) : t.format === `hsv` ? Oi(t) : ki(t) } function Oi(e) { let t = ci(e.h, e.s, e.v); return { ...ii(t.r, t.g, t.b), ...t, format: `rgb`, a: e.a === void 0 ? 1 : ji(e.a) } } function ki(e) { let t = ni(e.r, e.g, e.b); return { ...ii(t.r, t.g, t.b), ...t, format: `rgb`, a: e.a === void 0 ? 1 : ji(e.a) } } function Ai(e) { let t, n, r, i = { r: 0, g: 0, b: 0 }, a = { h: 0, s: 0, l: 0 }; return t = Xr(e.h) ? e.h : 0, t = (t + 360) % 360, n = Xr(e.s) ? e.s : 1, typeof e.s == `string` && (n = Qr(e.s)), r = Xr(e.l) ? e.l : .5, typeof e.l == `string` && (r = Qr(e.l)), i = oi(t, n, r), a = { h: t, s: n, l: r }, { ...i, ...a, a: e.a === void 0 ? 1 : e.a, format: `hsl` } } function ji(e) { return e = parseFloat(e), e < 0 && (e = 0), (Number.isNaN(e) || e > 1) && (e = 1), e } function Mi({ children: e }) { if (t($_).top) return m(E, { children: e }); let n = c({ byId: {}, byName: {}, byLastId: {}, byPossibleId: {}, byLastName: {}, byLayoutId: {}, count: { byId: {}, byName: {} } }), r = c({ byId: {}, byName: {}, byLastId: {}, byPossibleId: {}, byLastName: {}, byLayoutId: {} }), i = c(new Set).current, a = c({ getLayoutId: o(({ id: e, name: t, duplicatedFrom: a }) => { if (!e) return null; let o = t ? `byName` : `byId`, s = n.current[o][e]; if (s) return s; let c = t || e; if (!a && !i.has(c) && (!n.current.byLayoutId[c] || n.current.byLayoutId[c] === c)) return n.current.count[o][c] === void 0 && (n.current.count[o][c] = 0, n.current.byLayoutId[c] = c, r.current[o][e] = c), i.add(c), c; let l; if (a?.length) for (let s = a.length - 1; s >= 0; s--) { let c = a[s]; B(!!c, `duplicatedId must be defined`); let u = n.current[o][c], d = n.current.byLastId[c]; if (d && !l) { let e = n.current.byLayoutId[d], r = !e || e === t; d && !i.has(d) && (!t || r) && (l = [d, c]) } let f = u ? n.current.byLayoutId[u] : void 0, p = !f || f === t; if (u && !i.has(u) && (!t || p)) return r.current[o][e] = u, r.current.byLastId[c] = u, i.add(u), u } let u = n.current.byLastId[e]; if (u && !i.has(u)) return i.add(u), r.current.byId[e] = u, u; if (l) { let [t, n] = l; return r.current[o][e] = t, r.current.byLastId[n] = t, i.add(t), t } let d = n.current.byPossibleId[e]; if (d && !i.has(d)) return i.add(d), r.current.byId[e] = d, d; let f = a?.[0], p = t || f || e, { layoutId: m, value: h } = Ni(p, (n.current.count[o][p] ?? -1) + 1, i); if (n.current.count[o][p] = h, r.current[o][e] = m, a?.length && !t) { let e = a[a.length - 1]; if (e && (r.current.byLastId[e] = m), a.length > 1) for (let e = 0; e < a.length - 1; e++) { let t = a[e]; t !== void 0 && (r.current.byPossibleId[t] || (r.current.byPossibleId[t] = m)) } } return r.current.byLayoutId[m] = c, i.add(m), m }, []), persistLayoutIdCache: o(() => { n.current = { byId: { ...n.current.byId, ...r.current.byId }, byLastId: { ...n.current.byLastId, ...r.current.byLastId }, byPossibleId: { ...n.current.byPossibleId, ...r.current.byPossibleId }, byName: { ...n.current.byName, ...r.current.byName }, byLastName: { ...n.current.byLastName, ...r.current.byLastName }, byLayoutId: { ...n.current.byLayoutId, ...r.current.byLayoutId }, count: { ...n.current.count, byName: {} } }, r.current = { byId: {}, byName: {}, byLastId: {}, byPossibleId: {}, byLastName: {}, byLayoutId: {} }, i.clear() }, []), top: !0, enabled: !0 }).current; return m($_.Provider, { value: a, children: e }) } function Ni(e, t, n) { let r = t, i = r ? `${e}-${r}` : e; for (; n.has(i);)r++, i = `${e}-${r}`; return { layoutId: i, value: r } } function Pi({ enabled: e = !0, ...n }) { let r = t($_), i = b(() => ({ ...r, enabled: e }), [e]); return m($_.Provider, { ...n, value: i }) } function Fi(e) { let t = c(null); return t.current === null && (t.current = e()), t.current } function Ii(e) { let { error: t, file: n } = e, r = n ? `Error in ${Li(n)}` : `Error`, i = t instanceof Error ? t.message : `` + t; return S(`div`, { style: tv, children: [m(`div`, { className: `text`, style: rv, children: r }), i && m(`div`, { className: `text`, style: iv, children: i })] }) } function Li(e) { return e.startsWith(`./`) ? e.replace(`./`, ``) : e } function H(e) { return Number.isFinite(e) } function Ri(e) { return !e || !Object.keys(e).length && e.constructor === Object } function zi(e) { return typeof e != `string` && typeof e != `number` } function Bi(e) { return e != null && typeof e != `boolean` && !Ri(e) } function Vi(e) { return e * (Math.PI / 180) } function Hi(e) { return $e(e) ? !1 : e === 2 || e === 5 } function Ui(e) { if (typeof e == `string`) { let t = e.trim(); if (t === `auto`) return 2; if (t.endsWith(`fr`)) return 3; if (t.endsWith(`%`)) return 1; if (t.endsWith(`vw`) || t.endsWith(`vh`)) return 4 } return 0 } function Wi(e, t, n, r) { if (typeof t == `string`) { if (t.endsWith(`%`) && n) switch (e) { case `maxWidth`: case `minWidth`: return parseFloat(t) / 100 * n.width; case `maxHeight`: case `minHeight`: return parseFloat(t) / 100 * n.height; default: break }if (t.endsWith(`vh`)) { if (!r) return Gi(e); switch (e) { case `maxWidth`: case `minWidth`: return parseFloat(t) / 100 * r.width; case `maxHeight`: case `minHeight`: return parseFloat(t) / 100 * r.height; default: break } } return parseFloat(t) } return t } function Gi(e) { switch (e) { case `minWidth`: case `minHeight`: return -1 / 0; case `maxWidth`: case `maxHeight`: return 1 / 0; default: V(e, `unknown constraint key`) } } function Ki(e, t, n, r) { return t.minHeight && (e = Math.max(Wi(`minHeight`, t.minHeight, n, r), e)), t.maxHeight && (e = Math.min(Wi(`maxHeight`, t.maxHeight, n, r), e)), e } function qi(e, t, n, r) { return t.minWidth && (e = Math.max(Wi(`minWidth`, t.minWidth, n, r), e)), t.maxWidth && (e = Math.min(Wi(`maxWidth`, t.maxWidth, n, r), e)), e } function Ji(e, t, n, r, i) { let a = qi(H(e) ? e : lv, n, r, i), o = Ki(H(t) ? t : uv, n, r, i); return H(n.aspectRatio) && n.aspectRatio > 0 && (H(n.left) && H(n.right) ? o = a / n.aspectRatio : H(n.top) && H(n.bottom) || n.widthType === 0 ? a = o * n.aspectRatio : o = a / n.aspectRatio), { width: a, height: o } } function Yi(e, t) { return !H(e) || !H(t) ? null : e + t } function Xi(e) { return typeof e.right == `string` || typeof e.bottom == `string` || typeof e.left == `string` && (!e.center || e.center === `y`) || typeof e.top == `string` && (!e.center || e.center === `x`) } function Zi(e) { return !e._constraints || Xi(e) ? !1 : e._constraints.enabled } function Qi(e) { let { size: t } = e, { width: n, height: r } = e; return H(t) && (n === void 0 && (n = t), r === void 0 && (r = t)), H(n) && H(r) ? { width: n, height: r } : null } function $i(e) { let t = Qi(e); if (t === null) return null; let { left: n, top: r } = e; return H(n) && H(r) ? { x: n, y: r, ...t } : null } function ea(e, t, n = !0) { if (e.positionFixed || e.positionAbsolute) return null; let r = t === 1 || t === 2; if (!Zi(e) || r) return $i(e); let i = ta(e), a = na(t), o = a ? { sizing: a, positioning: a, viewport: null } : null; return cv.toRect(i, o, null, n, null) } function ta(e) { let { left: t, right: n, top: r, bottom: i, center: a, _constraints: o, size: s } = e, { width: c, height: l } = e; c === void 0 && (c = s), l === void 0 && (l = s); let { aspectRatio: u, autoSize: d } = o, f = sv.quickfix({ left: H(t), right: H(n), top: H(r), bottom: H(i), widthType: Ui(c), heightType: Ui(l), aspectRatio: u || null, fixedSize: d === !0 }), p = null, m = null, h = 0, g = 0; if (f.widthType !== 0 && typeof c == `string`) { let e = parseFloat(c); c.endsWith(`fr`) ? (h = 3, p = e) : c === `auto` ? h = 2 : (h = 1, p = e / 100) } else c !== void 0 && typeof c != `string` && (p = c); if (f.heightType !== 0 && typeof l == `string`) { let e = parseFloat(l); l.endsWith(`fr`) ? (g = 3, m = e) : l === `auto` ? g = 2 : (g = 1, m = parseFloat(l) / 100) } else l !== void 0 && typeof l != `string` && (m = l); let _ = .5, v = .5; return (a === !0 || a === `x`) && (f.left = !1, typeof t == `string` && (_ = parseFloat(t) / 100)), (a === !0 || a === `y`) && (f.top = !1, typeof r == `string` && (v = parseFloat(r) / 100)), { left: f.left ? t : null, right: f.right ? n : null, top: f.top ? r : null, bottom: f.bottom ? i : null, widthType: h, heightType: g, width: p, height: m, aspectRatio: f.aspectRatio || null, centerAnchorX: _, centerAnchorY: v, minHeight: e.minHeight, maxHeight: e.maxHeight, minWidth: e.minWidth, maxWidth: e.maxWidth } } function na(e) { return e === 0 || e === 1 || e === 2 ? null : e } function ra() { return p.useContext(dv).parentSize } function ia(e) { return typeof e == `object` } function aa(e) { return ia(e) ? e.width : e } function oa(e) { return ia(e) ? e.height : e } function sa(e, t) { return m(fv, { parentSize: t, children: e }) } function ca(e) { return ea(e, ra(), !0) } function la({ width: e, height: t }) { return e === `auto` || e === `min-content` || t === `auto` || t === `min-content` } function ua() { return j === void 0 ? void 0 : j } function da() { let e = ua(); return e ? mv.test(e.platform) : !1 } function fa() { let e = ua(); return e ? hv.test(e.platform) ? !0 : gv.test(e.platform) && e.maxTouchPoints != null && e.maxTouchPoints > 2 : !1 } function pa() { return da() || fa() } function ma() { let e = ua(); return e ? _v.test(e.userAgent) : !1 } function ha() { let e = ua(); return e ? vv.test(e.userAgent) && yv.test(e.vendor) && !ma() : !1 } function ga() { let e = ua(); return e ? bv.test(e.userAgent) && xv.test(e.vendor) : !1 } function _a() { let e = ua(); return e ? Sv.test(e.userAgent) : !1 } function va() { return typeof document == `object` } function ya() { let e = ua(); return e ? Cv.test(e.userAgent) : !1 } function ba() { return !1 } function xa() { let e = ua(); return e && wv.test(e.userAgent) ? `tablet` : e && Tv.test(e.userAgent) ? `phone` : `desktop` } function Sa() { return xa() === `desktop` } function Ca(e) { return pa() ? e.metaKey : e.ctrlKey } function wa(e, t, n = Dv) { if (!(!e || n.has(e) || typeof document > `u`)) { if (n.add(e), !t) { if (!Ov) { let e = document.createElement(`style`); if (e.setAttribute(`type`, `text/css`), e.setAttribute(`data-framer-css`, `true`), !document.head) { console.warn(`not injecting CSS: the document is missing a <head> element`); return } if (document.head.appendChild(e), e.sheet) Ov = e.sheet; else { console.warn(`not injecting CSS: injected <style> element does not have a sheet`, e); return } } t = Ov } try { t.insertRule(e, t.cssRules.length) } catch { } } } function Ta() { if (Fv !== void 0) return Fv; let e = document.createElement(`div`); Object.assign(e.style, { position: `absolute`, display: `flex`, flexDirection: `column`, rowGap: `1px` }), e.appendChild(document.createElement(`div`)), e.appendChild(document.createElement(`div`)), document.body.appendChild(e); let t = e.scrollHeight === 1; return e.parentNode && e.parentNode.removeChild(e), Fv = t, t } function Ea() { Lv || (Lv = !0, !Ta() && document.body.classList.add(Iv)) } function Da(e) { return typeof e == `number` ? e : e.startsWith(`--`) ? Z.variable(e) : e === `` ? `""` : e } function Oa(e) { return e !== Jv && e !== Yv } function ka(e) { for (let t in e) if (Oa(t) && e?.[t] === !0) return !0; return !1 } function Aa(e, t, n, r, i) { let a = p.useRef(null), o = p.useCallback(e => { t && a.current !== !1 && (a.current = !1, e.currentTarget.setCustomValidity(` `), e.currentTarget.reportValidity(), t(e)) }, [t]), s = p.useCallback(r => { if (n?.(r), !t && !e) return; let i = r.target.validity; a.current === !1 && !ka(i) && (r.currentTarget.setCustomValidity(``), r.target.reportValidity(), a.current = !0, e?.()) }, [t, e, n]), c = p.useCallback(e => { if (!t) { r?.(e); return } if (a.current === !1) return; let n = e.currentTarget.validity; if (ka(n)) { o(e); return } r?.(e) }, [o, r, t]); return p.useMemo(() => ({ onInvalid: o, onChange: s, onBlur: c, onFocus: i }), [o, s, c, i]) } function ja(e, t) { return Z.variable(...e.flatMap(e => [`${e}-rgb`, e]), t) } function Ma(e, t) { return `${e} > ${t}, ${e} > .ssr-variant > ${t}` } function Na() { return J.current() === J.preview ? Gy : Wy } function Pa(e) { return Mv(e, Na, `framer-lib-combinedCSSRules`) } function Fa(e) { return z(e) || Ye(e) } function Ia(e) { return !!e && Ky in e && e[Ky] === !0 } function La(e) { try { switch (e.type) { case `string`: case `collectionreference`: case `color`: case `date`: case `link`: case `boxshadow`: case `padding`: case `borderradius`: case `gap`: return L(e.defaultValue) ? e.defaultValue : void 0; case `boolean`: return Xe(e.defaultValue) ? e.defaultValue : void 0; case `enum`: return $e(e.defaultValue) ? void 0 : e.options.includes(e.defaultValue) ? e.defaultValue : void 0; case `fusednumber`: case `number`: return R(e.defaultValue) ? e.defaultValue : void 0; case `transition`: return z(e.defaultValue) ? e.defaultValue : void 0; case `border`: return z(e.defaultValue) ? e.defaultValue : void 0; case `font`: return z(e.defaultValue) ? e.defaultValue : void 0; case `linkrelvalues`: return Ze(e.defaultValue) ? e.defaultValue : void 0; case `multicollectionreference`: return Ze(e.defaultValue) ? e.defaultValue : void 0; case `object`: { let t = z(e.defaultValue) ? e.defaultValue : {}; return z(e.controls) && Ra(t, e.controls), t } case `array`: return Ze(e.defaultValue) ? e.defaultValue : void 0; case `file`: case `image`: case `richtext`: case `pagescope`: case `eventhandler`: case `segmentedenum`: case `responsiveimage`: case `componentinstance`: case `slot`: case `scrollsectionref`: case `customcursor`: case `cursor`: case `trackingid`: case `vectorsetitem`: return; default: return } } catch { return } } function Ra(e, t) { for (let n in t) { let r = t[n]; if (!r) continue; let i = e[n]; if (!$e(i) || Ia(r)) continue; let a = La(r); $e(a) || (e[n] = a) } } function za(e) { if (z(e.defaultProps)) return e.defaultProps; let t = {}; return e.defaultProps = t, t } function Ba(e, t) { Fa(e) && Ra(za(e), t) } function Va(e, t) { Object.assign(e, { propertyControls: t }), Ba(e, t) } function Ha(e) { return e.propertyControls } function Ua() { let e = J.current(); return e === J.canvas || e === J.export } function Wa() { let [e] = i(() => Ua()); return e } function Ga(e) { let t = Object.create(Object.prototype); return n => (t[n] === void 0 && (t[n] = e(n)), t[n]) } function Ka(e, t) { if (e === void 0 || t === void 0) return; let n = e, r = t, i = 0; t > e && (n = t, r = e, i = 1); let a = n / r, o = []; for (let e of rb) { if (n <= e) return o; o.push({ maxSideSize: e, width: i === 0 ? e : Math.trunc(e / a) }) } return o } function qa(e, t) { try { let n = new URL(e); return t ? n.searchParams.set(`scale-down-to`, `${t}`) : n.searchParams.delete(`scale-down-to`), n.toString() } catch { return e } } function Ja(e, t, n) { if (!n || n.length === 0 || !t.pixelWidth) return; let r = []; for (let t of n) { if (t.width < ib) continue; let n = qa(e, t.maxSideSize); r.push(`${n} ${t.width}w`) } return r.push(`${qa(e, null)} ${t.pixelWidth}w`), r.join(`, `) || void 0 } function Ya(e, t, n) { if (!t.pixelWidth || !t.pixelHeight || !n?.width || !n?.height) return; let r = [], i = Math.max(t.pixelWidth, t.pixelHeight), a = Math.max(n.width / t.pixelWidth, n.height / t.pixelHeight); for (let t of nb) { let n = qa(e, Math.round(i * t * a)); r.push({ src: n, scale: t }) } return r } function Xa(e, t, n) { if (![`auto`, `lossless`].includes(t.preferredSize ?? ``)) return { src: n, srcSet: void 0 }; if (e) { let r = Ya(n, t, e); if (!r?.length) return { src: n, srcSet: void 0 }; let [i, ...a] = r; return { src: i?.src, srcSet: a.map(({ src: e, scale: t }) => `${e} ${t}x`).join(`, `) } } else return { src: n, srcSet: Ja(n, t, Ka(t.pixelWidth, t.pixelHeight)) } } function Za() { return { backgroundRepeat: `repeat`, backgroundPosition: `left top`, backgroundSize: `64px auto`, backgroundImage: ot(eb.imagePlaceholderSvg) } } function Qa(e) { switch (e) { case `fit`: return `contain`; case `stretch`: return `fill`; default: return `cover` } } function $a(e, t) { let n = e ?? `center`, r = t ?? `center`; return n === `center` && r === `center` ? `center` : n + ` ` + r } function eo(e) { return { display: `block`, width: `100%`, height: `100%`, ...tb, objectPosition: $a(e.positionX, e.positionY), objectFit: Qa(e.fit) } } function to(e) { let t = p.useRef(e ? `auto` : `async`), n = o(e => { t.current = `auto`, e.decoding = `auto` }, []), r = o(e => { n(e.currentTarget) }, [n]), i = o(e => { e?.complete && n(e) }, [n]); return { decoding: t.current, onImageLoad: r, onImageMount: i } } function no({ image: e, containerSize: t, nodeId: n, alt: r, draggable: i, avoidAsyncDecoding: a }) { let o = eb.useImageSource(e, t, n), s = eo(e), { decoding: c, onImageLoad: l, onImageMount: u } = to(a), { srcSet: d, src: f } = `srcSet` in e ? { src: o, srcSet: e.srcSet } : Xa(e.nodeFixedSize, e, o); return m(`img`, { ref: u, decoding: c, fetchpriority: e.fetchPriority, loading: e.loading, width: e.pixelWidth, height: e.pixelHeight, sizes: d ? e.sizes : void 0, srcSet: d, src: f, onLoad: l, alt: r ?? e.alt ?? ``, style: s, draggable: i }) } function ro({ image: e, containerSize: t, nodeId: n }) { let r = p.useRef(null), i = eb.useImageElement(e, t, n), a = eo(e); return p.useLayoutEffect(() => { let e = r.current; if (e !== null) return e.appendChild(i), () => { e.removeChild(i) } }, [i]), Object.assign(i.style, a), m(`div`, { ref: r, style: { display: `contents`, ...tb } }) } function io({ nodeId: e, image: t, containerSize: n }) { let r = p.useRef(null), i = eb.useImageSource(t, n, e); return p.useLayoutEffect(() => { let n = r.current; if (n === null) return; let a = eo(t); eb.renderOptimizedCanvasImage(n, i, a, e) }, [e, t, i]), m(`div`, { ref: r, style: { display: `contents`, ...tb } }) } function ao({ layoutId: e, image: t, ...n }) { e && (e += `-background`); let r = null, i = !!e, a = null; if (L(t.src)) if (t.fit === `tile` && t.pixelWidth && t.pixelHeight) { let e = R(t.backgroundSize) ? t.backgroundSize : 1, n = { width: Math.round(e * t.pixelWidth), height: Math.round(e * t.pixelHeight) }, o = qr(e * (t.pixelWidth / 2)), s = eb.useImageSource(t, n); r = { ...ab, backgroundImage: `url(${s})`, backgroundRepeat: `repeat`, backgroundPosition: $a(t.positionX, t.positionY), opacity: void 0, border: 0, backgroundSize: `${o}px auto` }, a = null, i = !0 } else a = J.current() === J.canvas ? eb.canRenderOptimizedCanvasImage(eb.useImageSource(t)) ? m(io, { image: t, ...n }) : m(ro, { image: t, ...n }) : m(no, { image: t, avoidAsyncDecoding: J.current() === J.export, ...n }); let o = a ? ab : r ?? { ...ab, ...Za() }; return i ? m(P.div, { layoutId: e, style: o, "data-framer-background-image-wrapper": !0, children: a }) : m(`div`, { style: o, "data-framer-background-image-wrapper": !0, children: a }) } function oo(e, t, n = !0) { let { borderWidth: r, borderStyle: i, borderColor: a } = e; if (!r) return; let o, s, c, l; if (typeof r == `number` ? o = s = c = l = r : (o = r.top || 0, s = r.bottom || 0, c = r.left || 0, l = r.right || 0), !(o === 0 && s === 0 && c === 0 && l === 0)) { if (n && o === s && o === c && o === l) { t.border = `${o}px ${i} ${a}`; return } t.borderStyle = e.borderStyle, t.borderColor = e.borderColor, t.borderTopWidth = `${o}px`, t.borderBottomWidth = `${s}px`, t.borderLeftWidth = `${c}px`, t.borderRightWidth = `${l}px` } } function so(e) { let t = e.layoutId ? `${e.layoutId}-border` : void 0; if (!e.borderWidth) return null; let n = { position: `absolute`, left: 0, right: 0, top: 0, bottom: 0, ...tb, pointerEvents: `none` }; return e.border ? (n.border = e.border, m(P.div, { style: n })) : (oo(e, n, !1), m(P.div, { "data-frame-border": !0, style: n, layoutId: t })) } function co(e, t) { let { _forwardedOverrideId: n, _forwardedOverrides: r, id: i } = t, a = n ?? i, o = r && a ? r[a] : void 0; return o && typeof o == `string` && (e = { ...e, src: o }), e } function lo(e) { let { background: t, image: n } = e; if (n !== void 0 && t && !sb.isImageObject(t)) return; let r = null; if (r = L(n) ? { alt: ``, src: n } : O_.get(t, null), sb.isImageObject(r)) return co(r, e) } function uo(e) { if (e) { if (e.pixelHeight && e.pixelWidth) return { width: e.pixelWidth, height: e.pixelHeight }; if (e.src === void 0) return { width: 1, height: 1 } } } function fo(e) { return e && e !== `search` && e !== `slot` && e !== `template` ? P[e] : P.div } function po(e, t) { e[`data-framer-layout-hint-center-x`] = t === !0 || t === `x` ? !0 : void 0, e[`data-framer-layout-hint-center-y`] = t === !0 || t === `y` ? !0 : void 0 } function mo(e) { let t = {}; return !e || !cb || J.current() !== J.canvas || po(t, e), t } function ho(e) { return e.replace(/^id_/u, ``).replace(/\\/gu, ``) } function go(e, t) { if (!t && (t = e.children, !t)) return { props: e, children: t }; let n = e._forwardedOverrides; return n && (t = p.Children.map(t, e => p.isValidElement(e) ? p.cloneElement(e, { _forwardedOverrides: n }) : e)), { props: e, children: t } } function _o(e) { return (t, n) => e === !0 ? `translate(-50%, -50%) ${n}` : e === `x` ? `translateX(-50%) ${n}` : e === `y` ? `translateY(-50%) ${n}` : n || `none` } function vo(e, { specificLayoutId: n, postfix: r } = {}) { let { name: i, layoutIdKey: a, duplicatedFrom: o, __fromCodeComponentNode: s = !1, drag: c } = e, { getLayoutId: l, enabled: u } = t($_); return b(() => { if (!u) return e.layoutId; let t = n || e.layoutId; if (!t && (c || !a || s)) return; let d = t || l({ id: a, name: i, duplicatedFrom: o }); if (d) return r ? `${d}-${r}` : d }, [u]) } function yo() { let [e, t] = p.useState(0); return p.useCallback(() => t(e => e + 1), []) } function bo(e) { let t = yo(); s(() => { let n = e?.current; if (n) return fb?.observeElementWithCallback(e.current, t), () => { fb?.unobserve(n) } }, [e, t]) } function xo(e) { return [...e.firstElementChild && e.firstElementChild.hasAttribute(pb) ? e.firstElementChild.children : e.children].filter(So).map(Co) } function So(e) { return e instanceof HTMLBaseElement || e instanceof HTMLHeadElement || e instanceof HTMLLinkElement || e instanceof HTMLMetaElement || e instanceof HTMLScriptElement || e instanceof HTMLStyleElement || e instanceof HTMLTitleElement ? !1 : e instanceof HTMLElement || e instanceof SVGElement } function Co(e) { if (!(e instanceof HTMLElement) || e.children.length === 0 || e.style.display !== `contents`) return e; let t = [...e.children].find(So); return t ? Co(t) : e } function wo(e, n, r = () => [], i = {}) { let { id: a, visible: o, _needsMeasure: s } = e, { skipHook: c = !1 } = i, l = t(ub), u = J.current() === J.canvas; lb(() => { !u || l || c || n.current && a && o && s && eb.queueMeasureRequest(ho(a), n.current, r(n.current)) }) } function To(e) { let t = e.closest(`[data-framer-component-container]`); t && eb.queueMeasureRequest(ho(t.id), t, xo(t)) } function Eo(e) { e.willChange = `transform`; let t = J.current() === J.canvas; gb && t && (e.translateZ = mb) } function Do(e) { e.willChange = `transform`, Oo(e, !0) } function Oo(e, t) { let n = J.current() === J.canvas; if (!gb || !n) return; let r = L(e.transform) && e.transform || ``; t ? r.includes(hb) || (e.transform = r + hb) : e.transform = r.replace(hb, ``) } function ko(e, t, n, r = !0) { if (!e) return; let i = qy(e.style), a = n || i[t], o = () => { Ao(a) && (i[t] = a) }; i[t] = null, r ? Promise.resolve().then(o) : setTimeout(o, 0) } function Ao(e) { return L(e) || R(e) || et(e) } function jo(e, t) { if (e.size < t) return; let n = Math.round(Math.random()); for (let t of e.keys()) (++n & 1) != 1 && e.delete(t) } function Mo(e, t, n, r) { let i = t.get(n); if (i) return i; jo(t, e); let a = r(n); return t.set(n, a), a } function No(e, t) { let n = [e, t]; return bb.test(e) ? e : Mo(1e3, xb, n, () => yb.multiplyAlpha(e, t)) } function Po(e, t = 1) { let n; return n = `stops` in e ? e.stops : [{ value: e.start, position: 0 }, { value: e.end, position: 1 }], t === 1 ? n : n.map(e => ({ ...e, value: No(e.value, t) })) } function Fo(e, t) { let n = 0; return Po(e, t).forEach(e => { n ^= vb(e.value) ^ e.position }), n } function Io(e) { return e && Sb.every(t => t in e) } function Lo(e) { return e && Cb.every(t => t in e) } function Ro({ background: e, backgroundColor: t }, n) { t ? typeof t == `string` || H_(t) ? n.backgroundColor = t : q.isColorObject(e) && (n.backgroundColor = e.initialValue || q.toRgbString(e)) : e && (e = O_.get(e, null), typeof e == `string` || H_(e) ? n.background = e : Tb.isLinearGradient(e) ? n.background = Tb.toCSS(e) : Db.isRadialGradient(e) ? n.background = Db.toCSS(e) : q.isColorObject(e) && (n.backgroundColor = e.initialValue || q.toRgbString(e))) } function U(e, t, n, r) { if (r === void 0 && (r = t), e[t] !== void 0) { n[r] = e[t]; return } } function zo(e) { return e ? e.left !== void 0 && e.right !== void 0 : !1 } function Bo(e) { return e ? e.top !== void 0 && e.bottom !== void 0 : !1 } function Vo(e) { if (!e) return {}; let t = {}; e.preserve3d === !0 ? t.transformStyle = `preserve-3d` : e.preserve3d === !1 && (t.transformStyle = `flat`), e.backfaceVisible === !0 ? t.backfaceVisibility = `visible` : e.backfaceVisible === !1 && (t.backfaceVisibility = `hidden`), t.backfaceVisibility && (t.WebkitBackfaceVisibility = t.backfaceVisibility), e.perspective !== void 0 && (t.perspective = t.WebkitPerspective = e.perspective), e.__fromCanvasComponent || (e.center === !0 ? (t.left = `50%`, t.top = `50%`) : e.center === `x` ? t.left = `50%` : e.center === `y` && (t.top = `50%`)); let { cornerShape: n } = e; return Ce(n) ? t.cornerShape = te(() => `superellipse(${n.get()})`) : n !== void 0 && (t.cornerShape = `superellipse(${n})`), U(e, `size`, t), U(e, `width`, t), U(e, `height`, t), U(e, `minWidth`, t), U(e, `minHeight`, t), U(e, `top`, t), U(e, `right`, t), U(e, `bottom`, t), U(e, `left`, t), U(e, `position`, t), U(e, `overflow`, t), U(e, `opacity`, t), (!e._border || !e._border.borderWidth) && U(e, `border`, t), U(e, `borderRadius`, t), U(e, `radius`, t, `borderRadius`), U(e, `color`, t), U(e, `shadow`, t, `boxShadow`), U(e, `x`, t), U(e, `y`, t), U(e, `z`, t), U(e, `rotate`, t), U(e, `rotateX`, t), U(e, `rotateY`, t), U(e, `rotateZ`, t), U(e, `scale`, t), U(e, `scaleX`, t), U(e, `scaleY`, t), U(e, `skew`, t), U(e, `skewX`, t), U(e, `skewY`, t), U(e, `originX`, t), U(e, `originY`, t), U(e, `originZ`, t), Ro(e, t), t } function Ho(e) { for (let t in e) if (t === `drag` || t.startsWith(`while`) || typeof qy(e)[t] == `function` && t.startsWith(`on`) && !t.includes(`Animation`)) return !0; return !1 } function Uo(e) { if (e.drag) return `grab`; for (let t in e) if (kb.has(t)) return `pointer` } function Wo(e) { return Go(e) ? !0 : e.style ? !!Go(e.style) : !1 } function Go(e) { return Ab in e && (e[Ab] === `scroll` || e[Ab] === `auto`) } function Ko(e) { let { left: t, top: n, bottom: r, right: i, width: a, height: o, center: s, _constraints: c, size: l, widthType: u, heightType: d, positionFixed: f, positionAbsolute: p } = e, m = ge(e.minWidth), h = ge(e.minHeight), g = ge(e.maxWidth), _ = ge(e.maxHeight); return { top: ge(n), left: ge(t), bottom: ge(r), right: ge(i), width: ge(a), height: ge(o), size: ge(l), center: s, _constraints: c, widthType: u, heightType: d, positionFixed: f, positionAbsolute: p, minWidth: m, minHeight: h, maxWidth: g, maxHeight: _ } } function qo(e) { let n = t(ub), { style: r, _initialStyle: i, __fromCanvasComponent: a, size: o } = e, s = Ko(e), c = ca(s), l = { display: `block`, flex: r?.flex ?? `0 0 auto`, userSelect: J.current() === J.preview ? void 0 : `none` }; e.__fromCanvasComponent || (l.backgroundColor = e.background === void 0 ? `rgba(0, 170, 255, 0.3)` : void 0); let u = !Ho(e) && !e.__fromCanvasComponent && !Wo(e), d = e.style ? !(`pointerEvents` in e.style) : !0; u && d && (l.pointerEvents = `none`); let f = p.Children.count(e.children) > 0 && p.Children.toArray(e.children).every(e => typeof e == `string` || typeof e == `number`) && { display: `flex`, alignItems: `center`, justifyContent: `center`, textAlign: `center` }, m = Vo(e); o === void 0 && !a && (zo(m) || (l.width = jb.width), Bo(m) || (l.height = jb.height)), s.minWidth !== void 0 && (l.minWidth = s.minWidth), s.minHeight !== void 0 && (l.minHeight = s.minHeight); let h = {}; Zi(s) && c && !la(e) && (h = { left: c.x, top: c.y, width: c.width, height: c.height, right: void 0, bottom: void 0 }), Object.assign(l, f, i, m, h, r), Object.assign(l, { overflowX: l.overflowX ?? l.overflow, overflowY: l.overflowY ?? l.overflow, overflow: void 0 }), _b.applyWillChange(e, l, !0); let g = l; l.transform || (g = { x: 0, y: 0, ...l }); let _ = Ua(); return e.positionSticky ? (!_ || eb.isOnPageCanvas || n) && (g.position = `sticky`, g.willChange = `transform`, g.zIndex = 1, g.top = e.positionStickyTop, g.right = e.positionStickyRight, g.bottom = e.positionStickyBottom, g.left = e.positionStickyLeft) : _ && (e.positionFixed ? g.position = eb.isOnPageCanvas ? `fixed` : `absolute` : e.positionAbsolute && (g.position = `absolute`)), `rotate` in g && g.rotate === void 0 && delete g.rotate, [g, c] } function Jo(e) { let t = {}; for (let n in e) (Ke(n) || Yy(n)) && !Mb.has(n) ? t[n] = qy(e)[n] : (n === `positionTransition` || n === `layoutTransition`) && (t.layout = !0, typeof qy(e)[n] != `boolean` && !e.transition && (t.transition = qy(e)[n])); return t } function Yo(e) { return `data-framer-name` in e } function Xo(e, t, n, r) { if (r) return n ? { width: n.width, height: n.height } : 1; let { _usesDOMRect: i } = e, { widthType: a = 0, heightType: o = 0, width: s, height: c } = t; return n && !i ? n : a === 0 && o === 0 && typeof s == `number` && typeof c == `number` ? { width: s, height: c } : i || e.positionFixed || e.positionAbsolute ? 2 : 0 } function Zo(e) { return m(P.div, { layoutId: Fb, style: Rb, children: e.children }) } function Qo(e, t) { Ye(e) ? e(t) : $o(e) && (e.current = t) } function $o(e) { return z(e) && `current` in e } function es() { let e = Fi(() => new Set), t = Fi(() => new Map); return Fi(() => (n, r) => ({ get current() { return n.current }, set current(i) { if (i !== n.current) { if (n.current = i, r && r(i), t.forEach((e, t) => { e ? e() : t(null) }), i === null) { t.clear(), e.clear(); return } e.forEach(e => { let n = e(i); t.set(e, n) }) } }, observe(r) { e.add(r); let i = n.current; if (i) { let e = r(i); t.set(r, e) } }, unobserve(n) { if (!n || (e.delete(n), !t.has(n))) return; let r = t.get(n); r ? r() : n(null), t.delete(n) } })) } function ts(e) { let t = c(null), n = es(); return Fi(() => $o(e) ? n(e) : Ye(e) ? n(t, e) : n(t)) } function ns(e, t, n) { let r = c(), i = c(); dr(() => { i.current !== void 0 && (i.current = !0) }, n ?? [{}]), e && i.current !== !1 && (i.current = !1, e.unobserve(r.current), e.observe(t), r.current = t) } function rs(e, t, n, r, i, a, o) { let s = e.get(t); return (!s || s.root !== r?.current) && (s = new zb({ root: r?.current, rootMargin: a, threshold: o }), e.set(t, s)), s.observeElementWithCallback(n, i), () => { s.unobserve(n) } } function is(e, n, r) { let i = Fi(() => `${r.rootMargin}`), a = t(Bb), { enabled: o, root: s, rootMargin: c, threshold: l } = r; ns(e, e => { if (o && e !== null) return rs(a, i, e, s, n, c, l) }, [o, n, s, c, l]) } function as(e, t, n) { let r = p.useRef({ isInView: !1, hasAnimatedOnce: !1 }), { enabled: i, animateOnce: a, threshold: o, rootMargin: s = `0px 0px 0px 0px` } = n; Vb(e, p.useCallback(e => { let { isInView: n, hasAnimatedOnce: i } = r.current, s = ss(e, o?.y ?? 0); if (s && !n) { if (a && i) return; r.current.hasAnimatedOnce = !0, r.current.isInView = !0, t(!0); return } if (!s && n) { if (r.current.isInView = !1, a) return; t(!1); return } }, [a, o?.y, t]), { threshold: Hb, rootMargin: s, enabled: i ?? !0 }) } function os(e, t) { return t.height === 0 ? 0 : e.height / Math.min(t.height, K.innerHeight) } function ss({ boundingClientRect: e, intersectionRect: t, isIntersecting: n }, r) { return e.height === 0 ? n : n && os(t, e) >= r } function cs() { return new Map } function ls() { return Fi(cs) } function us(e, n = []) { let { register: r, deregister: i } = t(qb); s(() => { if (e) return r(e), () => i(e) }, [r, i, ...n]) } function ds(e, t) { return !(t.isCurrent === void 0 || e.isCurrent !== t.isCurrent || e.isPrevious !== t.isPrevious || t.isCurrent && e.isOverlayed !== t.isOverlayed) } function fs(e, t, n) { let r = { ...e }; return t && (H(t.originX) && (r.originX = t.originX), H(t.originY) && (r.originY = t.originY), H(t.originZ) && (r.originZ = t.originZ)), n && (H(n.originX) && (r.originX = n.originX), H(n.originY) && (r.originY = n.originY), H(n.originZ) && (r.originZ = n.originZ)), r } function ps(e) { if (!e || !(`rotateX` in e || `rotateY` in e || `z` in e)) return !1; let t = e.rotateX !== 0 || e.rotateY !== 0 || e.z !== 0, n = e?.transition?.rotateX.from !== 0 || e?.transition?.rotateY.from !== 0 || e?.transition?.z.from !== 0; return t || n } function ms(e) { switch (e && e.appearsFrom ? e.appearsFrom : `right`) { case `right`: return $b.PushLeft; case `left`: return $b.PushRight; case `bottom`: return $b.PushUp; case `top`: return $b.PushDown } } function hs(e) { switch (e && e.appearsFrom ? e.appearsFrom : `bottom`) { case `right`: return $b.OverlayLeft; case `left`: return $b.OverlayRight; case `bottom`: return $b.OverlayUp; case `top`: return $b.OverlayDown } } function gs(e) { switch (e && e.appearsFrom ? e.appearsFrom : `bottom`) { case `right`: return $b.FlipLeft; case `left`: return $b.FlipRight; case `bottom`: return $b.FlipUp; case `top`: return $b.FlipDown } } function _s(e, t) { switch (t.type) { case `addOverlay`: return ys(e, t.transition, t.component); case `removeOverlay`: return bs(e); case `add`: return xs(e, t.key, t.transition, t.component); case `remove`: return ws(e); case `update`: return vs(e, t.key, t.component); case `back`: return Ss(e); case `forward`: return Cs(e); default: return } } function vs(e, t, n) { return { ...e, containers: { ...e.containers, [t]: n } } } function ys(e, t, n) { let r = e.overlayStack[e.currentOverlay]; if (r && r.component === n) return; let i = e.overlayItemId + 1, a = [...e.overlayStack, { key: `stack-${i}`, component: n, transition: t }]; return { ...e, overlayStack: a, overlayItemId: i, currentOverlay: Math.max(0, Math.min(e.currentOverlay + 1, a.length - 1)), previousOverlay: e.currentOverlay } } function bs(e) { return { ...e, overlayStack: [], currentOverlay: -1, previousOverlay: e.currentOverlay } } function xs(e, t, n, r) { e.containers[t] || (e.containers[t] = r), e.history = e.history.slice(0, e.current + 1), e.visualIndex = Math.max(e.history.length, 0); let i = e.history[e.history.length - 1], a = i && i.key === t; if (e.overlayStack = [], a && e.currentOverlay > -1) return { ...e, currentOverlay: -1, previousOverlay: e.currentOverlay }; if (a) return; let o = e.containerVisualIndex[t], s = e.containerIsRemoved[t], c = i?.key && n.withMagicMotion ? ks(t, o, s, e.history) : !0; e.history.push({ key: t, transition: n, visualIndex: c ? Math.max(e.visualIndex, 0) : e.containerVisualIndex[t] }); let l = e.current + 1, u = e.current; for (let t in e.containerIndex) e.containerIndex[t] === l && (e.containerIndex[t] = Ds(t, e.history)); e.containerIndex[t] = l; let { containerVisualIndex: d, containerIsRemoved: f } = Ts(e, t, c), p = Os(l, u, e.history, e.containerIndex, e.transitionForContainer); return { ...e, current: l, previous: u, containerVisualIndex: d, containerIsRemoved: f, transitionForContainer: p, previousTransition: null, currentOverlay: -1, historyItemId: e.historyItemId + 1, previousOverlay: e.currentOverlay } } function Ss(e) { let t = { ...e.containers }, n = ws(e); if (n) return n.containers = t, n } function Cs(e) { let t = e.history[e.current + 1]; if (!t) return; let { key: n, transition: r, component: i } = t, a = [...e.history], o = xs(e, n, r, i); if (o) return o.history = a, o } function ws(e) { let t = [...e.history.slice(0, e.current + 1)]; if (t.length === 1) return; let n = t.pop(); if (!n) return; let r = t[t.length - 1]; B(r, `The navigation history must have at least one component`), e.containerIndex[r.key] = t.length - 1, t.every(e => e.key !== n.key) && delete e.containers[n.key]; let i = e.current - 1, a = e.current, { containerIsRemoved: o, containerVisualIndex: s, previousTransition: c, visualIndex: l } = Es(e, r, n), u = Os(i, a, e.history, e.containerIndex, e.transitionForContainer); return { ...e, current: i, previous: a, containerIsRemoved: o, containerVisualIndex: s, previousTransition: c, visualIndex: l, transitionForContainer: u } } function Ts(e, t, n) { let r = { containerVisualIndex: { ...e.containerVisualIndex }, containerIsRemoved: { ...e.containerIsRemoved } }; if (n) r.containerVisualIndex[t] = e.history.length - 1, r.containerIsRemoved[t] = !1; else { let n = e.containerVisualIndex[t]; for (let [t, i] of Object.entries(e.containerVisualIndex)) n !== void 0 && i > n && (r.containerIsRemoved[t] = !0) } return r } function Es(e, t, n) { let r = [t.key, n.key], i = e.history[e.history.length - 2], a = e.previousTransition === null ? null : { ...e.previousTransition }, o = { containerIsRemoved: { ...e.containerIsRemoved }, containerVisualIndex: { ...e.containerVisualIndex }, previousTransition: a, visualIndex: e.visualIndex }; i && r.push(i.key); let s = e.containerVisualIndex[t.key], c = e.containerVisualIndex[n.key], l = s !== void 0 && c !== void 0 && s <= c || t.visualIndex !== void 0 && t.visualIndex < e.history.length - 1, u = t.visualIndex; return l ? (o.containerIsRemoved[n.key] = !0, o.containerVisualIndex[t.key] = u === void 0 ? e.history.length - 1 : u) : (o.visualIndex = e.visualIndex + 1, o.containerVisualIndex[t.key] = e.visualIndex + 1), n.transition.withMagicMotion && (o.previousTransition = n.transition || null), e.containerIsRemoved[t.key] = !1, o } function Ds(e, t) { for (let n = t.length; n > t.length; n--)if (t[n]?.key === e) return n; return -1 } function Os(e, t, n, r, i) { let a = { ...i }; for (let [i, o] of Object.entries(r)) { let r = As(o, { current: e, previous: t, history: n }); r && (a[i] = r) } return a } function ks(e, t, n, r) { return n || t === void 0 ? !0 : t === 0 ? !1 : r.slice(t, r.length).findIndex(t => t.key === e) > -1 ? !0 : !(r.slice(0, t - 1).findIndex(t => t.key === e) > -1) } function As(e, t) { let { current: n, previous: r, history: i } = t; if (!(e !== n && e !== r)) { if (e === n && n > r) { let t = i[e]; return js(`enter`, t?.transition.enter, t?.transition.animation) } if (e === r && n > r) { let t = i[e + 1]; return js(`exit`, t?.transition.exit, t?.transition.animation) } if (e === n && n < r) { let t = i[e + 1]; return js(`enter`, t?.transition.exit, t?.transition.animation) } if (e === r && n < r) { let t = i[e]; return js(`exit`, t?.transition.enter, t?.transition.animation) } } } function js(e, t, n) { let r = {}, i = {}; return tx.forEach(e => { r[e] = Xb[e], i[e] = { ...n, from: Xb[e] } }), t && Object.keys(t).forEach(a => { if (t[a] === void 0) return; let o = t[a], s = typeof t[a] == `string` ? `${qy(Xb)[a]}%` : qy(Xb)[a]; qy(r)[a] = e === `enter` ? s : o, i[a] = { ...n, from: e === `enter` ? o : s, velocity: 0 } }), { ...r, transition: { ...i } } } function Ms(e) { let t, n; return e.current === -1 ? n = e.history[e.previous] : t = e.history[e.current], { currentOverlayItem: t, previousOverlayItem: n } } function Ns({ currentOverlayItem: e }) { return e && e.transition.exit } function Ps({ currentOverlayItem: e, previousOverlayItem: t }) { return e && e.transition.animation ? e.transition.animation : t && t.transition.animation ? t.transition.animation : ax } function Fs({ currentOverlayItem: e, previousOverlayItem: t }) { return e ? e.transition.backfaceVisible : t && t.transition.backfaceVisible } function Is(e) { if (e.backdropColor) return e.backdropColor; if (e.overCurrentContext) return `rgba(4,4,15,.4)` } function Ls(e, t) { let { current: n, history: r } = t; if (e === n) { let t = r[e]; return t && t.transition ? t.transition.backfaceVisible : !0 } else if (e < n) { let t = r[e + 1]; return t && t.transition ? t.transition.backfaceVisible : !0 } else { let t = r[e]; return t && t.transition ? t.transition.backfaceVisible : !0 } } function Rs(e, t) { let n = t.history[e]; if (n) return n.transition.enter } function zs(e, t) { let { current: n, previous: r, history: i } = t; return e === r && n > r || e === n && n < r ? i[e + 1]?.transition?.backfaceVisible : i[e]?.transition?.backfaceVisible } function Bs(e, t) { let { current: n, history: r } = t; if (e !== n) if (e < n) { let t = r[e + 1]; if (t && t.transition) return t.transition.exit } else { let t = r[e]; if (t && t.transition) return t.transition.enter } } function Vs(e, t) { let { current: n, previous: r, history: i } = t, a = r > n ? r : n; if (e < a) { let t = i[e + 1]; if (t && t.transition.animation) return t.transition.animation } else if (e !== a) { let t = i[e]; if (t && t.transition.animation) return t.transition.animation } else { let t = i[e]; if (t?.transition.animation) return t.transition.animation } return ax } function Hs(e, t, n) { let { current: r, previous: i, history: a } = t; return !!(n && a.length > 1 || e !== i && e !== r || r === i) } function Us(e, t) { let { current: n, previous: r } = t; return e > n && e > r ? !1 : e === n } function Ws(e) { return p.Children.map(e.component, t => { if (!Bi(t) || !zi(t) || !t.props) return t; let n = { style: t.props.style ?? {} }, r = e?.transition?.position, i = !r || r.left !== void 0 && r.right !== void 0, a = !r || r.top !== void 0 && r.bottom !== void 0, o = `style` in t.props ? z(t.props.style) : !0; return i && (`width` in t.props && (n.width = `100%`), o && (n.style.width = `100%`)), a && (`height` in t.props && (n.height = `100%`), o && (n.style.height = `100%`)), p.cloneElement(t, n) }) } function Gs(e, t) { if (e.goBackOnTapOutside !== !1) return t } function Ks(e) { let t = ne(), n = me(); return m(ix, { ...e, resetProjection: t, skipLayoutAnimation: n, children: e.children }) } function qs(e) { return fx in e } function Js(e, t) { if (!qs(e)) return; let n = O_.getNumber(e.opacity); n !== 1 && (t.opacity = n) } function Ys(e) { let t = []; if (e && e.length) { let n = e.map(e => `drop-shadow(${e.x}px ${e.y}px ${e.blur}px ${e.color})`); t.push(...n) } return t } function Xs(e, t) { if (!e.shadows || e.shadows.length === 0) return; let n = e.shadows.map(e => `${e.x}px ${e.y}px ${e.blur}px ${e.color}`).join(`, `); n && (t.textShadow = n) } function Zs(e, t) { let n = []; H(e.brightness) && n.push(`brightness(${e.brightness / 100})`), H(e.contrast) && n.push(`contrast(${e.contrast / 100})`), H(e.grayscale) && n.push(`grayscale(${e.grayscale / 100})`), H(e.hueRotate) && n.push(`hue-rotate(${e.hueRotate}deg)`), H(e.invert) && n.push(`invert(${e.invert / 100})`), H(e.saturate) && n.push(`saturate(${e.saturate / 100})`), H(e.sepia) && n.push(`sepia(${e.sepia / 100})`), H(e.blur) && n.push(`blur(${e.blur}px)`), e.dropShadows && n.push(...Ys(e.dropShadows)), n.length !== 0 && (t.filter = t.WebkitFilter = n.join(` `)) } function Qs(e, t) { H(e.backgroundBlur) && (t.backdropFilter = t.WebkitBackdropFilter = `blur(${e.backgroundBlur}px)`) } function $s(e, t) { Qs(e, t), Zs(e, t) } function ec(e, t) { let n, r = (...r) => { K.clearTimeout(n), n = K.setTimeout(e, t, ...r) }; return r.cancel = () => { K.clearTimeout(n) }, r } function tc(...e) { return e.filter(Boolean).join(` `) } function nc() { let e = p.useContext(hx); return !Number.isNaN(e.update) } function rc(e, t) { let n = {}, r = {}; for (let i in e) { let a = ic(i); if (a && t.has(a)) { n[a] = e[i]; continue } r[i] = e[i] } return [n, r] } function ic(e) { if (e.startsWith(_x)) return e.substr(vx) } function ac(e, t, n) { let r = k.map(e, e => g(e) ? x(e, t) : e); return n ? r : m(E, { children: r }) } function oc(e) { let t = Fi(() => sc(e)); return t.useSetup(e), t.cloneAsElement } function sc(e) { let t = { forwardedRef: e, childRef: null, ref: null }; t.ref = cc(t); let n = (e, n) => { if (!t.forwardedRef && t.forwardedRef === e) { t.ref = n; return } let r = !1; t.childRef !== n && (t.childRef = n, r = !0), t.forwardedRef !== e && (t.forwardedRef = e, r = !0), r && (t.ref = cc(t)) }, r = !1; function i(i, a) { if (r) throw ReferenceError(`useCloneChildrenWithPropsAndRef: You should not call cloneChildrenWithPropsAndRef more than once during the render cycle.`); return r = !0, k.count(i) > 1 && e && (t.forwardedRef = void 0, t.ref = t.childRef), k.map(i, e => { if (g(e)) { let r = `ref` in e ? e.ref : void 0; n(t.forwardedRef, r); let i = Ye(a) ? a(e.props) : a; return x(e, t.ref === r ? i : { ...i, ref: t.ref }) } return e }) } let a = function (e, t) { return m(E, { children: i(e, t) }) }; return a.cloneAsArray = i, { useSetup: e => { r = !1, n(e, t.childRef) }, cloneAsElement: a } } function cc(e) { if (!e.forwardedRef) return e.childRef; let { forwardedRef: t, childRef: n } = e; return e => { Qo(n, e), Qo(t, e) } } function lc(e, t, n, r, i, a, o, s) { let c = p.Children.toArray(t), l = c[0]; if (c.length !== 1 || !p.isValidElement(l)) return console.warn(`PropertyOverrides: expected exactly one React element for a child`, t), o(t, n); let u = [], d = []; for (let [t] of Object.entries(r)) { if (t === i) continue; let n = e[t]; if (!n || !pc(l.props, n)) { d.push(t); continue } let r = fc([t], a); r.length && u.push({ variants: r, propOverrides: n }) } if (u.length === 0) return o(l, n); let f = fc([i, ...d], a); f.length && u.unshift({ variants: f }); let h = []; for (let { variants: e, propOverrides: t } of u) { if (s && !e.includes(s)) continue; let c = e.join(`+`), d = m(bx.Provider, { value: { primaryVariantId: i, variants: new Set(e) }, children: o(l, t ? { ...n, ...t } : n) }, c), f = dc(e, a, r); f.length ? (B(u.length > 1, `Must branch out when there are hiddenClassNames`), d = m(`div`, { className: `${xx} ${f.join(` `)}`, children: d }, c)) : B(u.length === 1, `Cannot branch out when hiddenClassNames is empty`), h.push(d) } return B(!s || h.length === 1, `Must render exactly one branch when activeVariantId is given`), h } function uc(e) { return e.split(`-`)[2] } function dc(e, t, n) { let r = []; for (let [i, a] of Object.entries(n)) { let n = t && !t.has(i); e.includes(i) || n || r.push(`hidden-${uc(a)}`) } return r } function fc(e, t) { return t ? e.filter(e => t.has(e)) : e } function pc(e, t) { for (let n of Object.keys(t)) if (!Ct(e[n], t[n], !0)) return !0; return !1 } function mc(e, t, n) { return !n || !e ? t : { ...t, ...n[e] } } function hc(e) { return p.forwardRef(({ optimized: t, ...n }, r) => { let i = p.useContext(yx), a = p.useContext(bx)?.variants, o = n[Nx]; o && !va() && jx.setAll(o, a, t ? n : null, i); let s = Fx(n); return m(e, { ref: r, ...n, ...s }) }) } function gc(e) { return L(e) || Array.isArray(e) } function _c(e) { return e in Rx } function vc(e, t) { let n = Fi(() => ({ values: Lx(t ? e : void 0) })); return p.useEffect(() => { if (!t) for (let e of Ix) { let t = Rx[e]; $e(t) || n.values[e].set(t) } }, [t]), n } function yc({ loopEffectEnabled: e, loopRepeatDelay: t, loopTransition: n, loopRepeatType: r, loop: a, loopPauseOffscreen: l }, u) { let d = Je(), f = Fi(Lx), p = c(!1), m = Hx(), h = c(null), g = o(async () => { if (!a) return; let e = n || void 0, t = p.current && r === `mirror`, i = t ? Rx : a, o = t ? a : Rx; return p.current = !p.current, h.current = Promise.all(Ix.map(t => { if (!(d && t !== `opacity`)) return f[t].jump(o[t] ?? Rx[t]), new Promise(n => { let r = { ...e, onComplete: () => n() }, a = i[t] ?? o[t]; typeof a == `number` && De(f[t], a, r) }) })), h.current }, [a, r, n, d]), [v, y] = i(!1), x = c(!1), S = o(async () => { !e || !x.current || (await g(), await m(t ?? 0), S()) }, [g, m, e, t]), C = o(() => { x.current || (x.current = !0, _(() => y(!0)), S()) }, [S]), w = o((e = !0) => { Ix.forEach(e => { f[e].stop() }), Ix.forEach(e => { f[e].set(Rx[e]) }), p.current = !1, e && (x.current = !1, _(() => y(!1))) }, []), T = e && a, E = o(() => { document.hidden ? w(!1) : x.current && (x.current = !1, C()) }, [C, w]); s(() => { if (T) return document.addEventListener(`visibilitychange`, E), () => { document.removeEventListener(`visibilitychange`, E) } }, [T, E]), s(() => { T && l || (T ? C() : w()) }, [C, w, l, T]), s(() => () => w(), [w]); let D = c(!1), O = o(async () => { h.current && (await h.current, !D.current && w()) }, [w]); Vb(u, o(e => { e.isIntersecting ? (D.current = !0, C()) : (D.current = !1, O()) }, [C, O]), { enabled: T && l }); let k = v || !l; return b(() => ({ values: f, style: T && k ? zx : Bx }), [T, k]) } function bc(e, t, n, r, i) { let a = n / 100 - 1; return (i ? (t - r) * a : 0) + -e * a } function xc(e, n, r) { let { speed: i = 100, offset: a = 0, adjustPosition: o = !1, parallaxTransformEnabled: s } = e, c = p.useRef(null), l = Je(), u = p.useCallback(e => c.current === null || i === 100 ? 0 : bc(e, c.current, i, a, o), [i, a, o]), { scrollY: d } = ve(), f = _e(d, u), m = ce(o && c.current === null ? `hidden` : r), h = ce(0), g = t(Bb); return ns(n, e => { if (e === null || !s) return; let t = rs(g, `undefined`, e, null, e => { c.current = e.boundingClientRect.top, ke.update(() => { f.set(u(d.get())), o && m.set(r ?? `initial`) }), t() }); return t }, [o, s]), At(() => { s && f.set(0) }), { values: { y: l || !s ? h : f }, style: s ? { ...zx, visibility: m } : Bx } } function Sc(e) { return typeof e == `object` && !!e } function Cc(e) { if (Sc(e)) return e?.transition } function wc(e, t, n, r, i, a) { let o = Cc(e); return Promise.all(Ix.map(s => new Promise(c => { if (n && s !== `opacity`) return c(); let l = t.values[s]; l.stop(); let u = Sc(e) ? e?.[s] ?? Rx[s] : Rx[s]; if (Ce(u) && (u = u.get()), !R(u)) return c(); let d = ye.get(r.current); d && d.setBaseTarget(s, u); let f; if (L(i) && !l?.hasAnimated && K.MotionHandoffAnimation) { let e = K.MotionHandoffAnimation(i, s, ke); e && (f = e) } a ? l.set(u) : De(l, u, { ...o, velocity: 0, startTime: f, onComplete: () => c() }) }))) } function Tc({ initial: e, animate: t, exit: n, presenceInitial: r, presenceAnimate: i, presenceExit: a }, o, s, l, u) { let d = r ?? e, f = i ?? t, p = a ?? n, [m, h] = de(), g = c({ lastPresence: !1, lastAnimate: f, hasMounted: !1, running: !1 }), _ = Fi(() => { let e = d ?? l; if (!z(e)) return { values: Lx() }; let t = {}; for (let n in e) { let r = z(e) ? e[n] : void 0; R(r) && (t[n] = r) } return { values: Lx(t) } }); ns(o, e => { let { hasMounted: t } = g.current; if (t && f) return; let n = ye.get(e); if (n) for (let e in Object.assign(g.current, { hasMounted: !0 }), _.values) { if (!_c(e)) continue; let t = l?.[e]; n.setBaseTarget(e, R(t) ? t : Rx[e]) } }, [f]); let v = Je(); ns(o, e => { if (!s) { h?.(); return } if (e === null) return; if (m !== g.current.lastPresence) { Object.assign(g.current, { lastPresence: m }), m ? d && f && (Object.assign(g.current, { running: !0 }), wc(f, _, v, o, u).then(() => Object.assign(g.current, { running: !1 }))) : p ? (Object.assign(g.current, { running: !0 }), wc(p, _, v, o, u).then(() => Object.assign(g.current, { running: !1 })).then(() => h())) : h(); return } let { lastAnimate: t, running: n } = g.current; Ct(f, t) || !f || (Object.assign(g.current, { lastAnimate: f }), wc(f, _, v, o, u, !n).then(() => Object.assign(g.current, { running: !1 }))) }); let y = s && f; return b(() => ({ values: _.values, style: y ? zx : Bx }), [y]) } function Ec(e, t) { let n = 0, r = e; for (; r && r !== t && r instanceof HTMLElement;)n += r.offsetTop, r = r.offsetParent; return n } function Dc(e, t = 0, n) { let r = [], i = []; for (let a = e.length; a >= 0; a--) { let { ref: o, offset: s } = e[a] ?? {}; if (!o || !o.current) continue; let c = Ec(o.current, document.documentElement) - Gx - (s ?? 0) - t, l = o.current?.clientHeight ?? 0, u = r[r.length - 1], d = Math.max(c + l, 0); r.push(c), i.unshift(Math.max(c, 0), u === void 0 ? d : Math.min(d, Math.max(u - 1, 0))), n?.(a) } return i } function Oc(e, t = 0) { return e < t ? `up` : `down` } function kc(e, t, n = {}) { let { direction: r, target: i } = e ?? {}, { repeat: a = !0, enabled: o = !0 } = n, s = kt(); p.useEffect(() => { if (!r || !o) return; let e, n = 0, s, c; return ie((o, { y: l }) => { if (!a && c === i || l.current > l.scrollLength || l.current < 0) return; let u = Oc(l.current, e); e = l.current; let d = u !== s; if (s = u, d) n = l.current; else { if (Math.abs(l.current - n) < Kx) return; let e = u === r ? i : void 0; e !== c && t(e), c = e } }) }, [s, r, a, i, o, t]) } function Ac(e, t, n) { let r = Dc(e, t), i = [...Jx], a = r[0]; if (!R(a)) return Yx; if (a > 1 && (r.unshift(0, a - 1), i.unshift(`initial`, `initial`)), n) { let e = r[r.length - 1]; if (!R(e)) return Yx; r.push(e + 1), i.push(`exit`) } return { inputRange: r, outputRange: i } } function jc(e) { return { x: e?.x ?? Rx.x, y: e?.y ?? Rx.y, scale: e?.scale ?? Rx.scale, opacity: e?.opacity ?? Rx.opacity, transformPerspective: e?.transformPerspective ?? Rx.transformPerspective, rotate: e?.rotate ?? Rx.rotate, rotateX: e?.rotateX ?? Rx.rotateX, rotateY: e?.rotateY ?? Rx.rotateY, skewX: e?.skewX ?? Rx.skewX, skewY: e?.skewY ?? Rx.skewY, transition: e?.transition ?? void 0 } } function Mc({ opacity: e, targetOpacity: t, perspective: n, enter: r, exit: i, animate: a, ...o }) { return p.useMemo(() => ({ initial: r ?? jc({ ...o, opacity: e ?? t ?? 1, transformPerspective: n }), animate: a ?? jc({ opacity: t }), exit: i ?? jc() }), [a, o, r, i, e, t, n]) } function Nc(e, t) { let n = Je(), r = Mc(e), i = e.styleAppearEffectEnabled, a = vc(i ? r.initial : r.animate, i), o = p.useRef({ isPlaying: !1, scheduledAppearState: void 0, lastAppearState: !e.styleAppearEffectEnabled }), s = kt(), c = p.useRef(), l = p.useCallback(async ({ transition: i, ...o }, s) => { let l = i ?? r.animate.transition ?? e.transition; await c.current; let u = ye.get(t.current); c.current = Promise.all(Ix.map(e => { s && a.values[e].set(r.initial[e] ?? Rx[e]); let t = o[e] ?? Rx[e]; return u && typeof t != `object` && u.setBaseTarget(e, t), new Promise(r => { if (n && e !== `opacity`) R(t) && a.values[e].set(t), r(); else { let n = { restDelta: e === `scale` ? .001 : void 0, ...l, onComplete: () => r() }; typeof t == `number` && De(a.values[e], t, n) } }) })) }, []), u = e.animateOnce && o.current.lastAppearState === !0; as(t, e => { let { isPlaying: t, lastAppearState: n } = o.current; if (t) { o.current.scheduledAppearState = e; return } o.current.scheduledAppearState = void 0, o.current.lastAppearState = e, n !== e && l(e ? r.animate : r.exit, e) }, { enabled: !e.targets && e.styleAppearEffectEnabled && !e.scrollDirection && !u, animateOnce: !!e.animateOnce, threshold: { y: e.threshold } }); let d = e.targets && i && !e.scrollDirection; return p.useEffect(() => { if (!d) return; let t = { initial: !0 }, n = `initial`; return ie((i, { y: a }) => { let { targets: o } = e; if (!o || !o[0] || o[0].ref && !o[0].ref.current) return; let { inputRange: s, outputRange: c } = Ac(o, (e.threshold ?? 0) * a.containerLength, !!e.exit); if (s.length === 0 || s.length !== c.length) return; let u = Me(a.current, s, c); if (e.animateOnce && t[u] || (t[u] = !0, n === u)) return; n = u; let d = qy(r)[u]; d && l(d) }) }, [s, d]), kc(e.scrollDirection, e => void l(e ?? r.animate), { enabled: i, repeat: !e.animateOnce }), At(() => { if (i && !(!e.targets && !e.scrollDirection)) for (let e of Ix) a.values[e].set(r.initial?.[e] ?? Rx[e]) }), b(() => ({ values: a.values, style: i ? zx : Bx }), [i]) } function Pc(e, t) { let n = p.useRef({}); p.useEffect(() => { if (t !== void 0) for (let r of Lh(e)) { let i = function () { let e = n.current[r]; e && e.stop(), n.current[r] = Re({ keyframes: [a.get(), s], velocity: a.getVelocity(), ...t, restDelta: .001, onUpdate: o }) }, a = e[r], o, s; a.attach((e, t) => (s = e, o = t, ke.postRender(i), a.get())) } }, [JSON.stringify(t)]) } function Fc(e, t) { let n = Qx(); return { inputRange: Dc(e, t, t => { let r = e[t - 1]?.target, i = e[t]?.target; for (let e of Ix) n[e]?.unshift(r?.[e] ?? 0, i?.[e] ?? 0) }), effectKeyOutputRange: n } } function Ic(e) { let t = Qx(); for (let { target: n } of e) for (let e of Ix) t[e]?.push(n[e]); return t } function Lc({ transformTrigger: e, styleTransformEffectEnabled: t, transformTargets: n, spring: r, transformViewportThreshold: i = 0 }, a) { let o = Je(), s = vc(Zx(n, o), t), c = !t || !n, l = e === `onScrollTarget`, u = kt(); return A(() => { if (!(c || !l)) return ie((e, { y: t }) => { if (!n[0] || n[0].ref && !n[0].ref.current) return; let { inputRange: r, effectKeyOutputRange: a } = Fc(n, i * t.containerLength); if (r.length !== 0) for (let e of Ix) o && e !== `opacity` || r.length === a[e].length && a[e][0] !== void 0 && s.values[e].set(Me(t.current, r, a[e])) }) }, [o, l, i, n, c]), ns(a, t => { if (c || l || t === null) return; let r = Ic(n); return ie((e, { y: t }) => { for (let e of Ix) o && e !== `opacity` || $x.length === r[e].length && r[e][0] !== void 0 && s.values[e].set(Me(t.progress, $x, r[e])) }, e === `onInView` ? { target: t ?? void 0, offset: [`start end`, `end end`] } : void 0) }, [u, o, e, l, n, c]), Pc(s.values, r), At(() => { if (c) return; let e = Zx(n, o); for (let t of Ix) s.values[t].set(e?.[t] ?? Rx[t]) }), p.useMemo(() => ({ values: s.values, style: t ? zx : Bx }), [t]) } function Rc(e, t, n) { return !(e in n) && t in n || n[e] === !0 } function zc(e) { let t = { parallax: {}, styleAppear: {}, styleTransform: {}, presence: { animate: e.animate, initial: e.initial, exit: e.exit }, loop: {}, forwardedProps: {}, targetOpacityValue: e.__targetOpacity, withPerspective: e.__perspectiveFX, inSmartComponent: e.__smartComponentFX }; for (let n in e) { if (n === `__targetOpacity` || n === `__perspectiveFX` || n === `__smartComponentFX`) continue; let r = ic(n); if (r) { for (let i of tS) if (eS[i]?.has(r)) { t[i][r] = qy(e)[n]; break } } else t.forwardedProps[n] = qy(e)[n] } return t.parallax.parallaxTransformEnabled = Rc(`parallaxTransformEnabled`, `speed`, t.parallax), t.styleAppear.styleAppearEffectEnabled = Rc(`styleAppearEffectEnabled`, `animateOnce`, t.styleAppear), t } function Bc(e) { return z(e) && iS in e } function Vc(e, t) { if (!e || !z(e)) return t; for (let n in e) { let r = e[n]; !Ce(r) || !_c(n) || R(r.get()) && t[n].push(r) } } function Hc(e) { return L(e) || Array.isArray(e) } function Uc({ presets: e, children: t }) { let n = c(e); return Ct(e, n.current, !1) || (n.current = e), m(oS.Provider, { value: n.current, children: t }) } function Wc({ componentIdentifier: e, children: n }) { return n(t(oS)[e] ?? {}) } function Gc() { return p.useContext(sS) } function Kc(e) { return e instanceof Error && (e.message.includes(`A component suspended while responding to synchronous input.`) || e.message.includes(`Minified React error #426`)) } function qc() { if (n === void 0 || uS) return m(`div`, { hidden: !0, dangerouslySetInnerHTML: { __html: `<!-- SuspenseThatPreservesDOM fallback rendered -->` } }); throw fS } function Jc({ children: e }) { return t(mS) ? m(E, { children: e }) : m(T, { fallback: pS, children: e }) } function Yc() { return m(`div`, { hidden: !0, dangerouslySetInnerHTML: { __html: `<!-- Code boundary fallback rendered -->` } }) } function Xc(e, t) { if (!Ah || Math.random() > .01) return; let n = e instanceof Error && typeof e.stack == `string` ? e.stack : null, r = t?.componentStack; Zt(`published_site_load_recoverable_error`, { message: String(e), stack: n, componentStack: n ? void 0 : r }) } function Zc(...e) { console.error(...e) } function Qc() { return J.current() !== J.canvas } function $c({ getErrorMessage: e, fallback: t, children: n }) { return Qc() ? m(el, { fallback: t, children: m(gS, { fallback: t, getErrorMessage: e, children: n }) }) : n } function el({ children: e, fallback: t = hS }) { return n === void 0 ? m(T, { fallback: t, children: e }) : m(Jc, { children: e }) } function tl() { return p.useContext(vS) } function nl() { let e = tl(); return p.useMemo(() => { if (!e) return; let t = e; for (; t.parent && t.parent.level > 0;)t = t.parent; return t }, [e]) } function rl({ children: e, scopeId: t, nodeId: n }) { let r = tl(), i = p.useMemo(() => ({ level: (r?.level ?? 0) + 1, scopeId: t, nodeId: n, parent: r }), [t, n, r]); return m(vS.Provider, { value: i, children: e }) } function il(e, t) { return `${yS}${e}:${t}` } function al(e, t) { return sl(`component`, e, t) } function ol(e, t) { return sl(`override`, e, t) } function sl(e, t, n) { return `A code ${e} crashed while rendering due to the error above. To find and fix it, open the project in the editor \u2192 open Quick Actions (press Cmd+K or Ctrl+K) \u2192 paste this: ${il(t, n)} \u2192 click \u201CShow Layer\u201D.` } function cl(e, t, n, r, i, a) { let o = ul(e, t, n, a); return o && !i && r || o && i } function ll(e, t, n, r) { return ul(e, t, n, r) } function ul(e, t, n, r) { return !!($e(n) || n === 1 && r && e === t) } function dl(e, t, n, r, i, a) { let o = tl(); return $e(t) || $e(n) ? m(_S, { children: e }) : (cl(t, o?.scopeId, o?.level, r ?? !1, i ?? !1, a ?? !1) && (e = m($c, { getErrorMessage: al.bind(null, t, n), fallback: null, children: e })), i && (e = m(rl, { scopeId: t, nodeId: n, children: e })), e) } function fl(e, t, n) { let r = {}; for (let [, i] of e) for (let e of i) { let i = r[e] ?? t[e] ?? n[e]; i && (r[e] = i) } return r } function pl(e) { return !(!e || e.placement || e.alignment) } function ml(e) { switch (e) { case `start`: return `0%`; case `center`: return `-50%`; case `end`: return `-100%`; default: V(e) } } function hl(e, t = `center`) { switch (e) { case `top`: return `${ml(t)}, -100%`; case `right`: return `0%, ${ml(t)}`; case `bottom`: return `${ml(t)}, 0%`; case `left`: return `-100%, ${ml(t)}`; default: return `-50%, -50%` } } function gl(e, t) { let n = document.elementFromPoint(e, t); for (; n;) { if (n === document.body) return; let e = n.getAttribute(`data-framer-cursor`); if (e) return e; if (n.hasAttribute(OS)) { let e = n.getAttribute(OS); n = n.parentElement, e && (n = document.getElementById(e) ?? n) } else n = n.parentElement } } function _l(e) { let { registerCursors: n } = t(SS), r = Fi(() => e), i = O(); A(() => n(r, i), [n, i]) } function vl(e) { return !!(e && typeof e == `object` && AS in e) } function yl(e) { return `${e.scopeId}:${e.nodeId}:${e.furthestExternalComponent?.scopeId}:${e.furthestExternalComponent?.nodeId}` } function bl() { return J.current() === J.canvas } function xl(e) { return e === void 0 ? !1 : !!(e.startsWith(`#`) || e.startsWith(`/`) || e.startsWith(`.`)) } function Sl(e, t) { try { return !!new URL(e).protocol } catch { } return t } function Cl(e, t, n, r) { if (L(e)) { let i = xl(e); if (!t.routes || !t.getRoute || !n || !i) return; let [a] = e.split(`#`, 2); if (a === void 0) return; let [o] = a.split(`?`, 2); if (o === void 0) return; let { routeId: s } = kr(t.routes, o, void 0, r); return t.getRoute(s) } let { webPageId: i } = e; return t.getRoute?.(i) } function wl(e) { return L(e) && e.startsWith(`data:${LS}`) } function Tl(e) { if (wl(e)) try { let t = new URL(e), n = t.pathname.substring(LS.length), r = t.searchParams, i = r.has(NS) ? r.get(NS) : void 0, a, o = r.get(PS), s = r.get(FS), c = r.get(IS); return o && s && c && (a = { collection: o, collectionItemId: s, pathVariables: Object.fromEntries(new URLSearchParams(c).entries()) }), { target: n === `none` ? null : n, element: i === `none` ? void 0 : i, collectionItem: a } } catch { return } } function El(e, t, n) { let r = t.getAttribute(`data-framer-page-link-target`), i, a; if (r) { i = t.getAttribute(`data-framer-page-link-element`) ?? void 0; let e = t.getAttribute(`data-framer-page-link-path-variables`); e && (a = Object.fromEntries(new URLSearchParams(e).entries())) } else { let e = t.getAttribute(`href`); if (!e) return !1; let n = Tl(e); if (!n || !n.target) return !1; r = n.target, i = n.element ?? void 0, a = n.collectionItem?.pathVariables } let o = i ? t.dataset.framerSmoothScroll !== void 0 : void 0; return e(r, i, Object.assign({}, n, a), o), !0 } function Dl(e) { if (!wl(e)) return e; let t = Tl(e); if (!t) return; let { target: n, element: r, collectionItem: i } = t; if (n) return { webPageId: n, hash: r ?? void 0, pathVariables: Ol(i) } } function Ol(e) { if (!e) return; let t = {}; for (let n in e.pathVariables) { let r = e.pathVariables[n]; r && (t[n] = r) } return t } function kl({ children: e }) { return m(RS.Provider, { value: void 0, children: e }) } function Al(e, n, r, i, a, s) { let c = t(RS), l = nl(), u = b(() => ({ scopeId: n, nodeId: r, furthestExternalComponent: l }), [n, r, l]), d = Et(), f = Ot(), { locales: p } = pr(), h = b(() => { let e = vl(i) ? i : Dl(i); if (e) return Cl(e, d, f, p) }, [f, i, d, p]), g = !!(!bl() && c?.nodeId && u.nodeId), _ = o(e => { if (a.href) { if (e.preventDefault(), e.stopPropagation(), Ca(e)) { Nl(a.href, ``, `_blank`); return } h ? a.navigate?.() : Nl(a.href, a.rel, a.target) } }, [a, h]), v = o(e => { a.href && (e.preventDefault(), e.stopPropagation(), Nl(a.href, ``, `_blank`)) }, [a]), y = o(e => { a.href && e.key === `Enter` && (e.preventDefault(), e.stopPropagation(), h ? a.navigate?.() : Nl(a.href, a.rel, a.target)) }, [a, h]); ns(s, e => { e !== null && g && (e.dataset.hydrated = `true`) }, [g]); let x = e; return g && (k.forEach(e, e => { Ml(e) && (B(jl(c), "outerLink must have nodeId defined at this point; this was verified with `shouldReplaceLink` above"), B(jl(u), "innerLink must have nodeId defined at this point; this was verified with `shouldReplaceLink` above"), MS.collectNestedLink(c, u)) }), x = k.map(e, e => { if (!Ml(e)) return e; let t = Pl(e.type), { children: n, ...r } = e.props, i = { ...r, "data-nested-link": !0, role: `link`, tabIndex: 0, onClick: _, onAuxClick: v, onKeyDown: y, as: r.as && Pl(r.as) }, a = `ref` in e ? e.ref : void 0; return D(t, { ...i, ref: a }, n) })), m(RS.Provider, { value: u, children: x }) } function jl(e) { return !$e(e?.nodeId) } function Ml(e) { return g(e) && (Pl(e.type) !== e.type || Pl(e.props.as) !== e.props.as) } function Nl(e, t, n) { let r = document.createElement(`a`); r.href = e, t && (r.rel = t), n && (r.target = n), document.body.appendChild(r), r.click(), r.remove() } function Pl(e) { return e === `a` ? `span` : qe(e) && je(e) === `a` ? P.span : e } function Fl(e) { e && ke.read(() => { let t = document.getElementById(e); if (!t) return; let n = getComputedStyle(t), r = n.getPropertyValue(`--selection-color`).trim(), i = n.getPropertyValue(`--selection-background-color`).trim(); ke.render(() => { let t = document.querySelectorAll(`[data-framer-portal-id="${e}"]`); t.length !== 0 && (r && t.forEach(e => e.style.setProperty(zS, r)), i && t.forEach(e => e.style.setProperty(BS, i))) }) }) } function Il(e) {
    return [`[data-framer-portal-id="${e}"] * ::selection {
    color: var(${zS});
    background-color: var(${BS});
}`]
} function Ll({ triggerId: e, children: t }) { return p.useLayoutEffect(() => { e && Fl(e) }, [e]), t } function Rl(e, t) { return e instanceof HTMLAnchorElement ? e : e instanceof Element ? e === t ? null : Rl(e.parentElement, t) : null } function zl({ children: e }) { return m(Jc, { children: e }) } function Bl(e) { return v(function (t, n) { return m(zl, { children: m(e, { ...t, ref: n }) }) }) } function Vl(e, t, n, r, i, a) { let { webPageId: o, hash: s, pathVariables: c, hashVariables: l } = n; return Ul(e, t, o, s, a, c, l, i, r) } function Hl(e, t, n, r) { if (!(!e.routes || !e.getRoute) && xl(t)) try { let [i, a] = t.split(`#`, 2); B(i !== void 0, `A href must have a defined pathname.`); let [o] = i.split(`?`, 2); B(o !== void 0, `A href must have a defined pathname.`); let { routeId: s, pathVariables: c, localeId: l } = kr(e.routes, o, void 0, r), u = e.getRoute(s); if (u) return { routeId: s, route: u, href: t, elementId: a, pathVariables: Object.assign({}, n, c), locale: l ? r?.find(({ id: e }) => e === l) : void 0 } } catch { } } function Ul(e, t, n, r, i, a, o, s, c) { let l = { ...i, ...a, ...s?.path }, u = { ...i, ...o, ...s?.hash }, d = e.getRoute?.(n), f = nr(d, { currentRoutePath: t?.path, currentRoutePathLocalized: t?.pathLocalized, currentPathVariables: t?.pathVariables, hash: r, pathVariables: l, hashVariables: u, preserveQueryParams: e.preserveQueryParams, siteCanonicalURL: e.siteCanonicalURL, localeId: c?.id }); return { routeId: n, route: d, href: f, elementId: f.split(`#`, 2)[1], pathVariables: l, locale: c ?? void 0 } } function Wl() { let e = t(KS), n = Ot()?.pathVariables; return e || n } function Gl(e, { webPageId: t, hash: n, pathVariables: r }, i) { if (t !== e.id || n) return !1; if (e.path && e.pathVariables) { let t = Object.assign({}, i, r); for (let [, n] of e.path.matchAll(GS)) if (!n || e.pathVariables[n] !== t[n]) return !1 } return !0 } function Kl() { let e = j.connection || j.mozConnection || j.webkitConnection || {}, t = j.deviceMemory && j.deviceMemory > YS, n, r, i; function a() { n = e.effectiveType || ``, r = e.saveData || n.includes(`2g`), i = n === `3g` || t ? XS : ZS } e.addEventListener?.(`change`, a), a(); let o = new IntersectionObserver(l, { threshold: JS }), s = 0; async function c(e, t) { if (r) return; let { id: n, preload: i } = e, a = eC.get(n); if (!a?.size || $S.has(n)) return; ++s, $S.add(n); let c = i()?.catch(() => { }); o.unobserve(t), QS.delete(t); for (let e of a) o.unobserve(e), QS.delete(e); a.clear(), eC.delete(n), await c, --s } function l(e) { for (let t of e) { let e = t.target, n = QS.get(e); if (!n || $S.has(n.id)) { o.unobserve(e), QS.delete(e); continue } let r = n.id, a = eC.get(r), l = eC.get(r)?.size ?? 0; if (t.isIntersecting) { if (s >= i) continue; a ? a.add(e) : eC.set(r, new Set([e])), setTimeout(c, qS, n, e) } else a && a.delete(e), l <= 1 && eC.delete(r) } } return (e, t, n) => { if (!$S.has(n)) return QS.set(e, { id: n, preload: t }), o.observe(e), () => { QS.delete(e), o.unobserve(e) } } } function ql(e, t) { let n = xl(e), r = { href: e === `` || Sl(e, n) ? e : `https://${e}`, target: Jl(t?.openInNewTab, n), rel: n ? void 0 : Yl(`noopener`, t?.rel) }; return t?.preserveParams && (r.href = wn(r.href ?? e), r[`data-framer-preserve-params`] = !0), t?.trackLinkClick && (r.onClick = () => { t.trackLinkClick(e) }), r } function Jl(e, t) { return e === void 0 ? t ? void 0 : `_blank` : e ? `_blank` : void 0 } function Yl(e, t) { if (e && !t) return e; if (!e && t) return t; if (e && t) return `${e} ${t}` } function Xl(e, t) { console.warn(st(`Failed to resolve slug: ${e instanceof Error ? e.message : t ?? `Unknown error`}`)) } function Zl(e, t, n) { try { let r = t?.get(e.collectionId); if (!r) return Xl(void 0, `Couldn't find collection utils for collection id: "${e.collectionId}"`); let i = r.getSlugByRecordId(e.collectionItemId, n ?? void 0); return at(i) ? i.catch(Xl) : i } catch (e) { Xl(e) } } async function Ql(e, t, n, r) { async function i(e) { if (!e) return {}; let t = {}; for (let i in e) { let a = e[i]; B(a, `unresolvedSlug should be defined`); let o = Zl(a, r, n), s = at(o) ? await o : o; s && (t[i] = s) } return t } let [a, o] = await Promise.allSettled([i(e), i(t)]); return { path: a.status === `fulfilled` ? a.value : void 0, hash: o.status === `fulfilled` ? o.value : void 0 } } function $l(e, t, n, r, i = []) { function a(e) { if (!e) return; let t = {}; for (let a in e) { let o = e[a]; if (!o) continue; let s = Zl(o, r, n); at(s) ? i.push(s) : s && (t[a] = s) } return t } let o = { path: a(e), hash: a(t) }; return i.length > 0 ? Promise.allSettled(i) : o } function eu() { let e = ln(); return o((t, n, r, i = []) => $l(t, n, r, e, i), [e]) } function tu({ nodeId: e, clickTrackingId: t, router: n, href: r, activeLocale: i }) { let a = ln(); return o(async o => { if (!n.pageviewEventData?.current) return; let s = n.pageviewEventData.current instanceof Promise ? await n.pageviewEventData.current : n.pageviewEventData.current, c = vl(r) ? r : Dl(r); if (!vl(c)) return Zt(`published_site_click`, { ...s, href: o ? nu(o) : null, nodeId: e ?? null, trackingId: t || null, targetRoutePath: null, targetWebPageId: null, targetCollectionItemId: null }, `eager`); let l = c.webPageId, u = n?.getRoute?.(l), d = u?.path ?? null, f = null; if (u?.collectionId && c.pathVariables) { let e = a?.get(u.collectionId); if (!e) return; let [t] = Object.values(c.pathVariables); if (L(t)) { let n = e.getRecordIdBySlug(t, i || void 0); f = (at(n) ? await n : n) ?? null } } return Zt(`published_site_click`, { ...s, href: o ? nu(o) : null, nodeId: e ?? null, trackingId: t ?? null, targetRoutePath: d, targetWebPageId: l, targetCollectionItemId: f }, `eager`) }, [e, t, n, r, i, a]) } function nu(e) { try { let t = new URL(e, K.document.baseURI); return t.origin === K.location.origin ? t.pathname + t.search + t.hash : t.href } catch { return e } } function ru(e, t, n, r, i, a, o) { n(), e.navigate?.(t, r, i, a, o) } function iu(e, t, n) { return async r => { let i = Ca(r), a = Rl(r.target), o = !a || a.getAttribute(`target`) === `_blank`, s = !i && !o, c = () => void t(e); if (!s) { await mn({ priority: `user-blocking`, ensureContinueBeforeUnload: !0, continueAfter: `paint` }), c(); return } r.preventDefault(), n(c) } } function au(e, t, n, r, i, a, o, s) { if (!n) return ql(e, r); let c = Hl(t, e, s, o); if (!c) return ql(e, r); let { routeId: l, route: u, elementId: d, pathVariables: f, locale: p } = c; if (!u) return ql(e, r); let m = nr(u, { currentRoutePath: n.path, currentRoutePathLocalized: n.pathLocalized, currentPathVariables: n.pathVariables, hash: d, pathVariables: f, preserveQueryParams: t.preserveQueryParams && !jh, siteCanonicalURL: t.siteCanonicalURL, localeId: a }), h = Jl(r.openInNewTab, !0), g = h === `_blank`, _ = { pathVariables: f, locale: p }, v = e => ru(t, l, () => i(l, _, !1, !g), d, f, r.smoothScroll, e); return { href: m, target: h, onClick: iu(m, r.trackLinkClick, v), navigate: v, "data-framer-page-link-current": n && Gl(n, { webPageId: l, hash: d, pathVariables: f }, s) || void 0, preload: () => i(l, _, !0, !g), _routeId: l, _pathVariables: f, _locale: p } } function ou(e, t, n) { let r = su(e.style, t.style), i = { ...e, ...t, ...r && { style: r }, ref: n }, { onTap: a, onClick: o } = t; if (!a && !o) return i; let { onClick: s, onTap: c } = e; return { ...i, onClick: o || s ? e => { Ye(s) && s?.(e), o?.(e) } : void 0, onTap: a || c ? (e, t) => { Ye(c) && c?.(e, t), a?.(e, t) } : void 0 } } function su(e, t) { let n = z(e) ? e : void 0, r = n && !Qe(n), i = t && !Qe(t); if (!(!r && !i)) return { ...n, ...t } } function cu(e, t, n) { if (!(t && fa())) return e; let { onClick: r, ...i } = e; return r ? n ? { ...i, onTap: r, onClick: lu } : { ...i, onTap: r } : e } function lu(e) { let t = Rl(e.target); !t || t.getAttribute(`target`) === `_blank` || e.preventDefault() } function uu(e, t, n, r, i, a) { let o = vl(e) ? e : Dl(e); if (!vl(o)) return L(e) ? ql(e).href : void 0; if (!t.getRoute || !t.currentRouteId) return; let s = t.getRoute(t.currentRouteId), { webPageId: c, hash: l, pathVariables: u, hashVariables: d, unresolvedHashSlugs: f, unresolvedPathSlugs: p } = o, m = t.getRoute(c), h = p || f ? a?.(p, f) : void 0; if (at(h)) return; let g = Object.assign({}, t.currentPathVariables, n, u, h?.path), _ = Object.assign({}, t.currentPathVariables, n, d, h?.hash), v = nr(m, { currentRoutePath: s?.path, currentRoutePathLocalized: s?.pathLocalized, currentPathVariables: t.currentPathVariables, hash: l, pathVariables: g, hashVariables: _, relative: !1, preserveQueryParams: t.preserveQueryParams, onlyHash: r, siteCanonicalURL: t.siteCanonicalURL, localeId: i?.id }); return r ? v : (i?.slug ? `/${i.slug}` : ``) + v } function du() { return (function () { async function e(e) { let t = new TextEncoder().encode(e), n = await crypto.subtle.digest(`SHA-256`, t); return Array.from(new Uint8Array(n)).map(e => e.toString(16).padStart(2, `0`)).join(``) } function t(e) { let t = ``; for (let n = 0; n < e; n++)t += `ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789`.charAt(Math.floor(Math.random() * 62)); return t } addEventListener(`message`, async n => { let { salt: r, difficulty: i, tokenLength: a, maxTime: o } = n.data, s = `0`.repeat(i), c = performance.now(), l = !0; for (; l;) { if (performance.now() - c > o) { l = !1, postMessage({ success: !1 }); return } let n = t(a), i = `${Date.now()}:${n}`, u = await e(r + i); if (u.startsWith(s)) { postMessage({ success: !0, secret: i, hash: u }); return } } }) }).toString() } async function fu() { return new Promise((e, t) => { let n = URL.createObjectURL(new Blob([`(`, du(), `)()`], { type: `application/javascript` })), r = new Worker(n); r.onmessage = t => { r.terminate(), URL.revokeObjectURL(n), t.data.success ? e({ secret: t.data.secret, hash: t.data.hash }) : e(void 0) }, r.onerror = e => { r.terminate(), URL.revokeObjectURL(n), t(e) }, r.postMessage({ salt: rC, difficulty: iC, tokenLength: aC, maxTime: oC }) }) } function pu(e) { return Array.from(e.keys()).map(encodeURIComponent).join(`,`) } function mu(e, t) { try { let n = t.cookie.match(`(^|;) ?framerFormsUTMTags=([^;]*)(;|$)`); if (n !== null && n[2]) { let t = JSON.parse(decodeURIComponent(n[2])); if (!t || typeof t != `object`) return;[`utm_source`, `utm_medium`, `utm_campaign`, `utm_term`, `utm_content`, `gclid`].forEach(n => { typeof t[n] == `string` && e.append(n, t[n]) }) } } catch { } } function hu() { let e = p.useContext(bC), t = p.useMemo(() => lC.map(e => ({ inputRef: p.createRef(), originalName: e, methodsUsed: { setAttribute: !1, valueProperty: !1 } })), []); return { states: t, convertHoneypotFieldsForSubmission: p.useCallback(() => { t.forEach(e => { let t = e.inputRef.current; t && (t.name = `${cC}_${e.originalName}`) }) }, [t]), replaceHoneypotWithMetadata: p.useCallback(n => { let r = t.length, i = 0, a = []; t.forEach(e => { let t = e.inputRef.current; if (t) { let r = t.name, o = t.value; if (o) { i++; let t = { [dC.name]: e.originalName, [dC.value]: o, [dC.setAttribute]: e.methodsUsed.setAttribute, [dC.valueProperty]: e.methodsUsed.valueProperty, [dC.isInputEventTrusted]: e.methodsUsed.isInputEventTrusted, [dC.inputChangeTimeSinceModuleLoad]: e.methodsUsed.inputChangeTimeSinceModuleLoad, [dC.wasFilledBeforeHydration]: e.methodsUsed.wasFilledBeforeHydration }; a.push(JSON.stringify(t)) } n.delete(r), t.name = e.originalName } }), n.append(`${cC}_${fC.fieldData}`, `[${a.join(`,`)}]`), n.append(`${cC}_${fC.fieldCount}`, r.toString()), n.append(`${cC}_${fC.fieldFilledCount}`, i.toString()), n.append(`${cC}_${fC.hpVersion}`, sC), n.append(`${cC}_${fC.siteId}`, e || ``), n.append(`${cC}_${fC.timeToSubmissionSinceModuleLoad}`, pC()) }, [t, e]) } } function gu({ states: e }) { return m(E, { children: e.map(e => m(mC, { inputStateRef: e }, `hp_${e.originalName}`)) }) } function _u({ router: e, nodeId: t, submitTrackingId: n }) { e?.pageviewEventData?.current && (e.pageviewEventData.current instanceof Promise ? e.pageviewEventData.current.then(e => { vu(e, t, n) }) : vu(e.pageviewEventData.current, t, n)) } function vu(e, t, n) { return Zt(`published_site_form_submit`, { ...e, nodeId: t ?? null, trackingId: n || null }, `eager`) } function yu({ state: e }, { type: t }) { switch (t) { case `complete`: return e === `error` ? yC : vC; case `incomplete`: return e === `error` ? yC : _C; case `submit`: return hC; case `success`: return gC; case `error`: return yC; default: V(t) } } function bu({ state: e }) { return e === `incomplete` || e === `complete` } function xu(e) { e.preventDefault() } function Su(e, t) { let n = Sl(e, !1) ? e : `https://${e}`, r = document.createElement(`a`); r.href = n, r.target = `_self`, r.style.display = `none`, `current` in t && t.current && (t.current.appendChild(r), r.click(), r.remove()) } function Cu(e) { if (e.children.length === 0) return !1; for (let t of e.children) if (t instanceof HTMLInputElement || t instanceof HTMLTextAreaElement || t instanceof HTMLSelectElement) { if (t.required && t.value === ``) return !0 } else if (Cu(t)) return !0; return !1 } async function wu(e, t, n) { let r = await fu(); if (!r) throw Error(`Failed to calculate proof of work`); let i = await fetch(e, { body: t, method: `POST`, headers: { "Framer-Site-Id": n, "Framer-POW": r.secret, "Framer-Form-Fields": pu(t) } }); if (i.ok) return i; { let e = await i.json(), t = `Failed to submit form`; throw Tu(e) ? Error(`${t} - ${e.error.message}`) : Error(t) } } function Tu(e) { return typeof e == `object` && !!e && `error` in e && z(e.error) && `message` in e.error && typeof e.error.message == `string` } function Eu({ EditorBar: e, fast: n = !1 }) { let r = Wh(), i = t(bC), a = ee(DC, n ? wC : TC, EC), o = b(() => { let e = {}, t; for (t in r) r.hasOwnProperty(t) && (t.startsWith(`editorBar`) || t.startsWith(`onPage`)) && (e[t] = r[t]); return e }, [r]); return !e || !i || !a ? null : m(CC, { children: m(T, { children: m(e, { framerSiteId: i, features: o }) }) }) } function Du({ currentRoutePath: e, routerAPI: t, children: n }) { let r = c(), a = c(), o = c(t), l = c(null); o.current = t, s(() => { e && (r.current ??= new Set, r.current.add(e), a.current?.(e)) }, [e]); let [u] = i(() => ({ getInitialState: () => ({ visitedPages: r.current ?? new Set, getCurrentRoutePath: () => ku(o.current, o.current.currentRouteId, o.current.currentPathVariables), resolveRoute: e => ku(o.current, e.webPageId, e.pathVariables), setRouteChangeHandler: e => { a.current = e }, sendTrackingEvent: async e => { Ou(o.current.pageviewEventData.current, e) } }), triggerStateRef: l })); return m(OC.Provider, { value: u, children: n }) } async function Ou(e, t) { if (!Qt(t.trackingId)) return; let n = e instanceof Promise ? await e : e; n && Zt(`published_site_trigger_invoke`, { ...n, ...t, trackingId: t.trackingId || null }, `lazy`) } function ku(e, t, n) { let r = e.getRoute(t); return !r || !r.path ? `` : n ? Cn(r.path, n) : r.path } function Au({ children: e, loadSnippetsModule: t }) { return m(zC.Provider, { value: t, children: e }) } function ju() { return p.useContext(zC) } function Mu(e) { return { start: `<!-- Snippet: ${e} -->`, end: `<!-- SnippetEnd: ${e} -->` } } async function Nu(e, t, n = `beforeend`) { let r, i; switch (n) { case `beforebegin`: B(t.parentNode, `Can't use 'beforebegin' with a referenceNode at the top level`), r = t.parentNode, i = t; break; case `afterend`: B(t.parentNode, `Can't use 'afterend' with a referenceNode at the top level`), r = t.parentNode, i = t.nextSibling; break; case `afterbegin`: r = t, i = t.firstChild; break; case `beforeend`: r = t, i = null; break; default: V(n) }let a = document.createRange(); a.selectNodeContents(r), await Pu(a.createContextualFragment(e), r, i) } async function Pu(e, t, n) { for (let r = e.firstChild; r; r = r.nextSibling) { if (r instanceof HTMLScriptElement) { let e = Fu(r, t, n); e !== void 0 && await e; continue } let e = r.cloneNode(!1); t.insertBefore(e, n), r.firstChild && await Pu(r, e, null) } } function Fu(e, t, n) { let r = e.cloneNode(!0); if (!e.hasAttribute(`src`) || e.hasAttribute(`async`) || e.hasAttribute(`defer`) || e.getAttribute(`type`)?.toLowerCase() === `module`) t.insertBefore(r, n); else return Iu(r, t, n) } function Iu(e, t, n) { return new Promise(r => { e.onload = e.onerror = r, t.insertBefore(e, n) }) } function Lu(e) { let t, n; switch (e) { case `bodyStart`: t = FC, n = IC; break; case `bodyEnd`: t = LC, n = RC; break; case `headStart`: t = jC, n = MC; break; case `headEnd`: t = NC, n = PC; break }let r = e === `bodyStart` || e === `bodyEnd` ? document.body : document.head, i = null, a = null; for (let e of r.childNodes) { if (e.nodeType !== Node.COMMENT_NODE) continue; let r = `<!--${e.nodeValue}-->`; r === t ? i = e : r === n && (a = e) } return { start: i, end: a } } function Ru(e, t, n) { if (!t || !n) return { start: null, end: null }; let r = null, i = null, { start: a, end: o } = Mu(e), s = t.nextSibling; for (; s && s !== n;) { if (s.nodeType !== Node.COMMENT_NODE) { s = s.nextSibling; continue } let e = `<!--${s.nodeValue}-->`; if (e === a) r = s; else if (e === o) { i = s; break } s = s.nextSibling } return { start: r, end: i } } async function zu(e, t, n) {
    if (t.length === 0) return; let { start: r, end: i } = Lu(e), a = e === `bodyStart` || e === `bodyEnd` ? document.body : document.head; for (let e of t) {
        let { start: t, end: o } = Ru(e.id, r, i), s = t && o; if (s && e.loadMode === `once`) continue; if (Bu(t, o), s) { await Nu(e.code, o, `beforebegin`); continue } let { start: c, end: l } = Mu(e.id), u = `${c}
${e.code}
${l}`, d = Hu(e.id, n, r, i); d ? await Nu(u, d, `afterend`) : await Nu(u, r ?? a, r ? `afterend` : `beforeend`)
    }
} function Bu(e, t) { if (!e || !t) return; let n = e.nextSibling; for (; n && n !== t;) { let e = n.nextSibling; Vu(n) && n.remove(), n = e } } function Vu(e) { if (e.nodeType !== Node.ELEMENT_NODE) return !0; if (e.nodeName === `SCRIPT`) { let t = e.type; if (!t || t === `text/javascript` || t === `module`) return !1 } return !0 } function Hu(e, t, n, r) { let i = t.indexOf(e) - 1; if (i < 0) return null; for (let e = i; e >= 0; e--) { let i = t[e]; if (!i) continue; let a = Ru(i, n, r).end; if (a) return a } return null } function Uu() { let e = ju(); return o(async (t, n, r, i) => { if (!e) return; let a = document.getElementById(kC), o = a && a.dataset[AC] !== void 0; if (i && o) return; let { getSnippets: s, snippetsSorting: c } = await e.readMaybeAsync(), l = await s(t, n, r); for (let e in l) { let t = e, n = l[t], r = c[t]; await zu(t, n, r) } }, [e]) } function Wu(e, t) { if (e.routeId !== t.routeId) return !1; if (e.pathVariables === t.pathVariables) return !0; let n = e.pathVariables || {}, r = t.pathVariables || {}; return n.length === r.length && Object.keys(n).every(e => n[e] === r[e]) } function Gu() { let e = Intl.DateTimeFormat().resolvedOptions(); BC = e.timeZone, VC = e.locale } function Ku() { let [e, t] = p.useState(0); return [e, p.useCallback(() => t(e => e + 1), [])] } function qu(e, t, r) { let i = e && document.getElementById(e); if (i) { $u(i, t); return } r || n.scrollTo(0, 0) } function Ju(e) { let t = c([]); return A(() => { t.current?.length && (t.current.forEach(e => e()), t.current = []) }, [e]), o(e => { t.current.push(e) }, []) } function Yu(e) { if (!e) return kh; let t = !1; return () => { t || (t = !0, e?.()) } } function Xu() { let e = or(), t = c(void 0); return o(async (r, i, a, o = !0) => { let s = a !== void 0; t.current?.abort(); let c = o ? new AbortController : void 0; t.current = c; let l = c?.signal, u = Nt(l); if (i.promise.finally(u), !s) return t.current = void 0, r(l), i.promise; r(l); let d; if (e(new Promise((e, t) => { d = e, l?.addEventListener(`abort`, t) }).catch(kh), a, c), await i.promise, l?.aborted) return; let f = n.navigation?.transition; d(); try { await f?.finished } catch (e) { console.error(`Navigation transition failed`, e) } l?.aborted || zg() }, [e]) } function Zu({ defaultPageStyle: e, disableHistory: t, initialPathVariables: r, initialRoute: i, notFoundPage: a, collectionUtils: u, routes: d, initialLocaleId: f, initialCollectionItemId: p, locales: h = Vh, preserveQueryParams: g = !1, LayoutTemplate: v, EditorBar: y, siteCanonicalURL: x, adaptLayoutToTextDirection: C }) { xr(), $n({ disabled: t, routeId: i, initialPathVariables: r, initialLocaleId: f }); let w = Gn(), [T, E] = Ku(), D = Ju(T), O = Xu(), k = Jn(`framer-route-change`), { synchronousNavigationOnDesktop: ee } = Wh(), j = b(() => !ee || !Sa() ? _ : e => e(), [ee]), M = Uu(), te = c(!0), ne = c(), N = c(i), re = c(r), ie = c(f), ae = ie.current, oe = b(() => h.find(({ id: e }) => ae ? e === ae : e === Gh) ?? null, [ae, h]), se = oe?.textDirection ?? `ltr`, ce = C ? se : `ltr`; A(() => { C && document.documentElement.setAttribute(`dir`, se) }, [se, C]); let le = ir(), ue = b(() => ({ activeLocale: oe, locales: h, setLocale: async e => { let t = k({ localized: !0 }); await mn({ priority: `user-blocking`, continueAfter: `paint` }); let r; L(e) ? r = e : z(e) && (r = e.id); let i = h.find(({ id: e }) => e === Gh), a = h.find(({ id: e }) => e === r); if (!a) return; let o = N.current, s = d[o]; if (s) try { let e = await le({ currentLocale: oe, nextLocale: a, route: s, routeId: o, defaultLocale: i, pathVariables: re.current, preserveQueryParams: g }); if (!e) return; let r = Xn(n.history.state) ? n.history.state.paginationInfo : void 0, c = e.path; te.current = !1, re.current = e.pathVariables, ie.current = a.id, O(() => { w(o, o, () => j(E)) }, t, async (t = !1) => { if (c) return Qn({ routeId: o, pathVariables: e.pathVariables, localeId: a.id, paginationInfo: r }, c, t) }, !1) } catch { } } }), [oe, E, h, g, d, O, w, k, j, le]), de = o((e, t, n, r, i, a, o, s = !1, c) => { te.current = !1; let l = N.current; if (N.current = e, re.current = i, ie.current = t, ne.current = r, D(() => { qu(n, s, a) }), a) { j(E); return } O(t => { w(l, e, () => j(E), t) }, o, c, !0) }, [E, D, O, w, j]); er(N, de); let fe = o(async (e, r, i, a, o) => { let s = d[e], c = lt(s?.page) ? s.page.getStatus() : void 0, l = c?.hasRendered, u = k({ cached: l, preloaded: l ? void 0 : c?.hasLoaded }), f = Yu(o); if (mn({ priority: `background`, ensureContinueBeforeUnload: !0, continueAfter: `paint` }).then(f), await mn({ priority: `user-blocking`, continueAfter: `paint` }), i) { let e = new Set, t = s?.path ?? `/`; for (let n of t.matchAll(Dg)) { let t = n[1]; if (t === void 0) throw Error(`A matching path variable should not be undefined`); e.add(t) } i = Object.fromEntries(Object.entries(i).filter(([t]) => e.has(t))) } let p = Mt(s, r), m = re.current, h = ie.current; if (Wu({ routeId: N.current, pathVariables: m }, { routeId: e, pathVariables: i })) { u.ignore?.(); let o = d[e]; n.history.state?.hash !== r && !t && o && (f(), await Yn(e, o, { currentRoutePath: o.path, currentPathVariables: m, pathVariables: i, hash: r, localeId: h, preserveQueryParams: g, siteCanonicalURL: x, currentRoutePathLocalized: o.pathLocalized })), qu(p, a, !1); return } if (!s) return; let _ = d[N.current]; de(e, h, p, On(x) + nr(s, { currentRoutePath: _?.path, currentRoutePathLocalized: _?.pathLocalized, currentPathVariables: m, hash: r, pathVariables: i, localeId: h, preserveQueryParams: g, siteCanonicalURL: x, relative: !1 }), i, !1, u, a, t ? void 0 : async (t = !1) => (f(), Yn(e, s, { currentRoutePath: _?.path, currentPathVariables: m, currentRoutePathLocalized: _?.pathLocalized, hash: r, pathVariables: i, localeId: h, preserveQueryParams: g, siteCanonicalURL: x }, t))) }, [d, de, t, g, x, k]), pe = wt(d), me = N.current, he = ne.current, P = re.current, ge = d[me], _e = ge?.path, ve = HC(ge, me, he, P, oe, p), ye = te.current; s(() => { M(me, P ?? {}, ue.activeLocale, ye) }, [M, me, P, ue, ye]); let F = b(() => ({ navigate: fe, getRoute: pe, currentRouteId: me, currentPathVariables: P, routes: d, collectionUtils: u, preserveQueryParams: g, pageviewEventData: ve, siteCanonicalURL: x, isInitialNavigation: ye }), [fe, pe, me, P, d, u, g, x, ve, ye]); if (!ge) throw Error(`Router cannot find route for ${me}`); let be = !oe || !ge.includedLocales || ge.includedLocales.includes(oe.id), xe = _e && P ? Cn(_e, P) : _e, I = String(ae) + xe, Se = Fi(() => ({ ...e, display: `contents` })); return m(Tt, { api: F, children: m(Jg.Provider, { value: ue, children: m(Yg.Provider, { value: ce, children: m(hr, { children: S(Du, { currentRoutePath: xe, routerAPI: F, children: [y && m(Eu, { EditorBar: y, fast: !0 }), m(dS, { children: S(Jc, { children: [S(C_, { notFoundPage: a, defaultPageStyle: e, forceUpdateKey: T, children: [m(x_.Start, {}), m(Qu, { LayoutTemplate: v, webPageId: ge?.abTestingVariantId ?? me, style: e, children: t => m(l, { children: be ? Er(ge.page, t ? Se : e) : a && Er(a, e) }, I) })] }), y && m(Eu, { EditorBar: y }), m(_r, {}), m(x_.End, {})] }) })] }) }) }) }) }) } function Qu({ LayoutTemplate: e, webPageId: t, style: n, children: r }) { return e ? m(e, { webPageId: t, style: n, children: r }) : r(!1) } function $u(e, t) { let n = t ? { behavior: `smooth`, block: `start`, inline: `nearest` } : void 0; e.scrollIntoView(n) } function ed(e) { return new Promise((t, n) => { try { new URL(e); let r = new Image; r.onload = () => t(), r.onerror = n, r.src = e } catch (e) { n(e) } }) } function td(e) { return typeof e == `object` && !!e } function nd(e, t) { if (t === ``) return e; let n = t.split(/[.[\]]+/u).filter(e => e.length > 0), r = e; for (let e of n) { if (!td(r)) return; r = r[e] } return r } function rd(e) { return `${e.credentials}:${e.url}` } function id(e) { return L(e) && !Number.isNaN(Number(e)) } function ad(e, t) { switch (e) { case `string`: return L(t) || R(t); case `color`: return L(t); case `boolean`: return Xe(t); case `number`: return R(t) || id(t); case `link`: case `image`: return L(t) && Sl(t, !1); default: return !1 } } function od(e, t) { if (e.status === `loading`) return t.fallbackValue; if (e.status === `error`) throw e.error; let n = nd(e.data, t.resultKeyPath); if ($e(n)) throw Error(`Key '${t.resultKeyPath}' not found in response`); if (!ad(t.resultOutputType, n)) throw Error(`Resolved value '${n}' is not valid for type '${t.resultOutputType}'`); return n } function sd(e, t) { if (J.current() === J.canvas) return !1; let n = Math.max(t * 1e3, WC); return Date.now() >= e + n } function cd(e) { let { RootComponent: t, isWebsite: n, environment: r, routeId: i, framerSiteId: a, pathVariables: o, routes: s, collectionUtils: c, notFoundPage: l, isReducedMotion: u = !1, includeDataObserver: d = !1, localeId: f, locales: h, preserveQueryParams: g, EditorBar: _, defaultPageStyle: v, disableHistory: y, LayoutTemplate: b, siteCanonicalURL: x, adaptLayoutToTextDirection: S, loadSnippetsModule: C, initialCollectionItemId: w } = e; return p.useEffect(() => { n || X_.start() }, []), n ? m(lr, { value: r ?? `preview`, children: m(Ae, { reducedMotion: u ? `user` : `never`, children: m(cn, { collectionUtils: c, children: m(nw, { children: m(ES, { children: m(bC.Provider, { value: a, children: m(Au, { loadSnippetsModule: C, children: m(Zu, { initialRoute: i, initialPathVariables: o, initialLocaleId: f, initialCollectionItemId: w, routes: s, collectionUtils: c, notFoundPage: l, locales: h, defaultPageStyle: v ?? { minHeight: `100vh`, width: `auto` }, preserveQueryParams: g, EditorBar: _, disableHistory: y, LayoutTemplate: b, siteCanonicalURL: x, adaptLayoutToTextDirection: S }) }) }) }) }) }) }) }) : m(d ? gx : p.Fragment, { children: m(Dt, { routes: s, children: m(ox, { children: p.isValidElement(t) ? t : p.createElement(t, { key: i }) }) }) }) } function ld(e) { return { trace(...t) { return eb.getLogger(e)?.trace(...t) }, debug(...t) { return eb.getLogger(e)?.debug(...t) }, info(...t) { return eb.getLogger(e)?.info(...t) }, warn(...t) { return eb.getLogger(e)?.warn(...t) }, error(...t) { return eb.getLogger(e)?.error(...t) }, get enabled() { return eb.getLogger(e) !== void 0 } } } function ud(e) { let t = e.next(); return B(t.done, `Generator must not yield`), t.value } async function dd(e, t = e.next()) { for (; !t.done;) { let n = await t.value; t = e.next(n) } return t.value } function fd(e) { let t = e.next(); return t.done ? t.value : dd(e, t) } function* W(e) { let t = {}, n = Object.keys(e), r = []; for (let i of n) { let n = e[i]; if (rt(n)) { let e = n.next(); e.done ? t[i] = e.value : r.push(dd(n, e).then(e => { t[i] = e })) } else t[i] = n } return r.length > 0 && (yield Promise.all(r)), t } function* pd(e) { let t = [], n = e.keys(), r = []; for (let i of n) { let n = e[i]; if (rt(n)) { let e = n.next(); e.done ? t[i] = e.value : r.push(dd(n, e).then(e => { t[i] = e })) } else t[i] = n } return r.length > 0 && (yield Promise.all(r)), t } function md(e) { return _d(e) || bd(e) } function hd(e) { return Ze(e) && e.every(z) } function gd(e) { return z(e) && Ye(e.read) && Ye(e.preload) } function _d(e) { return hd(e) || gd(e) } function vd(e) { return z(e) && z(e.schema) } function yd(e) { return z(e) && z(e.collectionByLocaleId) } function bd(e) { return vd(e) || yd(e) } function xd(e, t, n) { let r = e.value.length, i = t.value.length; if (r < i) return -1; if (r > i) return 1; for (let i = 0; i < r; i++) { let r = e.value[i], a = t.value[i], o = Xd(r, a, n); if (o !== 0) return o } return 0 } function Sd(e, t) { switch (e?.type) { case `array`: return { type: `array`, value: e.value.map(e => iw.cast(e, t.definition)) } }return null } function Cd(e, t) { return e.value < t.value ? -1 : e.value > t.value ? 1 : 0 } function wd(e) { switch (e?.type) { case `boolean`: return e; case `number`: case `string`: return { type: `boolean`, value: !!e.value } }return null } function Td(e) { return wd(e)?.value ?? !1 } function Ed(e, t) { return e.value < t.value ? -1 : e.value > t.value ? 1 : 0 } function Dd(e) { switch (e?.type) { case `color`: return e }return null } function Od(e, t) { let n = new Date(e.value), r = new Date(t.value); return n < r ? -1 : n > r ? 1 : 0 } function kd(e) { switch (e?.type) { case `date`: return e; case `number`: case `string`: { let t = new Date(e.value); return nt(t) ? { type: `date`, value: t.toISOString() } : null } }return null } function Ad(e, t) { return e.value < t.value ? -1 : e.value > t.value ? 1 : 0 } function jd(e) { switch (e?.type) { case `enum`: return e; case `string`: return { type: `enum`, value: e.value } }return null } function Md(e, t) { return e.value < t.value ? -1 : e.value > t.value ? 1 : 0 } function Nd(e) { switch (e?.type) { case `file`: return e }return null } function Pd(e, t) { let n = JSON.stringify(e.value), r = JSON.stringify(t.value); return n < r ? -1 : n > r ? 1 : 0 } function Fd(e) { switch (e?.type) { case `link`: return e; case `string`: try { let { protocol: t } = new URL(e.value); return t === `http:` || t === `https:` ? { type: `link`, value: e.value } : null } catch { return null } }return null } function Id(e, t) { return e.value < t.value ? -1 : e.value > t.value ? 1 : 0 } function Ld(e) { switch (e?.type) { case `number`: case `string`: { let t = Number(e.value); return Number.isFinite(t) ? { type: `number`, value: t } : null } }return null } function Rd(e) { return Ld(e)?.value ?? null } function zd(e, t, n) { let r = Object.keys(e.value).sort(), i = Object.keys(t.value).sort(); if (r.length < i.length) return -1; if (r.length > i.length) return 1; for (let a = 0; a < r.length; a++) { let o = r[a], s = i[a]; if (o < s) return -1; if (o > s) return 1; let c = Xd(e.value[o] ?? null, t.value[s] ?? null, n); if (c !== 0) return c } return 0 } function Bd(e, t) { switch (e?.type) { case `object`: { let n = {}, r = Object.entries(t.definitions); for (let [t, i] of r) { let r = e.value[t] ?? null; n[t] = iw.cast(r, i) } return { type: `object`, value: n } } }return null } function Vd(e, t) { let n = JSON.stringify(e.value), r = JSON.stringify(t.value); return n < r ? -1 : n > r ? 1 : 0 } function Hd(e) { switch (e?.type) { case `responsiveimage`: return e }return null } function Ud(e, t) { let n = e.value, r = t.value; return n < r ? -1 : n > r ? 1 : 0 } function Wd(e) { switch (e?.type) { case `richtext`: return e }return null } function Gd(e, t) { let n = e.value, r = t.value; return n < r ? -1 : n > r ? 1 : 0 } function Kd(e) { switch (e?.type) { case `vectorsetitem`: return e }return null } function qd(e, t, n) { let r = e.value, i = t.value; return n.type === 0 && (r = e.value.toLowerCase(), i = t.value.toLowerCase()), r < i ? -1 : r > i ? 1 : 0 } function Jd(e) { switch (e?.type) { case `string`: return e; case `number`: return { type: `string`, value: String(e.value) } }return null } function Yd(e) { return Jd(e)?.value ?? null } function Xd(e, t, n) { if (et(e) || et(t)) return B(e === t), 0; switch (e.type) { case `array`: return B(e.type === t.type), xd(e, t, n); case `boolean`: return B(e.type === t.type), Cd(e, t); case `color`: return B(e.type === t.type), Ed(e, t); case `date`: return B(e.type === t.type), Od(e, t); case `enum`: return B(e.type === t.type), Ad(e, t); case `file`: return B(e.type === t.type), Md(e, t); case `link`: return B(e.type === t.type), Pd(e, t); case `number`: return B(e.type === t.type), Id(e, t); case `object`: return B(e.type === t.type), zd(e, t, n); case `responsiveimage`: return B(e.type === t.type), Vd(e, t); case `richtext`: return B(e.type === t.type), Ud(e, t); case `vectorsetitem`: return B(e.type === t.type), Gd(e, t); case `string`: return B(e.type === t.type), qd(e, t, n); default: V(e) } } async function Zd(e, t) { return gd(e) ? (await e.preload(t), e.read(t)) : e } function Qd(e) { return e.includes(lw) } function $d(e) { if (!bd(e) || !e.id) return; let t = sw.get(e.id); if (!t) return sw.set(e.id, new WeakRef(e)), e.id; if (t.deref() === e) return e.id } function ef(e) { let t = $d(e); if (t) return t; let n = cw.get(e); if (n) return n; let r = `${lw}${Math.random().toString(16).slice(2)}`; return cw.set(e, r), r } function tf(e, t) { if (_d(e)) { let n = ef(e) + (t?.id ?? Gh), r = uw.get(n); if (r) return r; let i = new ow(e, t); return uw.set(n, i), i } if (vd(e)) return e; if (yd(e)) { for (; t;) { let n = e.collectionByLocaleId[t.id]; if (n) return n; t = t.fallback } return e.collectionByLocaleId.default } V(e, `Unsupported collection type`) } function nf() { return 25 } function rf() { return 12500 } function af(e) { return e } function of(e) { return e } function sf(e) { return z(e) && Ye(e.getHash) } function G(e, ...t) { return of(`${e}(${t.map(e => (B(!(e instanceof yw), `Pass CollectionMetadata.id instead`), B(!(e instanceof Sw), `Pass FieldMetadata.id instead`), B(!(e instanceof bw), `Pass IndexMetadata.id instead`), B(!(e instanceof hw), `Pass RelationalNode.group.id instead`), B(!(e instanceof fw), `Pass Group.id instead`), sf(e) ? e.getHash() : JSON.stringify(e))).join(`, `)})`) } function cf(e, t) { return { collectionId: ef(e), pointer: t } } function lf(e) { return z(e) && L(e.collectionId) } function uf(e, t) { return { collectionId: ef(e), pointer: t } } function df(e) { return z(e) && L(e.collectionId) } function ff(e, t) { let n = new Map; function r(e) { if (z(e)) if (e.type === `Collection` && md(e.data)) { let r = tf(e.data, t), i = ef(r); n.set(i, r) } else for (let t in e) { let n = e[t]; r(n) } else if (Ze(e)) for (let t of e) r(t) } return r(e), n } function pf(e) { return e } function mf(e) { return e } function hf(e) { return e } function gf(e) { return Array(e).fill({ type: `All` }) } function _f(e, ...t) {
    if (e) return; let n = Error(`Assertion Error` + (t.length > 0 ? `: ` + t.join(` `) : ``)); if (n.stack) try {
        let e = n.stack.split(`
`); e[1]?.includes(`assert`) ? (e.splice(1, 1), n.stack = e.join(`
`)) : e[0]?.includes(`assert`) && (e.splice(0, 1), n.stack = e.join(`
`))
    } catch { } throw n
} function vf(e) { let t = new Set; if (!e) return t; _f(e.type === `array`, `ScalarIntersection expects an array, got:`, e.type); for (let n of e.value) n && (_f(n.type === `string`, `ScalarIntersection expects an array of strings, got an array with:`, n.type), t.add(n.value)); return t } function yf(e) { return e.collection ? `"${e.collection}"."${e.name}"` : `"${e.name}"` } function bf(e) { return typeof e.value == `string` ? `'${e.value}'` : e.value } function xf(e) { return `${e.functionName}(${e.arguments.map(e => Ef(e)).join(`, `)})` } function Sf(e) { let t = `CASE`; e.value && (t += ` ${Ef(e.value)}`); for (let n of e.conditions) t += ` WHEN ${Ef(n.when)} THEN ${Ef(n.then)}`; return e.else && (t += ` ELSE ${Ef(e.else)}`), t += ` END`, t } function Cf(e) { let t = Ef(e.value); return `${e.operator.toUpperCase()} ${t}` } function wf(e) { let t = Ef(e.left), n = Ef(e.right); return `${t} ${e.operator.toUpperCase()} ${n}` } function Tf(e) { return `CAST(${Ef(e.value)} as ${e.dataType})` } function Ef(e) { switch (e.type) { case `Identifier`: return yf(e); case `LiteralValue`: return bf(e); case `FunctionCall`: return xf(e); case `Case`: return Sf(e); case `UnaryOperation`: return Cf(e); case `BinaryOperation`: return wf(e); case `TypeCast`: return Tf(e); case `Select`: return `${jf(e)}`; default: V(e) } } function Df(e) { return vd(e.data) ? `Collection` : e.alias ? `"${e.data.displayName}" AS "${e.alias}"` : `"${e.data.displayName}"` } function Of(e) { let t = `${kf(e.left)} LEFT JOIN ${kf(e.right)}`; return e.constraint && (t += ` ON ${Ef(e.constraint)}`), t } function kf(e) { switch (e.type) { case `Collection`: return Df(e); case `LeftJoin`: return Of(e); default: V(e) } } function Af(e) {
    let t = ``; return e.split(/\s+/u).forEach(e => {
        e !== `` && ([`SELECT`, `FROM`, `WHERE`, `ORDER`, `LIMIT`, `OFFSET`].includes(e) ? t += `
${e}` : [`AND`, `OR`].includes(e) ? t += `
	${e}` : t += ` ${e}`)
    }), t.trim()
} function jf(e) { let t = ``; return t += `SELECT ${e.select.map(e => { let t = Ef(e); return e.alias ? `${t} AS "${e.alias}"` : t }).join(`, `)}`, t += ` FROM ${kf(e.from)}`, e.where && (t += ` WHERE ${Ef(e.where)}`), e.orderBy && (t += ` ORDER BY ${e.orderBy.map(e => `${Ef(e)} ${e.direction ?? `asc`}`).join(`, `)}`), e.limit && (t += ` LIMIT ${Ef(e.limit)}`), e.offset && (t += ` OFFSET ${Ef(e.offset)}`), Af(t) } function Mf(e) { return z(e) && e.type === `Collection` } function Nf(e, t) { return Mf(t) && md(t.data) ? ef(t.data) : t } function Pf(e, t) { let n = t?.id ?? `default`; return JSON.stringify(e, Nf) + n } function Ff(e) { let { activeLocale: t } = pr(); return NT.get(e, t).use() } function If(e, t) { let n = Object.entries(e ?? {}).filter(([, e]) => !($e(e) || z(e))).map(([e, n]) => ({ type: `BinaryOperation`, operator: `==`, left: { type: `TypeCast`, value: { type: `Identifier`, name: e, collection: t }, dataType: `STRING` }, right: { type: `LiteralValue`, value: String(n) } })); return n.length === 0 ? { type: `LiteralValue`, value: !1 } : n.reduce((e, t) => ({ type: `BinaryOperation`, operator: `and`, left: e, right: t })) } function Lf(e) { let t = c(e); return d(() => { t.current = e }, [e]), fr((...e) => { let n = t.current; return n(...e) }, []) } function Rf(e, t) { e.forEach(e => clearTimeout(e)), e.clear(), t.forEach(e => e?.(`Callback cancelled by variant change`)), t.clear() } function zf() { return new Set } function Bf(e) { let t = Fi(zf), n = Fi(zf); return us(() => () => Rf(n, t)), s(() => () => Rf(n, t), []), s(() => { Rf(n, t) }, [e]), c({ activeVariantCallback: e => async (...n) => new Promise((r, i) => { t.add(i), e(...n).then(r) }).catch(() => { }), delay: async (e, t) => { await new Promise(e => { n.add(globalThis.setTimeout(() => e(!0), t)) }), e() } }).current } function Vf(e, t, n) { return p.useCallback(r => !n || !e ? {} : t ? Object.assign({}, n[e]?.[r], n[t]?.[r]) : n[e]?.[r] || {}, [e, t, n]) } function Hf(e) { for (let [t, n] of Object.entries(e)) if (K.matchMedia(n).matches) return t } function Uf(e) { let t = []; for (let { hash: n, mediaQuery: r } of e) r && K.matchMedia(r).matches && t.push(n); if (t.length > 0) return t; let n = e[0]?.hash; if (n) return [n] } function Wf(e, n, r = !0) { let i = t(rx), a = Wa(), l = c(!a && va() ? Hf(n) ?? e : e), u = c(r && i ? e : l.current), d = yo(), f = ae(), p = o(e => { if (e !== l.current || e !== u.current) { let t = function () { l.current = u.current = e, _(() => { d() }) }; a ? t() : f(() => { t() }) } }, [f, d, a]); return lb(() => { a && p(e) }, [e, a, p]), lb(() => { !r || i !== !0 || p(l.current) }, []), s(() => { let e = []; for (let [t, r] of Object.entries(n)) { let n = K.matchMedia(r), i = e => { e.matches && p(t) }; Gf(n, i), e.push([n, i]) } return () => e.forEach(([e, t]) => Kf(e, t)) }, [n, p]), [l.current, u.current] } function Gf(e, t) { e.addEventListener ? e.addEventListener(`change`, t) : e.addListener(t) } function Kf(e, t) { e.removeEventListener ? e.removeEventListener(`change`, t) : e.removeListener(t) } function qf(e) { setTimeout(e, 1) } function Jf(e) { let t = new Set, n = Uf(e); if (n) for (let e of n) for (let n of document.querySelectorAll(`.hidden-` + e)) Yf(n.previousSibling) && t.add(n.previousSibling), n.parentNode?.removeChild(n); (Mh ? K.requestIdleCallback : qf)(() => { document.querySelector(PT)?.remove() }); for (let e of document.querySelectorAll(`.ssr-variant:empty`)) Yf(e.previousSibling) && t.add(e.previousSibling), e.parentNode?.removeChild(e); for (let e of t) Xf(e.nextSibling) && (e.parentNode?.removeChild(e.nextSibling), e.parentNode?.removeChild(e)) } function Yf(e) { return e?.nodeType === Node.COMMENT_NODE && e.textContent === `$` } function Xf(e) { return e?.nodeType === Node.COMMENT_NODE && e.textContent === `/$` } function Zf(e, t) { e !== !1 && ke.render(() => { let e = document.documentElement.style; t ? e.setProperty(`overflow`, `hidden`) : e.removeProperty(`overflow`) }) } function Qf({ blockDocumentScrolling: e = !0, dismissWithEsc: t = !1 } = {}) { let [n, r] = p.useState(!1), i = p.useCallback(async t => { await mn({ priority: `user-blocking`, continueAfter: `paint` }), _(() => r(t)), Zf(e, t) }, [e]); return p.useEffect(() => () => { mn({ priority: `user-blocking`, continueAfter: `paint` }).then(() => { Zf(e, !1) }) }, [e]), p.useEffect(() => { if (!t) return; let e = e => { e.key === `Escape` && (e.preventDefault(), e.stopPropagation(), i(!1)) }; return K.addEventListener(`keydown`, e), () => K.removeEventListener(`keydown`, e) }, [t, i]), [n, i] } function $f(e) { return z(e) && FT in e && e.page !== void 0 } function ep(e, t) { return `${e}-${t}` } function tp(e, t) { let n = e.indexOf(t) + 1; n >= e.length && (n = 0); let r = e[n]; return B(r !== void 0, `nextVariant should be defined`), r } function np(e, t) { if (e) { if (t) { let n = e[t]; if (n) return n } return e.default } } function rp(e, t, n, r, i) { let { hover: a, pressed: o, loading: s, error: c } = e || {}; if (c && i) return `error`; if (s && r) return `loading`; if (o && n) return `pressed`; if (a && t) return `hover` } function ip(e, t) { return t[e] || `framer-v-${e}` } function ap(e, t, n) { return e && n.has(e) ? e : t } function op() { let e = c(), t = c(), n = o(() => { e.current && (document.removeEventListener(`visibilitychange`, e.current), e.current = void 0, t.current = void 0) }, []); return s(() => () => { n() }, [n]), o(r => { if (!document.hidden) { r(), n(); return } if (t.current = r, e.current) return; let i = () => { document.hidden || (t.current?.(), n()) }; e.current = i, document.addEventListener(`visibilitychange`, i) }, [n]) } function sp() { let e = c(), n = c(!1), r = c(), i = t(Bb); return s(() => () => { e.current?.(), r.current = void 0, e.current = void 0 }, []), o((t, a) => { if (!a?.current || n.current) { t(); return } if (r.current = t, e.current) return; let o = !1; e.current = rs(i, `undefined`, a.current, null, e => { n.current = e.isIntersecting, !o && (o = !0, queueMicrotask(() => { o = !1, n.current && r.current?.() })) }) }, [i]) } function cp(e) { let t = op(), n = sp(); return o((r, i = !1) => { if (jh) { r(); return } t(i && e ? () => n(r, e) : r) }, [t, n, e]) } async function lp() { return new Promise(e => { let t = e; setTimeout(() => { t && (performance.mark(`wait-for-click-fallback`), t()) }, 150), RT = () => { e(), t = void 0 } }) } function up(e) { e.button === 0 && (performance.mark(`pointerdown-listener`), LT = lp()) } function dp() { performance.mark(`click-received-listener`), LT = void 0, RT?.(), RT = void 0 } function fp(e = !1) { s(() => { e && (document.addEventListener(`pointerup`, up, !0), document.__proto__.addEventListener.call(document, `click`, dp, !0)) }, [e]) } function pp({ variant: e, defaultVariant: t, transitions: n, enabledGestures: r, cycleOrder: i = [], variantProps: a = {}, variantClassNames: s = {}, ref: l }) { let u = yo(), d = bl(), f = Fi(() => new Set(i)), { yieldOnTap: p } = Wh(); fp(p); let m = cp(l), h = c({ isHovered: !1, isHoveredHasUpdated: !1, isPressed: !1, isPressedHasUpdated: !1, isError: !1, hasPressedVariants: !0, baseVariant: ap(e, t, f), lastVariant: e, gestureVariant: void 0, loadedBaseVariant: {}, defaultVariant: t, enabledGestures: r, cycleOrder: i, transitions: n }), g = o(e => { let { isHovered: t, isPressed: n, isError: r, enabledGestures: i, defaultVariant: a } = h.current, o = ap(e, a, f), s = rp(i?.[o], t, n, !1, r); return [o, s ? ep(o, s) : void 0] }, []), v = o(async (e, t, n, r, i = !1, a = !1) => { let [o, s] = g(r); if (o === e && s === t) return; a && (h.current.isError = !1), h.current.baseVariant = o || n, h.current.gestureVariant = s; let c = p && h.current.isPressedHasUpdated; c && LT && (performance.mark(`wait-for-tap-start`), await LT, performance.measure(`wait-for-tap`, `wait-for-tap-start`)), c && (performance.mark(`yield-on-tap-start`), await mn({ priority: `user-blocking`, continueAfter: `paint` }), performance.measure(`yield-on-tap`, `yield-on-tap-start`)); let { isHovered: l, isPressed: d, isHoveredHasUpdated: f, isPressedHasUpdated: v } = h.current; if (l || f || d || v) { _(u); return } m(() => _(u), i) }, [g, u, m, p]), y = o(({ isHovered: e, isPressed: t, isError: n }) => { let r = t !== h.current.isPressed, i = e !== h.current.isHovered; e !== void 0 && (h.current.isHovered = e), t !== void 0 && (h.current.isPressed = t), n !== void 0 && (h.current.isError = n); let { baseVariant: a, gestureVariant: o, defaultVariant: s } = h.current; h.current.isPressedHasUpdated = r, h.current.isHoveredHasUpdated = i, v(a, o, s, a, !1) }, [v]), x = o((e, t = !1) => { let { defaultVariant: n, cycleOrder: r, baseVariant: i, gestureVariant: a } = h.current; v(i, a, n, e === IT ? tp(r || [], i || n) : e, t, !0) }, [v]), S = o(() => { let { baseVariant: e } = h.current; h.current.loadedBaseVariant[e] = !0, m(() => _(u), !0) }, [u, m]); if (e !== h.current.lastVariant) { let [t, n] = g(e); h.current.lastVariant = t, (t !== h.current.baseVariant || n !== h.current.gestureVariant) && (h.current.baseVariant = t, h.current.gestureVariant = n) } let { baseVariant: C, gestureVariant: w, defaultVariant: T, enabledGestures: E, isHovered: D, isPressed: O, isError: k, loadedBaseVariant: A } = h.current, ee = Vf(h.current.baseVariant, h.current.gestureVariant, a); return b(() => { let e = []; C !== T && e.push(C); let t = E?.[C]?.loading, n = !k && !d && !!t && !A[C], r = n ? ep(C, `loading`) : w; r && e.push(r); let i = E?.[C], a = { onMouseEnter: () => y({ isHovered: !0 }), onMouseLeave: () => y({ isHovered: !1 }) }; return i?.pressed && Object.assign(a, { onTapStart: () => y({ isPressed: !0 }), onTapCancel: () => y({ isPressed: !1 }), onTap: () => y({ isPressed: !1 }) }), { variants: e, baseVariant: C, gestureVariant: r, isLoading: n, transition: np(h.current.transitions, C), setVariant: x, setGestureState: y, clearLoadingGesture: S, addVariantProps: ee, gestureHandlers: a, classNames: tc(ip(C, s), rp(i, D, O, n, k)) } }, [C, w, D, O, A, ee, x, T, E, y, S, s]) } function mp(e, { scopeId: t, nodeId: n, override: r, inComponentSlot: i }) { if (!Qc()) return r(e); let a = hp(e, r), o = !1; function s(r, s) { let c = tl(); if (ll(t, c?.scopeId, c?.level, i ?? !1)) return a.status === `success` ? m(Wg.Provider, { value: n, children: m($c, { getErrorMessage: ol.bind(null, t, n), fallback: m(e, { ...r, ref: s }), children: m(a.Component, { ...r, ref: s }) }) }) : (o ||= (Zc(a.error), Zc(ol(t, n)), Xc(a.error), !0), m(e, { ...r, ref: s })); if (a.status === `success`) return m(Wg.Provider, { value: n, children: m(a.Component, { ...r, ref: s }) }); throw a.error } return p.forwardRef(s) } function hp(e, t) { try { return { status: `success`, Component: t(e) } } catch (e) { return { status: `error`, error: e } } } function gp(e) { let t = e.__FramerMetadata__.exports.default.annotations?.framerVariables; if (t) try { return JSON.parse(t) } catch { return } } function _p(e, t) { return n => { let r = {}, i = gp(t); for (let e in n) qy(r)[i?.[e] ?? e] = n[e]; return m(e, { ...r }) } } function vp(e, t, n) { let r = [], i = Dc(e, t, e => r.unshift(e, e)); if (n) { let e = i[i.length - 1]; if (!R(e)) return VT; i.push(e + 1), r.push(-1) } let a = i[0]; return R(a) ? a <= 1 ? { inputRange: i, outputRange: r } : { inputRange: [0, Math.max(a - 1, 0), ...i], outputRange: [-1, -1, ...r] } : VT } function yp(e) { return e.weight !== void 0 && e.style !== void 0 } function bp(e, t) { let n = t === `normal` ? `Regular` : `Italic`; return e === 400 ? n : t === `normal` ? `${XT[e]}` : `${XT[e]} ${n}` } function xp() { return n === void 0 ? {} : QT || (QT = Sp(), QT) } function Sp() { let e = n.location, t = n?.bootstrap?.services; if (t) return t; let r; try { if (r = n.top.location.origin, t = n.top?.bootstrap?.services, t) return t } catch { } if (r && r !== e.origin) throw Error(`Unexpectedly embedded by ${r} (expected ${e.origin})`); if (e.origin.endsWith(`framer.com`) || e.origin.endsWith(`framer.dev`)) throw Error(`ServiceMap data was not provided in document`); try { let n = new URLSearchParams(e.search).get(`services`) || new URLSearchParams(e.hash.substring(1)).get(`services`); n && (t = JSON.parse(n)) } catch { } if (t && typeof t == `object` && t.api) return t; return { api: ``, userContent: `https://framerusercontent.com` } } function Cp(e) { return e.key + e.extension } function wp(e) { return `${xp().userContent}/assets/${e}` } function Tp(e) { return wp(Cp(e)) } function Ep(e, t) { return t ? `${e} ${$T}` : e } function Dp(e, t) { switch (t) { case `custom`: throw Error(`Custom fonts are not supported`); default: return Ep(e.name, e.isVariable) } } function Op(e) { return !!(e && Array.isArray(e)) } function kp(e) { if (!e || !Array.isArray(e)) return; let t = []; for (let n of e) jp(n) && t.push({ tag: n.tag, name: n.name, minValue: n.minValue, maxValue: n.maxValue, defaultValue: n.defaultValue }); return t } function Ap(e) { return !(typeof e != `object` || !e || !(`tag` in e) || typeof e.tag != `string` || `coverage` in e && e.coverage !== void 0 && !Array.isArray(e.coverage)) } function jp(e) { return !(typeof e != `object` || !e || !(`tag` in e) || typeof e.tag != `string` || `name` in e && typeof e.name != `string` || !(`minValue` in e) || typeof e.minValue != `number` || !(`maxValue` in e) || typeof e.maxValue != `number` || !(`defaultValue` in e) || typeof e.defaultValue != `number`) } function Mp(e) { return nE[Np(e)] } function Np(e) { return e.toLowerCase().replace(/\s+/gu, `-`) } function Pp(e) { return e = e.toLowerCase(), e.includes(`italic`) || e.includes(`oblique`) || e.includes(`slanted`) ? `italic` : `normal` } function Fp(e, t) { return { ...Ip(e, t), ...Lp(e, t) } } function Ip(e, t) { if (t.length === 0) return { variantBold: void 0, variantBoldItalic: void 0, variantItalic: void 0 }; let { weight: n, style: r } = e, i = new Map, a = new Map; for (let r of t) r.isVariable === e.isVariable && (i.set(`${r.weight}-${r.style}`, r), !(r.weight <= n) && (a.has(r.style) || a.set(r.style, r))); let o = a.get(r), s = a.get(`italic`), c = e.weight; c <= 300 ? (o = i.get(`400-${r}`) ?? o, s = i.get(`400-italic`) ?? s) : c <= 500 ? (o = i.get(`700-${r}`) ?? o, s = i.get(`700-italic`) ?? s) : (o = i.get(`900-${r}`) ?? o, s = i.get(`900-italic`) ?? s); let l = i.get(`${n}-italic`); return { variantBold: o, variantItalic: l, variantBoldItalic: s } } function Lp(e, t) { if (t.length === 0) return { variantVariable: void 0, variantVariableItalic: void 0 }; let n, r, i, a; for (let o of t) { if (!o.isVariable) continue; let t = o.weight === e.weight, s = o.weight === 400; o.style === `normal` ? t ? n = o : s ? i = o : i ||= o : o.style === `italic` && (t ? r = o : s ? a = o : a ||= o) } return { variantVariable: n ?? i, variantVariableItalic: r ?? a } } function Rp(e) { return !!e.variationAxes } function zp(e) { return Bp(e) || Vp(e) } function Bp(e) { return e.startsWith(aE) } function Vp(e) { return e.startsWith(iE) } function Hp(e, t) { for (let n = 0; n < e.length; n++) { let r = e[n]; if (r) { if (r.owner !== t.owner && r.file === t.file) return { existingFont: r, index: n, projectDuplicate: !0 }; if (r && r.selector === t.selector) return { existingFont: r, index: n, projectDuplicate: !1 } } } } function Up(e) { let { font: t } = e, n = t.fontFamily, r = Array.isArray(t.variationAxes); if (r && n.toLowerCase().includes(`variable`)) return n; let i = r ? $T : t.fontSubFamily.trim(); return i === `` ? n : `${n} ${i}` } function Wp({ fontFamily: e, fontSubFamily: t, variationAxes: n, faceDescriptors: r }) { let i = t.trim() || `Regular`, a = i.toLocaleLowerCase().includes(`variable`), o = kp(n) && !a ? `Variable ${i}` : i, s = `normal`, c = 400; return r && (c = r.weight, s = r.italic || r.oblique ? `italic` : `normal`), { family: e, variant: o, weight: c, style: s } } function Gp(e) { if (!(!e.weight || !e.style)) return { weight: e.weight, style: e.style, isVariable: Rp(e), selector: e.selector } } function Kp(e) { let t = e.fonts.map(e => Gp(e)).filter(e => e !== void 0); for (let n of e.fonts) { let e = Gp(n); if (!e) continue; let r = Fp(e, t); n.selectorVariable = r.variantVariable?.selector, n.selectorVariableItalic = r.variantVariableItalic?.selector, n.selectorBold = r.variantBold?.selector, n.selectorBoldItalic = r.variantBoldItalic?.selector, n.selectorItalic = r.variantItalic?.selector } } function qp(e) { return e.ownerTypes.includes(`team`) ? `team` : `project` } async function Jp(e) { switch (e) { case `google`: return (await import(`./google-VQ4ZP4WR.Dv9zQcVi.mjs`)).default; case `fontshare`: return (await import(`./fontshare-Q7VOJ3QT.C1rh5kMp.mjs`)).default; default: throw Error(`Unknown font source: ${e}`) } } async function Yp(e) { switch (e) { case `google`: return (await import(`./google-TRAPONMP.D30CrhOT.mjs`)).default; case `fontshare`: return (await import(`./fontshare-LJWOE5KG.BWe-PH9s.mjs`)).default; case `framer`: return (await import(`./framer-font-G73BNA7N.DW-3R9Cb.mjs`)).default; default: throw Error(`Unknown font source: ${e}`) } } function Xp(e) { return e.split(`,`).map(e => e.trim().toLowerCase()).filter(Zp) } function Zp(e) { return sE.includes(e) } function Qp(e) { let t = { serif: `serif`, sans: `sans-serif`, slab: `slab`, display: `display`, handwritten: `handwriting`, script: `handwriting` }, n = Xp(e)[0]; return n && t[n] } function $p(e) { let t = { serif: `serif`, "sans-serif": `sans-serif`, display: `display`, handwriting: `handwriting`, monospace: `monospace` }; if (e) return t[e] } function em(e, t) { return e.reduce((e, n) => (e[t(n)] = n, e), {}) } async function tm(e, t, n = 0) { let { family: r, url: i, stretch: a, unicodeRange: o } = e, s = e.weight, c = e.style || `normal`, l = `${r}-${c}-${s}-${i}`; if (!CE.has(l) || n > 0) { let u = new FontFace(r, `url(${i})`, { weight: L(s) ? s : s?.toString(), style: c, stretch: a, unicodeRange: o }), d = u.load().then(() => (t.fonts.add(u), nm(r, c, s))).catch(l => { if (l.name !== `NetworkError`) throw l; if (n < xE) return tm(e, t, n + 1); throw new SE(`Font loading failed after ${n} retries due to network error: ${JSON.stringify({ family: r, style: c, weight: s, url: i, stretch: a, unicodeRange: o })}`) }); CE.set(l, d) } await CE.get(l) } async function nm(e, t, n) { let r = `${e}-${t}-${n}`; if (!wE.has(r)) { let i = new yE.default(e, { style: t, weight: n }).load(null, bE); wE.set(r, i) } try { await wE.get(r) } catch { throw new SE(`Failed to check if font is ready (${bE}ms timeout exceeded): ${JSON.stringify({ family: e, style: t, weight: n })}`) } } function rm(e) { try { if (e === `framer`) return im(EE) ? EE : void 0; { let t = (async () => { switch (e) { case `google`: return (await import(`./google-LLNWFNMY.BLE5-Goo.mjs`)).default; case `fontshare`: return (await import(`./fontshare-MHXFPDHS.LvLui89J.mjs`)).default; default: V(e) } })(); return im(t) ? t : void 0 } } catch (e) { console.error(e); return } } function im(e) { return z(e) && Object.values(e).every(om) } function am(e) { return z(e) && L(e.tag) } function om(e) { return Array.isArray(e) && e.every(am) } function sm() { return m(`svg`, { xmlns: `http://www.w3.org/2000/svg`, width: `8`, height: `8`, viewBox: `0 0 8 8`, "aria-hidden": `true`, children: m(`path`, { d: `m1.5 6.5 5-5M6.5 6.5l-5-5`, fill: `none`, stroke: `currentColor`, strokeWidth: `1.5`, strokeLinecap: `round` }) }) } function cm(e, t) { s(() => { function r(n) { n.key === `Escape` && e && (n.preventDefault(), n.stopPropagation(), t()) } return n.addEventListener(`keyup`, r), () => n.removeEventListener(`keyup`, r) }, [e, t]) } function lm(e, t, r, i) { let a = n.innerHeight - i, o = Math.min(n.innerWidth - r, t), s = a / e; return Math.min(o, s) } function um(e, { width: t, height: r }) { if (!e.src || !e.srcSet) return; let i = new n.Image; return i.src = e.src, i.srcset = e.srcSet, i.sizes = e.sizes || ``, i.width = t, i.height = r, i.decode() } function dm() { return document.getElementById(US) ?? document.getElementById(HS) ?? document.body } function fm(e, t) { return R(e) ? e : t ?? 0 } function pm(e) { return fm(e?.paddingTop, e?.padding) + fm(e?.paddingBottom, e?.padding) } function mm(e) { return fm(e?.paddingLeft, e?.padding) + fm(e?.paddingRight, e?.padding) } function hm(e, t) { if (!e || !t || !t.src) return t; let n = new URL(t.src); return n.searchParams.delete(`scale-down-to`), n.searchParams.delete(`lossless`), { ...t, sizes: `min(100vw, ${e.maxWidth - mm(e)}px)`, srcSet: Xa(t.nodeFixedSize, t, t.src).srcSet } } function gm(e) { if (!e) return !1; for (let t in e) { if (!(t in BE)) continue; let n = BE[t], r = e[t]; if (!(!R(n) || !R(r)) && n !== r) return !0 } return !1 } function _m(e) { let t = ye.get(e.current); if (!t) return !1; if (gm(t.projection?.latestValues)) return !0; let n = t.projection?.path; if (!n || n.length === 0) return !1; for (let e of n) if (gm(e.latestValues)) return !0; return !1 } function vm(e) { return v(function ({ lightbox: n, lightboxClassName: r, onClick: a, ...u }, d) { let f = t(Se), p = t(zT), h = !!p, g = c(null), v = d ?? g, x = c(), C = b(() => hm(n, u.background), [n, u.background]), [w, T] = i(!1), [D, k] = i(), A = o(() => { if (n) { if (w) { _(() => { T(!0) }); return } ke.read(() => { if (!v.current) return; let e = getComputedStyle(v.current), t = v.current.getAttribute(`data-border`) === `true` ? getComputedStyle(v.current, `::after`) : void 0, r = v.current.offsetWidth ?? 1, i = v.current.offsetHeight ?? 1, a = _m(v) || h ? { duration: 0 } : n.transition; _(() => { k({ borderRadius: e.borderRadius, aspectRatio: r / (i || 1), borderTop: t?.borderTopWidth, borderRight: t?.borderRightWidth, borderBottom: t?.borderBottomWidth, borderLeft: t?.borderLeftWidth, borderStyle: t?.borderStyle, borderColor: t?.borderColor, transition: a, imageRendering: e.imageRendering, filter: e.filter }), T(!0), p?.stop() }) }) } }, [n, w, v, p?.stop, h]), ee = D?.aspectRatio ?? 1, j = Lf(() => { if (!n || !C || !C.src) return; let e = x.current?.[C.src]; if (e) return e; let t = lm(ee, n.maxWidth, mm(n), pm(n)), r = um(C, { width: t, height: t * ee }); return x.current = { [C.src]: r }, r }), M = o(async e => { a?.(e), !(w || !n || !C) && (await j(), A()) }, [a, A, w, C, n, j]), te = o(e => { e?.stopPropagation(), _(() => { T(!1) }) }, []); cm(w, te), s(() => { if (!n) return; let e; function t() { e = setTimeout(() => { j() }, 50) } function r() { clearTimeout(e) } let i = v.current; return i?.addEventListener(`mouseenter`, t), i?.addEventListener(`mouseleave`, r), i?.addEventListener(`pointerdown`, j), () => { r(), i?.removeEventListener(`mouseenter`, t), i?.removeEventListener(`mouseleave`, r), i?.removeEventListener(`pointerdown`, j) } }, [j, v, n]); let ne = O(), N = D?.transition ?? u.transition ?? f.transition, re = D?.borderRadius, ie = D?.imageRendering, ae = D?.filter, oe = D?.borderTop, se = D?.borderRight, ce = D?.borderBottom, le = D?.borderLeft, ue = D?.borderStyle, de = D?.borderColor, fe = !!(oe || se || ce || le || ue || de), pe = fe ? { "--border-top-width": oe, "--border-right-width": se, "--border-bottom-width": ce, "--border-left-width": le, "--border-style": ue, "--border-color": de } : void 0, me = { [OS]: u.id }, he = fm(n?.paddingTop, n?.padding), ge = fm(n?.paddingBottom, n?.padding), _e = fm(n?.paddingLeft, n?.padding), ve = fm(n?.paddingRight, n?.padding), ye = D?.borderRadius ? { ...u.style, borderRadius: D.borderRadius } : u.style, F = w ? u.layoutDependency ? `${u.layoutDependency}-open` : `open` : u.layoutDependency, be = h && w ? void 0 : u.layoutId ?? (n ? ne : void 0); return S(E, { children: [m(e, { ...u, style: ye, onClick: M, layoutId: be, ref: v, layoutDependency: F, transition: N }), m(Fe, { onExitComplete: () => { _(() => { k(void 0), p?.start() }) }, children: w && n && C && m(l, { children: y(S(E, { children: [m(P.div, { ...me, className: r, onClick: te, style: { position: `fixed`, inset: 0, zIndex: n.zIndex, backgroundColor: n.backdrop ?? `transparent` }, transition: N, initial: VE, animate: HE, exit: VE }), m(P.div, { ...me, className: r, style: { alignItems: `center`, display: `flex`, inset: `${he}px ${ve}px ${ge}px ${_e}px`, justifyContent: `center`, pointerEvents: `none`, position: `fixed`, zIndex: n.zIndex }, children: m(`div`, { style: { alignItems: `center`, aspectRatio: ee, display: `flex`, justifyContent: `center`, maxHeight: `100%`, position: `relative`, width: `100%`, maxWidth: n.maxWidth }, children: m(P.div, { layoutId: be, transition: N, onClick: A, className: `framer-lightbox-container`, "data-border": fe, style: { aspectRatio: ee, borderRadius: re, bottom: 0, position: `absolute`, top: 0, userSelect: `none`, imageRendering: ie, filter: ae, ...pe }, children: m(ao, { image: C, alt: C.alt, draggable: u.draggable }) }) }) })] }), dm()) }, `backdrop`) })] }) }) } function ym(e, t) { return GE && !t ? Document.parseHTMLUnsafe(e) : (WE ??= new DOMParser, WE.parseFromString(e, t ?? `text/html`)) } function bm(e) { return e.replaceAll(`&`, `&amp;`).replaceAll(`<`, `&lt;`).replaceAll(`>`, `&gt;`).replaceAll(`"`, `&quot;`).replaceAll(`'`, `&#39;`) } function xm(e, t, n, r) { return e.replace(KE, (e, i, a, o, s, c, l) => { if (a.toLowerCase() !== `a`) return e; let u = s || c, d = Tl(u.replace(/&amp;/gu, `&`)); if (!d || !d.target) return e; let f = t(d.target); if (!$f(f) || !$f(n)) return e; let p = f.path, m = n.path; if (!p || !m) return e; let h = ` data-framer-page-link-target="${d.target}"`, g = Mt(f, d.element ?? void 0); g && (h += ` data-framer-page-link-element="${d.element}"`); let _ = Dl(u); if (!_ || L(_)) return e; Gl(n, _, r) && (h += ` data-framer-page-link-current`); let v = p, y = Object.assign({}, r, d.collectionItem?.pathVariables); if (Object.keys(y).length > 0 && (v = v.replace(GS, (e, t) => `` + y[t])), d.collectionItem?.pathVariables) { let e = new URLSearchParams(d.collectionItem.pathVariables); h += ` data-framer-page-link-path-variables="${e}"` } return v = yn(m, v), i + o + `"${bm(v + (g ? `#${g}` : ``))}"` + h + l }) } function Sm(e, t) { return e.length === t.length && e.every((e, n) => e === t[n]) } function Cm(e) { switch (e) { case `top`: return `flex-start`; case `center`: return `center`; case `bottom`: return `flex-end` } } function wm(e, t, n) { let r = c([]); Sm(r.current, e) || (r.current = e, OE.loadFonts(e).then(({ newlyLoadedFontCount: e }) => { !t || !n.current || J.current() !== J.canvas || e > 0 && To(n.current) })) } function Tm() { return { current: null } } async function Em(e, t) { let n = e.current; if (n) return n; let r, i = new Promise((e, n) => { r = e, t.signal.addEventListener(`abort`, () => n()) }); return Object.defineProperty(e, `current`, { get() { return n }, set(e) { if (n = e, e === null) { t.abort(); return } r(e) }, configurable: !0 }), i } function Dm(e) { return e in XE } function Om(e, t) { let n = {}; for (let r in e) { if (!Dm(r)) continue; let i = e[r], a = XE[r]; $e(i) || $e(a) || t && r !== `opacity` || (n[r] = [i, a]) } return n } function km(e, t = `character`, n, r, i) { if (r) { let t = Tm(); return n.add(t), m(`span`, { ref: t, style: i, children: e }) } switch (t) { case `character`: case `line`: { let t = e.split(` `), r = t.length - 1; return t.map((e, t) => { let a = t === r; return S(l, { children: [m(`span`, { style: { whiteSpace: e.length <= 12 ? `nowrap` : `unset` }, children: e.match(ZE)?.map((e, t) => { let r = Tm(); return n.add(r), m(`span`, { ref: r, style: i, children: e }, e + t) }) }), a ? null : ` `] }, e + t + a) }) } case `word`: { let t = e.split(` `), r = t.length - 1; return t.map((e, t) => { let a = t === r, o = Tm(); return n.add(o), S(l, { children: [m(`span`, { ref: o, style: i, children: e }), a ? null : ` `] }, e + t + a) }) } case `element`: default: return e } } function Am(e) { let t = e.type; switch (t) { case `appear`: return e.tokenization ?? `character`; default: V(t) } } function jm(e) { let t = []; return R(e.x) && t.push(`translateX(${e.x}px)`), R(e.y) && t.push(`translateY(${e.y}px)`), R(e.scale) && t.push(`scale(${e.scale})`), R(e.rotate) && t.push(`rotate(${e.rotate}deg)`), R(e.rotateX) && t.push(`rotateX(${e.rotateX}deg)`), R(e.rotateY) && t.push(`rotateY(${e.rotateY}deg)`), R(e.skewX) && t.push(`skewX(${e.skewX}deg)`), R(e.skewY) && t.push(`skewY(${e.skewY}deg)`), t.join(` `) } function Mm(e, t, n, r) { if (!n || !n.effect) return; let i = n.type; switch (i) { case `appear`: switch (n.tokenization) { case `element`: return !e || !t ? void 0 : { opacity: n.effect.opacity, filter: r ? void 0 : n.effect.filter, transform: r ? void 0 : jm(n.effect) }; case `line`: case `word`: case `character`: default: return !e || !t ? { display: `inline-block` } : { display: `inline-block`, opacity: n.effect.opacity, filter: r ? void 0 : n.effect.filter, transform: r ? void 0 : jm(n.effect) } }default: V(i) } } function Nm(e, t, n) { let r = Fi(() => new Set), i = Ua(), a = n || !i, o = Je(), l = c({ hasMounted: !1, hasAnimatedOnce: !1, isAnimating: !1, effect: e }); l.current.effect = e; let u = e?.trigger ?? `onMount`, d = e?.target, f = e?.threshold; s(() => { if (!a || n) return; l.current.hasMounted = !0; function e() { let { effect: e } = l.current; if (!a || !e || e?.repeat !== !0 && l.current.hasAnimatedOnce || e?.type === `appear` && l.current.isAnimating) return; Object.assign(l.current, { hasAnimatedOnce: !0, isAnimating: !0 }); let t = e.type; switch (t) { case `appear`: { let { transition: t, startDelay: n, repeat: i, tokenization: a } = e, s = { current: void 0 }; return Fm(a, e.effect, r, t, n, i, o, () => { Object.assign(l.current, { isAnimating: !1 }) }, s), () => s.current?.() } default: V(t) } } switch (u) { case `onMount`: e(); return; case `onInView`: { let n = t?.current; return n ? Oe(n, e, { amount: f ?? 0 }) : void 0 } case `onScrollTarget`: { let t = d?.ref?.current; return t ? Oe(t, e, { amount: f ?? 0, root: document, margin: d?.offset ? `${d.offset}px 0px 0px 0px` : void 0 }) : void 0 } default: V(u) } }, [a, r, n, t, d, f, u]); let p = !!e, m = e ? Am(e) : void 0; return b(() => ({ getTokenizer: () => { if (r.clear(), !p) return; let { hasMounted: e, hasAnimatedOnce: t, effect: i } = l.current, s = Mm(a, n || Pm(e, t, i), l.current.effect, o); return { text: e => km(e, m, r, o, s), props: e => { if (i?.tokenization !== `element`) return; let t = Tm(); return r.add(t), { ref: t, style: { ...e, ...s } } } } }, play: () => { let { effect: e } = l.current; if (!e) return; let t = e.type; switch (t) { case `appear`: { let { transition: t, startDelay: n } = e; Fm(m, e.effect, r, t, n, !1, o); break } default: V(t) } } }), [a, p, r, n, m]) } function Pm(e, t, n) { return !(e && n?.trigger === `onMount` || t && !n?.repeat && (n?.trigger === `onInView` || n?.trigger === `onScrollTarget`)) } async function Fm(e = `character`, t, n, r, i = 0, a = !1, o, s, c) { let l = Om(t, o), u = new AbortController; switch (c && (c.current = () => u.abort()), e) { case `character`: case `element`: case `word`: { let e = await Im(n, u); if (e === null || (De(e, l, { ...r, restDelta: .001, delay: pe(r?.delay ?? 0, { startDelay: i }) }).then(() => s?.()), !a || !c)) return; c.current = () => { De(e, o ? { opacity: t.opacity } : t, { ...r, restDelta: .001, delay: pe(r?.delay ?? 0, { startDelay: i }) }) }; return } case `line`: { try { for (let e of n) await Em(e, u) } catch { return } let e; if (ke.read(() => { e = Lm(n), e.length !== 0 && ke.update(() => { let t = e.map((e, t) => De(e, l, { ...r, restDelta: .001, delay: i + t * (r?.delay ?? 0) })); Promise.all(t).then(() => s?.()) }) }), !a || !c) return; c.current = () => { if (e.length === 0) return; let n = o ? { opacity: t.opacity } : t; e.forEach((e, t) => { De(e, n, { ...r, restDelta: .001, delay: i + t * (r?.delay ?? 0) }) }) }; return } default: V(e) } } async function Im(e, t) { if (e.size === 0) return null; let n = []; for (let r of e) try { let e = await Em(r, t); e && n.push(e) } catch { return null } return n } function Lm(e) { let t = [], n = [], r = null; for (let i of e) { if (!i.current) continue; let e = i.current.offsetTop, a = i.current.offsetHeight; !a || r === null || e === r ? n.push(i.current) : (t.push(n), n = [i.current]), a && (r = e) } return t.push(n), t } function Rm(e) { return e.type === l } function zm(e) { return e.type === `br` } function Bm(e, t, n, r, i = {}, a, o = Rm(e) ? -1 : 0) { let s = k.toArray(e.props.children); $e(n) || (s = s.slice(0, 1)); let c = !0; s = s.map(e => { if ((!g(e) || !zm(e)) && (c = !1), g(e)) return Bm(e, t, n, r, i, a, o + 1); let s = $e(n) ? e : n; return L(s) && a ? a.text(s) : s }); let { "data-preset-tag": l, ...u } = e.props; if (L(e.type) || qe(e.type)) { let n = je(e.type) || e.type, d = l || n, f = L(d) ? t?.[d] : void 0; u.className = tc(`framer-text`, u.className, f), a && o === 0 && !c && Object.assign(u, a.props(u.style)); let p = n === `h1` || n === `h2` || n === `h3` || n === `h4` || n === `h5` || n === `h6`, h = t?.anchor; if (p && h) { let e = Vm(s, i); u.id = e; let t = tc(`framer-text`, h), n = m(`a`, { href: `#${e}`, className: t, children: s }); u.style = { ...u.style ?? {}, scrollMarginTop: r }, s = [n] } } return x(e, u, ...s) } function Vm(e, t) { let n = cr(e.map(Hm).join(``)), r = t[n] ?? 0; return r > 0 && (n += `-${r}`), t[n] = r + 1, n } function Hm(e) { return L(e) || R(e) ? e.toString() : g(e) ? Hm(e.props.children) : Array.isArray(e) ? e.map(Hm).join(``) : `` } function Um(e) { let t = e * Math.PI / 180, n = { x: -Math.sin(t) * 100, y: Math.cos(t) * 100 }, r = Jr(n.x, n.y), i = av(Jr(.5, .5), r), a = Y.points({ x: 0, y: 0, width: 1, height: 1 }), o = a.map(e => ({ point: e, distance: Jr.distance(r, e) })).sort((e, t) => e.distance - t.distance), s = o[0]?.point, c = o[1]?.point; B(s && c, `linearGradientLine: Must have 2 closest points.`); let [l, u] = a.filter(e => !Jr.isEqual(e, s) && !Jr.isEqual(e, c)); B(l && u, `linearGradientLine: Must have 2 opposing points.`); let d = av.intersection(i, av(s, c)), f = av.intersection(i, av(l, u)); return B(d && f, `linearGradientLine: Must have a start and end point.`), av(d, f) } function Wm(e, t) { let n = Um(e.angle), r = Po(e), i = r[0]?.position ?? 0, a = r[r.length - 1]?.position ?? 1, o = av.pointAtPercentDistance(n, i), s = av.pointAtPercentDistance(n, a), c = We([i, a], [0, 1]); return { id: `id${t}g${Tb.hash(e)}`, x1: o.x, y1: o.y, x2: s.x, y2: s.y, stops: r.map(t => ({ color: t.value, alpha: yb.getAlpha(t.value) * e.alpha, position: c(t.position) })) } } function Gm(e, t) { return { id: `id${t}g${Db.hash(e)}`, widthFactor: e.widthFactor, heightFactor: e.heightFactor, centerAnchorX: e.centerAnchorX, centerAnchorY: e.centerAnchorY, stops: Po(e).map(t => ({ color: t.value, alpha: yb.getAlpha(t.value) * e.alpha, position: t.position })) } } function Km(e) { if (!L(e) || e.charAt(e.length - 1) !== `%`) return !1; let t = e.slice(0, -1); return R(parseFloat(t)) } function qm(e) { let t = e.slice(0, -1), n = parseFloat(t); return R(n) ? n : 50 } function Jm(e) { return Km(e) ? qm(e) / 100 : e === `left` ? 0 : e === `right` ? 1 : .5 } function Ym(e) { return Km(e) ? qm(e) / 100 : e === `top` ? 0 : e === `bottom` ? 1 : .5 } function Xm(e, t, n, r) { if (e = O_.get(e, `#09F`), !sb.isImageObject(e) || !e.pixelWidth || !e.pixelHeight) return; let i = e.pixelWidth, a = e.pixelHeight, o, { fit: s } = e, c = 1, l = 1, u = 0, d = 0; if (s === `fill` || s === `fit` || s === `tile` || !s) { let n = 1, f = 1, p = i / a, m = t.height * p, h = t.width / p, g = m / t.width, _ = h / t.height; if (s === `tile`) { e.backgroundSize ??= 1, c = Math.round(e.backgroundSize * (i / 2)), l = Math.round(e.backgroundSize * (a / 2)); let n = t.x ?? 0, s = t.y ?? 0, f = 0, p = 0; r && (f = n, p = s), u = (t.width - c) * Jm(e.positionX) + f, d = (t.height - l) * Ym(e.positionY) + p, o = `translate(${u + n}, ${d + s})` } else (s === `fill` || !s ? _ > g : _ < g) ? (f = _, d = (1 - _) * Ym(e.positionY)) : (n = g, u = (1 - g) * Jm(e.positionX)), o = `translate(${u}, ${d}) scale(${n}, ${f})` } return { id: `id${n}g-fillImage`, path: e.src ?? ``, transform: o, width: c, height: l, offsetX: u, offsetY: d } } function Zm(e) { return e.startsWith(`data:${aD}`) } function Qm(e, t) { if (/^\w+:/u.test(e) && !Zm(e)) return e; t = typeof t == `number` ? t <= 512 ? 512 : t <= 1024 ? 1024 : t <= 2048 ? 2048 : 4096 : void 0; let n = J.current() === J.export; return eb.assetResolver(e, { pixelSize: t, isExport: n }) ?? `` } function $m(e) { try { let t = ym(e).getElementsByTagName(`svg`)[0]; if (!t) throw Error(`no svg element found`); return t } catch { return } } function eh(e, t) { nh(e, th(t)) } function th(e) { return e.replace(/[^\w\-:.]|^[^a-z]+/gi, ``) } function nh(e, t) { rh(e, t), Array.from(e.children).forEach(e => { nh(e, t) }) } function rh(e, t) { e.getAttributeNames().forEach(n => { let r = e.getAttribute(n); if (!r) return; if (n === `id` && e.setAttribute(n, `${t}_${r}`), n === `href` || n === `xlink:href`) { let [i, a] = r.split(`#`); if (i) return; e.setAttribute(n, `#${t}_${a}`); return } let i = `url(#`; if (r.includes(i)) { let a = r.replace(i, `${i}${t}_`); e.setAttribute(n, a) } }) } function ih(e) { if (!e) return; let t = /(-?[\d.]+)([a-z%]*)/u.exec(e); if (!(t?.[1] === void 0 || t?.[2] === void 0) && !t[2]?.startsWith(`%`)) return Math.round(parseFloat(t[1]) * (fD[t[2]] || 1)) } function ah(e) { let t = ih(e.getAttribute(`width`)), n = ih(e.getAttribute(`height`)); if (!(typeof t != `number` || typeof n != `number`) && !(t <= 0 || n <= 0)) return { width: t, height: n } } function oh(e) { return e.indexOf(`image`) >= 0 } function sh(e) { return e.indexOf(`var(--`) >= 0 } function ch(e) { return !!(e.borderRadius || e.borderBottomLeftRadius || e.borderBottomRightRadius || e.borderTopLeftRadius || e.borderTopRightRadius) } function lh(e, t) { let n = e.current; if (!n) return; let r = t.providedWindow ?? K, i = n.firstElementChild; if (!i || !(i instanceof r.SVGSVGElement)) return; if (!i.getAttribute(`viewBox`)) { let e = dD.getViewBox(t.svg); e && i.setAttribute(`viewBox`, e) } let { withExternalLayout: a, parentSize: o } = t; if (!a && Zi(t) && o !== 1 && o !== 2) return; let { intrinsicWidth: s, intrinsicHeight: c, _constraints: l } = t; i.viewBox?.baseVal?.width === 0 && i.viewBox?.baseVal?.height === 0 && H(s) && H(c) && i.setAttribute(`viewBox`, `0 0 ${s} ${c}`), l && l.aspectRatio ? i.setAttribute(`preserveAspectRatio`, ``) : i.setAttribute(`preserveAspectRatio`, `none`), i.setAttribute(`width`, `100%`), i.setAttribute(`height`, `100%`) } function uh(e) { return e > _D ? `lazy` : void 0 } function dh(e, t, n) { let r = hh(t); !n?.supportsExplicitInterCodegen && !r.some(e => e.explicitInter === !1) && r.push({ explicitInter: !1, fonts: [] }), Object.assign(e, { fonts: r }) } function fh(e) { return e ? e.fonts ?? Dr() : Dr() } function ph(e) { return e.length === 0 ? [{ explicitInter: !1, fonts: [] }] : hh(e) } function mh(e) { return e.length === 0 ? [{ explicitInter: !1, fonts: [] }] : hh(e) } function hh(e) { let t = { explicitInter: !1, fonts: [] }, n = []; for (let r of e) gh(r) ? n.push({ explicitInter: r.explicitInter, fonts: r.fonts.map(_h) }) : t.fonts.push(_h(r)); return t.fonts.length > 0 && n.push(t), n } function gh(e) { return vD in e } function _h(e) { let t = vh(e) || yh(e) ? e : bh(e); return yh(t) ? t : xh(t) } function vh(e) { return `source` in e } function yh(e) { return `cssFamilyName` in e } function bh(e) { let t; return t = e.url.startsWith(`https://fonts.gstatic.com/s/`) ? `google` : e.url.startsWith(`https://framerusercontent.com/third-party-assets/fontshare/`) ? `fontshare` : `custom`, { ...e, source: t } } function xh(e) { let { family: t, ...n } = e, r = e.variationAxes && e.source !== `custom` ? `${t} ${$T}` : t; return { ...n, uiFamilyName: t, cssFamilyName: r } } function Sh(e, t) { let n = `${e}-start`; performance.mark(n), t(); let r = `${e}-end`; performance.mark(r), performance.measure(e, n, r) } var Ch, wh, Th, Eh, Dh, Oh, kh, Ah, jh, Mh, Nh, Ph, Fh, Ih, Lh, Rh, zh, Bh, Vh, Hh, Uh, Wh, Gh, Kh, qh, Jh, Yh, Xh, Zh, Qh, $h, eg, tg, ng, rg, K, ig, ag, og, sg, cg, lg, ug, dg, fg, pg, mg, hg, gg, _g, vg, yg, bg, xg, Sg, Cg, wg, Tg, Eg, Dg, Og, kg, Ag, jg, Mg, Ng, Pg, Fg, Ig, Lg, Rg, zg, Bg, Vg, Hg, Ug, Wg, Gg, Kg, qg, Jg, Yg, Xg, Zg, Qg, $g, e_, t_, n_, r_, i_, a_, o_, s_, c_, l_, u_, d_, f_, p_, m_, h_, g_, __, v_, y_, b_, x_, S_, C_, w_, T_, E_, D_, O_, k_, A_, j_, M_, N_, P_, F_, I_, L_, R_, z_, B_, V_, q, H_, U_, W_, G_, K_, q_, J_, Y_, X_, Z_, J, Q_, $_, ev, tv, nv, rv, iv, av, Y, ov, sv, cv, lv, uv, dv, fv, pv, mv, hv, gv, _v, vv, yv, bv, xv, Sv, Cv, wv, Tv, Ev, Dv, Ov, kv, Av, jv, Mv, Nv, Pv, Fv, Iv, Lv, Rv, zv, X, Bv, Vv, Hv, Uv, Z, Wv, Gv, Kv, qv, Jv, Yv, Xv, Zv, Qv, $v, ey, ty, ny, ry, iy, ay, oy, sy, cy, ly, uy, dy, fy, py, my, hy, gy, _y, vy, yy, by, xy, Sy, Cy, wy, Ty, Ey, Dy, Oy, ky, Ay, jy, My, Ny, Py, Fy, Iy, Ly, Ry, zy, By, Vy, Hy, Uy, Wy, Gy, Ky, qy, Jy, Yy, Xy, Zy, Qy, $y, eb, tb, nb, rb, ib, ab, ob, sb, cb, lb, ub, db, fb, pb, mb, hb, gb, _b, vb, yb, bb, xb, Sb, Cb, wb, Tb, Eb, Db, Ob, kb, Ab, jb, Mb, Nb, Pb, Fb, Ib, Lb, Rb, zb, Bb, Vb, Hb, Ub, Wb, Gb, Kb, qb, Jb, Yb, Xb, Zb, Qb, $b, ex, tx, nx, rx, ix, ax, ox, sx, cx, lx, ux, dx, fx, px, mx, hx, gx, _x, vx, yx, bx, xx, Sx, Cx, wx, Tx, Ex, Dx, Ox, kx, Ax, jx, Mx, Nx, Px, Fx, Ix, Lx, Rx, zx, Bx, Vx, Hx, Ux, Wx, Gx, Kx, qx, Jx, Yx, Xx, Zx, Qx, $x, eS, tS, nS, rS, iS, aS, oS, sS, cS, lS, uS, dS, fS, pS, mS, hS, gS, _S, vS, yS, bS, xS, SS, CS, wS, TS, ES, DS, OS, kS, AS, jS, MS, NS, PS, FS, IS, LS, RS, zS, BS, VS, HS, US, WS, GS, KS, qS, JS, YS, XS, ZS, QS, $S, eC, tC, nC, rC, iC, aC, oC, sC, cC, lC, uC, dC, fC, pC, mC, hC, gC, _C, vC, yC, bC, xC, SC, CC, wC, TC, EC, DC, OC, kC, AC, jC, MC, NC, PC, FC, IC, LC, RC, zC, BC, VC, HC, UC, WC, GC, KC, qC, JC, YC, XC, ZC, QC, $C, ew, tw, nw, rw, iw, aw, ow, sw, cw, lw, uw, dw, Q, fw, pw, mw, hw, gw, _w, vw, yw, bw, xw, Sw, $, Cw, ww, Tw, Ew, Dw, Ow, kw, Aw, jw, Mw, Nw, Pw, Fw, Iw, Lw, Rw, zw, Bw, Vw, Hw, Uw, Ww, Gw, Kw, qw, Jw, Yw, Xw, Zw, Qw, $w, eT, tT, nT, rT, iT, aT, oT, sT, cT, lT, uT, dT, fT, pT, mT, hT, gT, _T, vT, yT, bT, xT, ST, CT, wT, TT, ET, DT, OT, kT, AT, jT, MT, NT, PT, FT, IT, LT, RT, zT, BT, VT, HT, UT, WT, GT, KT, qT, JT, YT, XT, ZT, QT, $T, eE, tE, nE, rE, iE, aE, oE, sE, cE, lE, uE, dE, fE, pE, mE, hE, gE, _E, vE, yE, bE, xE, SE, CE, wE, TE, EE, DE, OE, kE, AE, jE, ME, NE, PE, FE, IE, LE, RE, zE, BE, VE, HE, UE, WE, GE, KE, qE, JE, YE, XE, ZE, QE, $E, eD, tD, nD, rD, iD, aD, oD, sD, cD, lD, uD, dD, fD, pD, mD, hD, gD, _D, vD, yD = e((() => {
    u(
        //! Credit to Astro | MIT License
        /**
        * @license Emotion v11.0.0
        * MIT License
        *
        * Copyright (c) Emotion team and other contributors
        *
        * Permission is hereby granted, free of charge, to any person obtaining a copy
        * of this software and associated documentation files (the "Software"), to deal
        * in the Software without restriction, including without limitation the rights
        * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
        * copies of the Software, and to permit persons to whom the Software is
        * furnished to do so, subject to the following conditions:
        *
        * The above copyright notice and this permission notice shall be included in all
        * copies or substantial portions of the Software.
        *
        * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
        * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
        * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
        * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
        * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
        * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
        * SOFTWARE.
        */
        /*! Bundled license information:
        
        react-is/cjs/react-is.production.min.js:
        (** @license React v16.13.1
        * react-is.production.min.js
        *
        * Copyright (c) Facebook, Inc. and its affiliates.
        *
        * This source code is licensed under the MIT license found in the
        * LICENSE file in the root directory of this source tree.
        *)
        */
    ), I(), Ie(), r(), w(), f(), Ch = oe({ "../../../node_modules/hsluv/dist/hsluv.cjs"(e) { Object.defineProperty(e, `__esModule`, { value: !0 }), e.Hsluv = void 0; var t = class e { constructor() { this.hex = `#000000`, this.rgb_r = 0, this.rgb_g = 0, this.rgb_b = 0, this.xyz_x = 0, this.xyz_y = 0, this.xyz_z = 0, this.luv_l = 0, this.luv_u = 0, this.luv_v = 0, this.lch_l = 0, this.lch_c = 0, this.lch_h = 0, this.hsluv_h = 0, this.hsluv_s = 0, this.hsluv_l = 0, this.hpluv_h = 0, this.hpluv_p = 0, this.hpluv_l = 0, this.r0s = 0, this.r0i = 0, this.r1s = 0, this.r1i = 0, this.g0s = 0, this.g0i = 0, this.g1s = 0, this.g1i = 0, this.b0s = 0, this.b0i = 0, this.b1s = 0, this.b1i = 0 } static fromLinear(e) { return e <= .0031308 ? 12.92 * e : 1.055 * e ** (1 / 2.4) - .055 } static toLinear(e) { return e > .04045 ? ((e + .055) / 1.055) ** 2.4 : e / 12.92 } static yToL(t) { return t <= e.epsilon ? t / e.refY * e.kappa : 116 * (t / e.refY) ** (1 / 3) - 16 } static lToY(t) { return t <= 8 ? e.refY * t / e.kappa : e.refY * ((t + 16) / 116) ** 3 } static rgbChannelToHex(t) { let n = Math.round(t * 255), r = n % 16, i = (n - r) / 16 | 0; return e.hexChars.charAt(i) + e.hexChars.charAt(r) } static hexToRgbChannel(t, n) { let r = e.hexChars.indexOf(t.charAt(n)), i = e.hexChars.indexOf(t.charAt(n + 1)); return (r * 16 + i) / 255 } static distanceFromOriginAngle(e, t, n) { let r = t / (Math.sin(n) - e * Math.cos(n)); return r < 0 ? 1 / 0 : r } static distanceFromOrigin(e, t) { return Math.abs(t) / Math.sqrt(e ** 2 + 1) } static min6(e, t, n, r, i, a) { return Math.min(e, Math.min(t, Math.min(n, Math.min(r, Math.min(i, a))))) } rgbToHex() { this.hex = `#`, this.hex += e.rgbChannelToHex(this.rgb_r), this.hex += e.rgbChannelToHex(this.rgb_g), this.hex += e.rgbChannelToHex(this.rgb_b) } hexToRgb() { this.hex = this.hex.toLowerCase(), this.rgb_r = e.hexToRgbChannel(this.hex, 1), this.rgb_g = e.hexToRgbChannel(this.hex, 3), this.rgb_b = e.hexToRgbChannel(this.hex, 5) } xyzToRgb() { this.rgb_r = e.fromLinear(e.m_r0 * this.xyz_x + e.m_r1 * this.xyz_y + e.m_r2 * this.xyz_z), this.rgb_g = e.fromLinear(e.m_g0 * this.xyz_x + e.m_g1 * this.xyz_y + e.m_g2 * this.xyz_z), this.rgb_b = e.fromLinear(e.m_b0 * this.xyz_x + e.m_b1 * this.xyz_y + e.m_b2 * this.xyz_z) } rgbToXyz() { let t = e.toLinear(this.rgb_r), n = e.toLinear(this.rgb_g), r = e.toLinear(this.rgb_b); this.xyz_x = .41239079926595 * t + .35758433938387 * n + .18048078840183 * r, this.xyz_y = .21263900587151 * t + .71516867876775 * n + .072192315360733 * r, this.xyz_z = .019330818715591 * t + .11919477979462 * n + .95053215224966 * r } xyzToLuv() { let t = this.xyz_x + 15 * this.xyz_y + 3 * this.xyz_z, n = 4 * this.xyz_x, r = 9 * this.xyz_y; t === 0 ? (n = NaN, r = NaN) : (n /= t, r /= t), this.luv_l = e.yToL(this.xyz_y), this.luv_l === 0 ? (this.luv_u = 0, this.luv_v = 0) : (this.luv_u = 13 * this.luv_l * (n - e.refU), this.luv_v = 13 * this.luv_l * (r - e.refV)) } luvToXyz() { if (this.luv_l === 0) { this.xyz_x = 0, this.xyz_y = 0, this.xyz_z = 0; return } let t = this.luv_u / (13 * this.luv_l) + e.refU, n = this.luv_v / (13 * this.luv_l) + e.refV; this.xyz_y = e.lToY(this.luv_l), this.xyz_x = 0 - 9 * this.xyz_y * t / ((t - 4) * n - t * n), this.xyz_z = (9 * this.xyz_y - 15 * n * this.xyz_y - n * this.xyz_x) / (3 * n) } luvToLch() { this.lch_l = this.luv_l, this.lch_c = Math.sqrt(this.luv_u * this.luv_u + this.luv_v * this.luv_v), this.lch_c < 1e-8 ? this.lch_h = 0 : (this.lch_h = Math.atan2(this.luv_v, this.luv_u) * 180 / Math.PI, this.lch_h < 0 && (this.lch_h = 360 + this.lch_h)) } lchToLuv() { let e = this.lch_h / 180 * Math.PI; this.luv_l = this.lch_l, this.luv_u = Math.cos(e) * this.lch_c, this.luv_v = Math.sin(e) * this.lch_c } calculateBoundingLines(t) { let n = (t + 16) ** 3 / 1560896, r = n > e.epsilon ? n : t / e.kappa, i = r * (284517 * e.m_r0 - 94839 * e.m_r2), a = r * (838422 * e.m_r2 + 769860 * e.m_r1 + 731718 * e.m_r0), o = r * (632260 * e.m_r2 - 126452 * e.m_r1), s = r * (284517 * e.m_g0 - 94839 * e.m_g2), c = r * (838422 * e.m_g2 + 769860 * e.m_g1 + 731718 * e.m_g0), l = r * (632260 * e.m_g2 - 126452 * e.m_g1), u = r * (284517 * e.m_b0 - 94839 * e.m_b2), d = r * (838422 * e.m_b2 + 769860 * e.m_b1 + 731718 * e.m_b0), f = r * (632260 * e.m_b2 - 126452 * e.m_b1); this.r0s = i / o, this.r0i = a * t / o, this.r1s = i / (o + 126452), this.r1i = (a - 769860) * t / (o + 126452), this.g0s = s / l, this.g0i = c * t / l, this.g1s = s / (l + 126452), this.g1i = (c - 769860) * t / (l + 126452), this.b0s = u / f, this.b0i = d * t / f, this.b1s = u / (f + 126452), this.b1i = (d - 769860) * t / (f + 126452) } calcMaxChromaHpluv() { let t = e.distanceFromOrigin(this.r0s, this.r0i), n = e.distanceFromOrigin(this.r1s, this.r1i), r = e.distanceFromOrigin(this.g0s, this.g0i), i = e.distanceFromOrigin(this.g1s, this.g1i), a = e.distanceFromOrigin(this.b0s, this.b0i), o = e.distanceFromOrigin(this.b1s, this.b1i); return e.min6(t, n, r, i, a, o) } calcMaxChromaHsluv(t) { let n = t / 360 * Math.PI * 2, r = e.distanceFromOriginAngle(this.r0s, this.r0i, n), i = e.distanceFromOriginAngle(this.r1s, this.r1i, n), a = e.distanceFromOriginAngle(this.g0s, this.g0i, n), o = e.distanceFromOriginAngle(this.g1s, this.g1i, n), s = e.distanceFromOriginAngle(this.b0s, this.b0i, n), c = e.distanceFromOriginAngle(this.b1s, this.b1i, n); return e.min6(r, i, a, o, s, c) } hsluvToLch() { this.hsluv_l > 99.9999999 ? (this.lch_l = 100, this.lch_c = 0) : this.hsluv_l < 1e-8 ? (this.lch_l = 0, this.lch_c = 0) : (this.lch_l = this.hsluv_l, this.calculateBoundingLines(this.hsluv_l), this.lch_c = this.calcMaxChromaHsluv(this.hsluv_h) / 100 * this.hsluv_s), this.lch_h = this.hsluv_h } lchToHsluv() { if (this.lch_l > 99.9999999) this.hsluv_s = 0, this.hsluv_l = 100; else if (this.lch_l < 1e-8) this.hsluv_s = 0, this.hsluv_l = 0; else { this.calculateBoundingLines(this.lch_l); let e = this.calcMaxChromaHsluv(this.lch_h); this.hsluv_s = this.lch_c / e * 100, this.hsluv_l = this.lch_l } this.hsluv_h = this.lch_h } hpluvToLch() { this.hpluv_l > 99.9999999 ? (this.lch_l = 100, this.lch_c = 0) : this.hpluv_l < 1e-8 ? (this.lch_l = 0, this.lch_c = 0) : (this.lch_l = this.hpluv_l, this.calculateBoundingLines(this.hpluv_l), this.lch_c = this.calcMaxChromaHpluv() / 100 * this.hpluv_p), this.lch_h = this.hpluv_h } lchToHpluv() { if (this.lch_l > 99.9999999) this.hpluv_p = 0, this.hpluv_l = 100; else if (this.lch_l < 1e-8) this.hpluv_p = 0, this.hpluv_l = 0; else { this.calculateBoundingLines(this.lch_l); let e = this.calcMaxChromaHpluv(); this.hpluv_p = this.lch_c / e * 100, this.hpluv_l = this.lch_l } this.hpluv_h = this.lch_h } hsluvToRgb() { this.hsluvToLch(), this.lchToLuv(), this.luvToXyz(), this.xyzToRgb() } hpluvToRgb() { this.hpluvToLch(), this.lchToLuv(), this.luvToXyz(), this.xyzToRgb() } hsluvToHex() { this.hsluvToRgb(), this.rgbToHex() } hpluvToHex() { this.hpluvToRgb(), this.rgbToHex() } rgbToHsluv() { this.rgbToXyz(), this.xyzToLuv(), this.luvToLch(), this.lchToHpluv(), this.lchToHsluv() } rgbToHpluv() { this.rgbToXyz(), this.xyzToLuv(), this.luvToLch(), this.lchToHpluv(), this.lchToHpluv() } hexToHsluv() { this.hexToRgb(), this.rgbToHsluv() } hexToHpluv() { this.hexToRgb(), this.rgbToHpluv() } }; e.Hsluv = t, t.hexChars = `0123456789abcdef`, t.refY = 1, t.refU = .19783000664283, t.refV = .46831999493879, t.kappa = 903.2962962, t.epsilon = .0088564516, t.m_r0 = 3.240969941904521, t.m_r1 = -1.537383177570093, t.m_r2 = -.498610760293, t.m_g0 = -.96924363628087, t.m_g1 = 1.87596750150772, t.m_g2 = .041555057407175, t.m_b0 = .055630079696993, t.m_b1 = -.20397695888897, t.m_b2 = 1.056971514242878 } }), wh = oe({ "../../../node_modules/eventemitter3/index.js"(e, t) { var n = Object.prototype.hasOwnProperty, r = `~`; function i() { } Object.create && (i.prototype = Object.create(null), new i().__proto__ || (r = !1)); function a(e, t, n) { this.fn = e, this.context = t, this.once = n || !1 } function o(e, t, n, i, o) { if (typeof n != `function`) throw TypeError(`The listener must be a function`); var s = new a(n, i || e, o), c = r ? r + t : t; return e._events[c] ? e._events[c].fn ? e._events[c] = [e._events[c], s] : e._events[c].push(s) : (e._events[c] = s, e._eventsCount++), e } function s(e, t) { --e._eventsCount === 0 ? e._events = new i : delete e._events[t] } function c() { this._events = new i, this._eventsCount = 0 } c.prototype.eventNames = function () { var e = [], t, i; if (this._eventsCount === 0) return e; for (i in t = this._events) n.call(t, i) && e.push(r ? i.slice(1) : i); return Object.getOwnPropertySymbols ? e.concat(Object.getOwnPropertySymbols(t)) : e }, c.prototype.listeners = function (e) { var t = r ? r + e : e, n = this._events[t]; if (!n) return []; if (n.fn) return [n.fn]; for (var i = 0, a = n.length, o = Array(a); i < a; i++)o[i] = n[i].fn; return o }, c.prototype.listenerCount = function (e) { var t = r ? r + e : e, n = this._events[t]; return n ? n.fn ? 1 : n.length : 0 }, c.prototype.emit = function (e, t, n, i, a, o) { var s = r ? r + e : e; if (!this._events[s]) return !1; var c = this._events[s], l = arguments.length, u, d; if (c.fn) { switch (c.once && this.removeListener(e, c.fn, void 0, !0), l) { case 1: return c.fn.call(c.context), !0; case 2: return c.fn.call(c.context, t), !0; case 3: return c.fn.call(c.context, t, n), !0; case 4: return c.fn.call(c.context, t, n, i), !0; case 5: return c.fn.call(c.context, t, n, i, a), !0; case 6: return c.fn.call(c.context, t, n, i, a, o), !0 }for (d = 1, u = Array(l - 1); d < l; d++)u[d - 1] = arguments[d]; c.fn.apply(c.context, u) } else { var f = c.length, p; for (d = 0; d < f; d++)switch (c[d].once && this.removeListener(e, c[d].fn, void 0, !0), l) { case 1: c[d].fn.call(c[d].context); break; case 2: c[d].fn.call(c[d].context, t); break; case 3: c[d].fn.call(c[d].context, t, n); break; case 4: c[d].fn.call(c[d].context, t, n, i); break; default: if (!u) for (p = 1, u = Array(l - 1); p < l; p++)u[p - 1] = arguments[p]; c[d].fn.apply(c[d].context, u) } } return !0 }, c.prototype.on = function (e, t, n) { return o(this, e, t, n, !1) }, c.prototype.once = function (e, t, n) { return o(this, e, t, n, !0) }, c.prototype.removeListener = function (e, t, n, i) { var a = r ? r + e : e; if (!this._events[a]) return this; if (!t) return s(this, a), this; var o = this._events[a]; if (o.fn) o.fn === t && (!i || o.once) && (!n || o.context === n) && s(this, a); else { for (var c = 0, l = [], u = o.length; c < u; c++)(o[c].fn !== t || i && !o[c].once || n && o[c].context !== n) && l.push(o[c]); l.length ? this._events[a] = l.length === 1 ? l[0] : l : s(this, a) } return this }, c.prototype.removeAllListeners = function (e) { var t; return e ? (t = r ? r + e : e, this._events[t] && s(this, t)) : (this._events = new i, this._eventsCount = 0), this }, c.prototype.off = c.prototype.removeListener, c.prototype.addListener = c.prototype.on, c.prefixed = r, c.EventEmitter = c, t !== void 0 && (t.exports = c) } }), Th = oe({ "../../../node_modules/hoist-non-react-statics/node_modules/react-is/cjs/react-is.production.min.js"(e) { var t = typeof Symbol == `function` && Symbol.for, n = t ? Symbol.for(`react.element`) : 60103, r = t ? Symbol.for(`react.portal`) : 60106, i = t ? Symbol.for(`react.fragment`) : 60107, a = t ? Symbol.for(`react.strict_mode`) : 60108, o = t ? Symbol.for(`react.profiler`) : 60114, s = t ? Symbol.for(`react.provider`) : 60109, c = t ? Symbol.for(`react.context`) : 60110, l = t ? Symbol.for(`react.async_mode`) : 60111, u = t ? Symbol.for(`react.concurrent_mode`) : 60111, d = t ? Symbol.for(`react.forward_ref`) : 60112, f = t ? Symbol.for(`react.suspense`) : 60113, p = t ? Symbol.for(`react.suspense_list`) : 60120, m = t ? Symbol.for(`react.memo`) : 60115, h = t ? Symbol.for(`react.lazy`) : 60116, g = t ? Symbol.for(`react.block`) : 60121, _ = t ? Symbol.for(`react.fundamental`) : 60117, v = t ? Symbol.for(`react.responder`) : 60118, y = t ? Symbol.for(`react.scope`) : 60119; function b(e) { if (typeof e == `object` && e) { var t = e.$$typeof; switch (t) { case n: switch (e = e.type, e) { case l: case u: case i: case o: case a: case f: return e; default: switch (e &&= e.$$typeof, e) { case c: case d: case h: case m: case s: return e; default: return t } }case r: return t } } } function x(e) { return b(e) === u } e.AsyncMode = l, e.ConcurrentMode = u, e.ContextConsumer = c, e.ContextProvider = s, e.Element = n, e.ForwardRef = d, e.Fragment = i, e.Lazy = h, e.Memo = m, e.Portal = r, e.Profiler = o, e.StrictMode = a, e.Suspense = f, e.isAsyncMode = function (e) { return x(e) || b(e) === l }, e.isConcurrentMode = x, e.isContextConsumer = function (e) { return b(e) === c }, e.isContextProvider = function (e) { return b(e) === s }, e.isElement = function (e) { return typeof e == `object` && !!e && e.$$typeof === n }, e.isForwardRef = function (e) { return b(e) === d }, e.isFragment = function (e) { return b(e) === i }, e.isLazy = function (e) { return b(e) === h }, e.isMemo = function (e) { return b(e) === m }, e.isPortal = function (e) { return b(e) === r }, e.isProfiler = function (e) { return b(e) === o }, e.isStrictMode = function (e) { return b(e) === a }, e.isSuspense = function (e) { return b(e) === f }, e.isValidElementType = function (e) { return typeof e == `string` || typeof e == `function` || e === i || e === u || e === o || e === a || e === f || e === p || typeof e == `object` && !!e && (e.$$typeof === h || e.$$typeof === m || e.$$typeof === s || e.$$typeof === c || e.$$typeof === d || e.$$typeof === _ || e.$$typeof === v || e.$$typeof === y || e.$$typeof === g) }, e.typeOf = b } }), Eh = oe({ "../../../node_modules/hoist-non-react-statics/node_modules/react-is/index.js"(e, t) { t.exports = Th() } }), Dh = oe({ "../../../node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js"(e, t) { var n = Eh(), r = { childContextTypes: !0, contextType: !0, contextTypes: !0, defaultProps: !0, displayName: !0, getDefaultProps: !0, getDerivedStateFromError: !0, getDerivedStateFromProps: !0, mixins: !0, propTypes: !0, type: !0 }, i = { name: !0, length: !0, prototype: !0, caller: !0, callee: !0, arguments: !0, arity: !0 }, a = { $$typeof: !0, render: !0, defaultProps: !0, displayName: !0, propTypes: !0 }, o = { $$typeof: !0, compare: !0, defaultProps: !0, displayName: !0, propTypes: !0, type: !0 }, s = {}; s[n.ForwardRef] = a, s[n.Memo] = o; function c(e) { return n.isMemo(e) ? o : s[e.$$typeof] || r } var l = Object.defineProperty, u = Object.getOwnPropertyNames, d = Object.getOwnPropertySymbols, f = Object.getOwnPropertyDescriptor, p = Object.getPrototypeOf, m = Object.prototype; function h(e, t, n) { if (typeof t != `string`) { if (m) { var r = p(t); r && r !== m && h(e, r, n) } var a = u(t); d && (a = a.concat(d(t))); for (var o = c(e), s = c(t), g = 0; g < a.length; ++g) { var _ = a[g]; if (!i[_] && !(n && n[_]) && !(s && s[_]) && !(o && o[_])) { var v = f(t, _); try { l(e, _, v) } catch { } } } } return e } t.exports = h } }), Oh = oe({ "../../../node_modules/fontfaceobserver/fontfaceobserver.standalone.js"(e, t) { (function () { function e(e, t) { document.addEventListener ? e.addEventListener(`scroll`, t, !1) : e.attachEvent(`scroll`, t) } function r(e) { document.body ? e() : document.addEventListener ? document.addEventListener(`DOMContentLoaded`, function t() { document.removeEventListener(`DOMContentLoaded`, t), e() }) : document.attachEvent(`onreadystatechange`, function t() { (document.readyState == `interactive` || document.readyState == `complete`) && (document.detachEvent(`onreadystatechange`, t), e()) }) } function i(e) { this.g = document.createElement(`div`), this.g.setAttribute(`aria-hidden`, `true`), this.g.appendChild(document.createTextNode(e)), this.h = document.createElement(`span`), this.i = document.createElement(`span`), this.m = document.createElement(`span`), this.j = document.createElement(`span`), this.l = -1, this.h.style.cssText = `max-width:none;display:inline-block;position:absolute;height:100%;width:100%;overflow:scroll;font-size:16px;`, this.i.style.cssText = `max-width:none;display:inline-block;position:absolute;height:100%;width:100%;overflow:scroll;font-size:16px;`, this.j.style.cssText = `max-width:none;display:inline-block;position:absolute;height:100%;width:100%;overflow:scroll;font-size:16px;`, this.m.style.cssText = `display:inline-block;width:200%;height:200%;font-size:16px;max-width:none;`, this.h.appendChild(this.m), this.i.appendChild(this.j), this.g.appendChild(this.h), this.g.appendChild(this.i) } function a(e, t) { e.g.style.cssText = `max-width:none;min-width:20px;min-height:20px;display:inline-block;overflow:hidden;position:absolute;width:auto;margin:0;padding:0;top:-999px;white-space:nowrap;font-synthesis:none;font:` + t + `;` } function o(e) { var t = e.g.offsetWidth, n = t + 100; return e.j.style.width = n + `px`, e.i.scrollLeft = n, e.h.scrollLeft = e.h.scrollWidth + 100, e.l === t ? !1 : (e.l = t, !0) } function s(t, n) { function r() { var e = i; o(e) && e.g.parentNode !== null && n(e.l) } var i = t; e(t.h, r), e(t.i, r), o(t) } function c(e, t, r) { t ||= {}, r ||= n, this.family = e, this.style = t.style || `normal`, this.weight = t.weight || `normal`, this.stretch = t.stretch || `normal`, this.context = r } var l = null, u = null, d = null, f = null; function p(e) { return u === null && (m(e) && /Apple/.test(n.navigator.vendor) ? (e = /AppleWebKit\/([0-9]+)(?:\.([0-9]+))(?:\.([0-9]+))/.exec(n.navigator.userAgent), u = !!e && 603 > parseInt(e[1], 10)) : u = !1), u } function m(e) { return f === null && (f = !!e.document.fonts), f } function h(e, t) { var n = e.style, r = e.weight; if (d === null) { var i = document.createElement(`div`); try { i.style.font = `condensed 100px sans-serif` } catch { } d = i.style.font !== `` } return [n, r, d ? e.stretch : ``, `100px`, t].join(` `) } c.prototype.load = function (e, t) { var o = this, c = e || `BESbswy`, u = 0, d = t || 3e3, f = new Date().getTime(); return new Promise(function (e, t) { if (m(o.context) && !p(o.context)) { var g = new Promise(function (e, t) { function n() { new Date().getTime() - f >= d ? t(Error(`` + d + `ms timeout exceeded`)) : o.context.document.fonts.load(h(o, `"` + o.family + `"`), c).then(function (t) { 1 <= t.length ? e() : setTimeout(n, 25) }, t) } n() }), _ = new Promise(function (e, t) { u = setTimeout(function () { t(Error(`` + d + `ms timeout exceeded`)) }, d) }); Promise.race([_, g]).then(function () { clearTimeout(u), e(o) }, t) } else r(function () { function r() { var t; (t = v != -1 && y != -1 || v != -1 && b != -1 || y != -1 && b != -1) && ((t = v != y && v != b && y != b) || (l === null && (t = /AppleWebKit\/([0-9]+)(?:\.([0-9]+))/.exec(n.navigator.userAgent), l = !!t && (536 > parseInt(t[1], 10) || parseInt(t[1], 10) === 536 && 11 >= parseInt(t[2], 10))), t = l && (v == x && y == x && b == x || v == S && y == S && b == S || v == C && y == C && b == C)), t = !t), t && (w.parentNode !== null && w.parentNode.removeChild(w), clearTimeout(u), e(o)) } function p() { if (new Date().getTime() - f >= d) w.parentNode !== null && w.parentNode.removeChild(w), t(Error(`` + d + `ms timeout exceeded`)); else { var e = o.context.document.hidden; (!0 === e || e === void 0) && (v = m.g.offsetWidth, y = g.g.offsetWidth, b = _.g.offsetWidth, r()), u = setTimeout(p, 50) } } var m = new i(c), g = new i(c), _ = new i(c), v = -1, y = -1, b = -1, x = -1, S = -1, C = -1, w = document.createElement(`div`); w.dir = `ltr`, a(m, h(o, `sans-serif`)), a(g, h(o, `serif`)), a(_, h(o, `monospace`)), w.appendChild(m.g), w.appendChild(g.g), w.appendChild(_.g), o.context.document.body.appendChild(w), x = m.g.offsetWidth, S = g.g.offsetWidth, C = _.g.offsetWidth, p(), s(m, function (e) { v = e, r() }), a(m, h(o, `"` + o.family + `",sans-serif`)), s(g, function (e) { y = e, r() }), a(g, h(o, `"` + o.family + `",serif`)), s(_, function (e) { b = e, r() }), a(_, h(o, `"` + o.family + `",monospace`)) }) }) }, typeof t == `object` ? t.exports = c : (n.FontFaceObserver = c, n.FontFaceObserver.prototype.load = c.prototype.load) })() } }), kh = () => { }, Ah = n !== void 0, jh = (() => Ah && (j.webdriver || /bot|-google|google-|yandex|ia_archiver|crawl|spider/iu.test(j.userAgent)))(), Mh = Ah && typeof n.requestIdleCallback == `function`, Nh = (() => Mh ? n.requestIdleCallback : setTimeout)(), Ph = new Map, Fh = Ah ? void 0 : new Set, Ih = `preload`, Lh = Object.keys, Rh = `equals`, zh = (() => p.createContext({}))(), Bh = (() => p.createContext({}))(), Vh = [], Hh = p.createContext(void 0), Hh.displayName = `LibraryFeaturesContext`, Uh = (() => Hh.Provider)(), Wh = () => p.useContext(Hh) ?? {}, Gh = `default`, Kh = { Pending: `pending`, Fulfilled: `fulfilled`, Rejected: `rejected` }, qh = class e { constructor(e, t) { this.resolver = e, this.cacheHash = t, M(this, `promiseState`, Kh.Pending), M(this, `preloadPromise`), M(this, `value`), M(this, `reason`), M(this, `read`, () => { if (this.promiseState === Kh.Fulfilled) return this.value; throw this.promiseState === Kh.Rejected ? this.reason : Error(`Need to call preload() before read()`) }) } static is(t) { return t instanceof e } get status() { return this.preload(), this.state } get state() { return this.promiseState } then(e, t) { return this.promiseState === Kh.Fulfilled ? Promise.resolve(this.value).then(e, t) : this.promiseState === Kh.Rejected ? Promise.reject(this.reason).then(e, t) : this.readAsync().then(e, t) } preload() { if (this.promiseState !== Kh.Pending) return; if (this.preloadPromise) return this.preloadPromise; this.cacheHash !== void 0 && Fh !== void 0 && Fh.add(this.cacheHash); let e = e => { this.promiseState = Kh.Fulfilled, this.value = e }, t = e => { this.promiseState = Kh.Rejected, this.reason = e }, n; try { n = this.cacheHash && Ph.has(this.cacheHash) ? Ph.get(this.cacheHash) : this.resolver() } catch (e) { t(e); return } if (!at(n)) { e(n); return } let r = n.then(e, t); return this.preloadPromise = r, r } async readAsync() { return this.readMaybeAsync() } readMaybeAsync() { let e = this.preload(); return e ? e.then(this.read) : this.read() } use() { let e = this.preload(); if (e) throw e; return this.read() } }, Jh = class extends Error { constructor(e, t, n, r) { super(e), this.name = `DevalueError`, this.path = t.join(``), this.value = n, this.root = r } }, Yh = Object.getOwnPropertyNames(Object.prototype).sort().join(`\0`), Xh = /^[a-zA-Z_$][a-zA-Z_$0-9]*$/, Zh = `ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/`, Qh = -1, $h = -2, eg = -3, tg = -4, ng = -5, rg = -6, K = Ah ? n : { addEventListener: () => { }, removeEventListener: () => { }, dispatchEvent: () => !1, ResizeObserver: void 0, onpointerdown: !1, onpointermove: !1, onpointerup: !1, ontouchstart: !1, ontouchmove: !1, ontouchend: !1, onmousedown: !1, onmousemove: !1, onmouseup: !1, devicePixelRatio: 1, scrollX: 0, scrollY: 0, location: { hash: ``, hostname: ``, href: ``, origin: ``, pathname: ``, search: `` }, document: { baseURI: ``, cookie: ``, referrer: null }, setTimeout: () => 0, clearTimeout: () => { }, setInterval: () => 0, clearInterval: () => { }, requestAnimationFrame: () => 0, cancelAnimationFrame: () => { }, requestIdleCallback: () => 0, getSelection: () => null, matchMedia: e => ({ matches: !1, media: e, onchange: () => { }, addEventListener: () => { }, removeEventListener: () => { }, addListener: () => { }, removeListener: () => { }, dispatchEvent: () => !1 }), innerHeight: 0, innerWidth: 0, SVGSVGElement: {}, scheduler: void 0, open: function (e, t, n) { }, __framer_events: [] }, ig = 2, ag = /^[a-z0-9]+(?:-[a-z0-9]+)*$/u, og = { QueryCache: 0, CollectionUtilsCache: 1 }, cg = class { constructor() { M(this, `payload`, $t()), M(this, `isEmpty`, !0) } set(e, t, n) { this.payload[e].set(t, n), this.isEmpty = !1 } has(e, t) { return this.payload[e].has(t) } get(e, t) { return this.payload[e].get(t) } toString() { if (!this.isEmpty) try { return Yt(this.payload) } catch (e) { console.error(`Failed to serialize handover data.`, e); return } } clear() { for (let e of Object.values(this.payload)) e.clear(); this.isEmpty = !0 } }, lg = (() => Ah ? void 0 : new cg)(), ug = (() => og.CollectionUtilsCache)(), dg = new WeakMap, fg = a(void 0), pg = class { constructor(e, t) { this.collectionId = t, M(this, `module`), M(this, `cacheMap`, new Map), this.module = new qh(async () => { try { let t = await e(); return B(t, `Couldn't find CollectionUtils`), t } catch (e) { console.error(st(`Failed to import collection module.`, e)); return } }) } callUtilsMethod(e, t, n) { let r = an(n), i = on(e, this.collectionId, r, t); if (this.cacheMap.has(i)) { let e = this.cacheMap.get(i)?.readMaybeAsync(); if (lg !== void 0) { if (at(e)) return e.then(e => (lg.set(ug, i, e), e)); lg.set(ug, i, e) } return e } if (nn(ug, i)) { let e = rn(ug, i); return this.cacheMap.set(i, new qh(() => e)), e } let a = this.module.readMaybeAsync(), o = at(a), s; try { s = o ? a.then(r => r?.[e](t, n)) : a?.[e](t, n) } catch (e) { console.error(st(`Failed to call CollectionUtils method.`, e)), s = void 0 } if (s === void 0) { lg !== void 0 && lg.set(ug, i, s), this.cacheMap.set(i, s); return } let c = new qh(() => s.then(e => (lg !== void 0 && lg.set(ug, i, e), e)).catch(e => { console.error(st(`Failed to call CollectionUtils method.`, e)) })); return this.cacheMap.set(i, c), c.readMaybeAsync() } getSlugByRecordId(e, t) { return this.callUtilsMethod(`getSlugByRecordId`, e, t) } getRecordIdBySlug(e, t) { return this.callUtilsMethod(`getRecordIdBySlug`, e, t) } }, mg = (() => K.scheduler && `yield` in K.scheduler)(), hg = (() => K.scheduler && `postTask` in K.scheduler)(), gg = new Set, _g = !jh, vg = 46, yg = 47, bg = (e, t) => e.charCodeAt(t), xg = (e, t) => e.lastIndexOf(t), Sg = (e, t, n) => e.slice(t, n), Cg = !1, wg = `/`, Tg = e => e === yg, Eg = new Set([`/404.html`, `/404`, `/404/`]), Dg = RegExp(`:([a-z]\\w*)`, `gi`), Og = `framer_variant`, kg = p.createContext({ global: void 0, routes: {} }), Ag = 10, jg = 1e4, Mg = e => `--view-transition-${e}`, Ng = {
        circle: { makeKeyframe: (e, t) => { let { x: r, y: i } = Pn(e); return t === `start` ? `clip-path: circle(0 at ${r}px ${i}px);` : `clip-path: circle(${Math.hypot(Math.max(r, n.innerWidth - r), Math.max(i, n.innerHeight - i))}px at ${r}px ${i}px);` } }, conic: {
            makeKeyframe: (e, t, n) => { let r = 0; return (n === `exit` && e.angularDirection === `clockwise` && t === `start` || n === `exit` && e.angularDirection === `counter-clockwise` && t === `end` || n === `enter` && e.angularDirection === `counter-clockwise` && t === `start` || n === `enter` && e.angularDirection === `clockwise` && t === `end`) && (r = e.sweepAngle / 360 * 100), `${Mg(`conic-offset`)}: ${r}%;` }, makeStyles: (e, t) => { let n = `var(${Mg(`conic-offset`)})`, r = t === `exit` && e.angularDirection === `clockwise` || t === `enter` && e.angularDirection === `counter-clockwise`, i = r ? `transparent` : `black`, a = r ? `black` : `transparent`, o = `conic-gradient(from `; return o += `${e.angle}deg at ${e.x} ${e.y}, `, o += `${i} 0%, ${i} ${n}, `, o += `${a} ${n}, ${a} 100%)`, `mask-image: ${o}; -webkit-mask-image: ${o};` }, makePropertyRules: () => `
        @property ${Mg(`conic-offset`)} {
            syntax: '<percentage>';
            initial-value: 0%;
            inherits: false;
        }
    `}, inset: { makeKeyframe: (e, t) => { let { x: r, y: i } = Pn(e), a = n.innerHeight - i, o = n.innerWidth - r; return t === `start` ? `clip-path: inset(${i}px ${o}px ${a}px ${r}px round ${e.round}px);` : `clip-path: inset(0 round 0);` } }, blinds: {
            makeKeyframe: (e, t, n) => { let [, r] = Nn(e.width), i = `0${r}`; return (t === `start` && n === `exit` || t === `end` && n === `enter`) && (i = e.width), `${Mg(`blinds-width`)}: ${i};` }, makeStyles: (e, t) => { let n = `var(${Mg(`blinds-width`)})`, r = t === `exit` ? `transparent` : `black`, i = t === `exit` ? `black` : `transparent`, a = `repeating-linear-gradient(`; return a += e.angle + 90 + `deg, `, a += `${r} 0px, ${r} ${n}, `, a += `${i} ${n}, ${i} ${e.width})`, `mask-image: ${a}; -webkit-mask-image: ${a};` }, makePropertyRules: () => `
            @property ${Mg(`blinds-width`)} {
                syntax: '<length-percentage>';
                initial-value: 0px;
                inherits: false;
            }
        `}, wipe: {
            makeKeyframe: (e, t, n) => { let r = t === `start` && n === `exit` || t === `end` && n === `enter` ? 1 : 0; return `${Mg(`wipe-offset`)}: ${r};` }, makeStyles: (e, t) => { let n = `var(${Mg(`wipe-offset`)})`, r = t === `exit` ? `transparent` : `black`, i = t === `exit` ? `black` : `transparent`, a = `linear-gradient(`; return a += e.angle + 90 + `deg, `, a += `${r} calc(calc(0% - ${e.width}) + calc(calc(100% + ${e.width}) * ${n})), `, a += `${i} calc(calc(100% + ${e.width}) * ${n}))`, `mask-image: ${a}; -webkit-mask-image: ${a};` }, makePropertyRules: () => `
            @property ${Mg(`wipe-offset`)} {
                syntax: '<number>';
                initial-value: 0;
                inherits: false;
            }
        `}
    }, Pg = { opacity: 1, x: `0px`, y: `0px`, scale: 1, rotate: 0, rotateX: 0, rotateY: 0, mask: void 0 }, Fg = `view-transition-styles`, Ig = { x: `0px`, y: `0px`, scale: 1, opacity: 1, rotate3d: !1, rotate: 0, rotateX: 0, rotateY: 0, mask: void 0, transition: { type: `tween`, delay: 0, duration: .2, ease: [.27, 0, .51, 1], stiffness: 400, damping: 30, mass: 1 } }, Lg = () => { }, zg = () => { Rg || (Rg = document.createElement(`div`), Rg.setAttribute(`aria-live`, `assertive`), Rg.setAttribute(`aria-atomic`, `true`), Rg.style.position = `absolute`, Rg.style.transform = `scale(0)`, document.body.append(Rg)), setTimeout(() => { Rg.textContent = document.title }, 60) }, Bg = !0, Vg = (() => { if (j === void 0) return !1; let e = j.userAgent, t = e.indexOf(`Chrome/`), n = +e.slice(t + 7, e.indexOf(`.`, t)); return n > 101 && n < 128 })(), Hg = (() => Ah && typeof n.navigation?.back == `function`)(), Ug = /[\s_?#[\]@!$&'*+,;:="<>%{}|\\^`/]+/gu, Wg = p.createContext(null), Gg = (() => { let e = a(`preview`); return e.displayName = `RenderTargetEnvironmentContext`, e })(), Kg = async () => { }, qg = { activeLocale: null, locales: [], setLocale: Kg }, Jg = (() => { let e = p.createContext(qg); return e.displayName = `LocaleInfoContext`, e })(), Yg = (() => { let e = p.createContext(`ltr`); return e.displayName = `LayoutDirectionContext`, e })(), Xg = (() => { let e = a({ urlSearchParams: new URLSearchParams, replaceSearchParams: async () => { } }); return e.displayName = `URLSearchParamsContext`, e })(), Zg = `mousedown.mouseup.touchcancel.touchend.touchstart.auxclick.dblclick.pointercancel.pointerdown.pointerup.dragend.dragstart.drop.compositionend.compositionstart.keydown.keypress.keyup.input.textInput.copy.cut.paste.click.change.contextmenu.reset`.split(`.`), Qg = e => { e.target?.closest?.(`#main`) && (e.stopPropagation(), performance.mark(`framer-react-event-handling-prevented`)) }, $g = !1, g_ = [vr], h_ = [vr], m_ = [vr], p_ = [vr], f_ = [vr], d_ = [vr], u_ = [vr], l_ = [vr], c_ = [vr], s_ = [vr], o_ = [vr], a_ = [vr], i_ = [vr], r_ = [vr], n_ = [vr], t_ = [vr], e_ = [vr], v_ = class { constructor() { Ee(__, 5, this), M(this, `render`, { markStart: () => this.markRenderStart(), markEnd: () => this.markRenderEnd() }), M(this, `mutationEffects`, { measure: () => this.measureMutationEffects() }), M(this, `useInsertionEffects`, { markStart: () => this.markUseInsertionEffectsStart(), markRouterStart: () => this.markUseInsertionEffectRouterStart(), markEnd: () => this.markUseInsertionEffectsEnd() }), M(this, `useLayoutEffects`, { markStart: () => this.markUseLayoutEffectsStart(), markRouterStart: () => this.markRouterUseLayoutEffectStart(), markEnd: () => this.markUseLayoutEffectsEnd() }), M(this, `useEffects`, { markStart: () => this.markUseEffectsStart(), markRouterStart: () => this.markUseEffectsRouterStart(), markEnd: () => this.markUseEffectsEnd(), markAreSynchronous: () => this.markUseEffectsAreSynchronous() }), M(this, `browserRendering`, { hasStarted: !1, requestAnimationFrame: { markStart: () => this.markRafStart(), markEnd: () => this.markRafEnd() }, layoutStylePaint: { markEnd: () => this.markLayoutStylePaintEnd() } }), M(this, `unattributedHydrationOverhead`, { measure: () => this.measureUnattributedHydrationOverhead() }) } markRenderStart() { performance.mark(`framer-hydration-start`) } markRenderEnd() { performance.mark(`framer-hydration-render-end`), yr(`framer-hydration-render`, `framer-hydration-start`, `framer-hydration-render-end`) } markUseInsertionEffectsStart() { performance.mark(`framer-hydration-insertion-effects-start`) } markUseInsertionEffectRouterStart() { performance.mark(`framer-hydration-router-insertion-effect`) } markUseInsertionEffectsEnd() { performance.mark(`framer-hydration-insertion-effects-end`), yr(`framer-hydration-insertion-effects`, `framer-hydration-insertion-effects-start`, `framer-hydration-insertion-effects-end`) } markUseLayoutEffectsStart() { performance.mark(`framer-hydration-layout-effects-start`) } markRouterUseLayoutEffectStart() { performance.mark(`framer-hydration-router-layout-effect`) } markUseLayoutEffectsEnd() { performance.mark(`framer-hydration-layout-effects-end`), yr(`framer-hydration-layout-effects`, `framer-hydration-layout-effects-start`, `framer-hydration-layout-effects-end`) } markUseEffectsStart() { performance.mark(`framer-hydration-effects-start`) } markUseEffectsRouterStart() { performance.mark(`framer-hydration-router-effect`) } markUseEffectsAreSynchronous() { performance.mark(`framer-hydration-effects-sync`) } markUseEffectsEnd() { performance.mark(`framer-hydration-effects-end`), yr(`framer-hydration-effects`, performance.getEntriesByName(`framer-hydration-first-paint`)[0]?.name ?? performance.getEntriesByName(`framer-hydration-effects-start`)[0]?.name, `framer-hydration-effects-end`) } markRafStart() { this.browserRendering.hasStarted = !0, performance.mark(`framer-hydration-browser-render-start`) } markRafEnd() { performance.mark(`framer-hydration-browser-raf-end`), yr(`framer-hydration-raf`, `framer-hydration-browser-render-start`, `framer-hydration-browser-raf-end`) } markLayoutStylePaintEnd() { performance.mark(`framer-hydration-first-paint`), yr(`framer-hydration-time-to-first-paint`, `framer-hydration-start`, `framer-hydration-first-paint`), yr(`framer-hydration-browser-render`, `framer-hydration-browser-raf-end`, `framer-hydration-first-paint`) } measureMutationEffects() { yr(`framer-hydration-commit`, `framer-hydration-layout-effects-end`, `framer-hydration-effects-start`) } measureUnattributedHydrationOverhead() { yr(`framer-hydration-uho`, performance.getEntriesByName(`framer-hydration-effects-end`)[0]?.name ?? performance.getEntriesByName(`framer-hydration-layout-effects-end`)[0]?.name, `framer-hydration-browser-render-start`) } }, __ = le(null), ue(__, 1, `markRenderStart`, g_, v_), ue(__, 1, `markRenderEnd`, h_, v_), ue(__, 1, `markUseInsertionEffectsStart`, m_, v_), ue(__, 1, `markUseInsertionEffectRouterStart`, p_, v_), ue(__, 1, `markUseInsertionEffectsEnd`, f_, v_), ue(__, 1, `markUseLayoutEffectsStart`, d_, v_), ue(__, 1, `markRouterUseLayoutEffectStart`, u_, v_), ue(__, 1, `markUseLayoutEffectsEnd`, l_, v_), ue(__, 1, `markUseEffectsStart`, c_, v_), ue(__, 1, `markUseEffectsRouterStart`, s_, v_), ue(__, 1, `markUseEffectsAreSynchronous`, o_, v_), ue(__, 1, `markUseEffectsEnd`, a_, v_), ue(__, 1, `markRafStart`, i_, v_), ue(__, 1, `markRafEnd`, r_, v_), ue(__, 1, `markLayoutStylePaintEnd`, n_, v_), ue(__, 1, `measureMutationEffects`, t_, v_), ue(__, 1, `measureUnattributedHydrationOverhead`, e_, v_), ze(__, v_), b_ = !1, x_ = { Start: wr, End: Tr }, S_ = class extends Error { }, C_ = class extends h { constructor(e) { super(e), this.state = { error: void 0, forceUpdateKey: e.forceUpdateKey } } static getDerivedStateFromError(e) { return { error: e } } static getDerivedStateFromProps(e, t) { if (e.forceUpdateKey !== t.forceUpdateKey) { let n = { forceUpdateKey: e.forceUpdateKey }; return t.error && (n.error = void 0), n } return null } render() { if (this.state.error === void 0) return this.props.children; if (!(this.state.error instanceof S_)) throw this.state.error; let { notFoundPage: e, defaultPageStyle: t } = this.props; if (!e) throw this.state.error; return Er(e, t) } }, w_ = Object.freeze([]), E_ = new Set, D_ = class { constructor() { M(this, `observers`, new Set), M(this, `transactions`, {}) } add(e) { this.observers.add(e); let t = !1; return () => { t || (t = !0, this.remove(e)) } } remove(e) { this.observers.delete(e) } notify(e, t) { if (t) { let n = this.transactions[t] || e; n.value = e.value, this.transactions[t] = n } else this.callObservers(e) } finishTransaction(e) { let t = this.transactions[e]; return delete this.transactions[e], this.callObservers(t, e) } callObservers(e, t) { let n = []; return new Set(this.observers).forEach(r => { typeof r == `function` ? r(e, t) : (r.update(e, t), n.push(r.finish)) }), n } }, O_ = (() => { function e(e) { return Hr(`Animatable()`, `2.0.0`, `the new animation API (https://www.framer.com/api/animation/)`), Ur(e) ? e : new j_(e) } return e.transaction = e => { let t = Math.random(), n = new Set; e((e, r) => { e.set(r, t), n.add(e) }, t); let r = []; n.forEach(e => { r.push(...e.finishTransaction(t)) }), r.forEach(e => { e(t) }) }, e.getNumber = (t, n = 0) => e.get(t, n), e.get = (e, t) => e == null ? t : Ur(e) ? e.get() : e, e.objectToValues = e => { if (!e) return e; let t = {}; for (let n in e) { let r = e[n]; Ur(r) ? t[n] = r.get() : t[n] = r } return t }, e })(), k_ = `onUpdate`, A_ = `finishTransaction`, j_ = class { constructor(e) { this.value = e, M(this, `observers`, new D_) } static interpolationFor(e, t) { if (Ur(e)) return Wr(e, t) } get() { return this.value } set(e, t) { let n = this.value; Ur(e) && (e = e.get()), this.value = e; let r = { value: e, oldValue: n }; this.observers.notify(r, t) } finishTransaction(e) { return this.observers.finishTransaction(e) } onUpdate(e) { return this.observers.add(e) } }, (e => { e.isQuadrilateralPoints = e => e?.length === 4, e.add = (...e) => e.reduce((e, t) => ({ x: e.x + t.x, y: e.y + t.y }), { x: 0, y: 0 }), e.subtract = (e, t) => ({ x: e.x - t.x, y: e.y - t.y }), e.multiply = (e, t) => ({ x: e.x * t, y: e.y * t }), e.divide = (e, t) => ({ x: e.x / t, y: e.y / t }), e.absolute = e => ({ x: Math.abs(e.x), y: Math.abs(e.y) }), e.reverse = e => ({ x: e.x * -1, y: e.y * -1 }), e.pixelAligned = (e, t = { x: 0, y: 0 }) => ({ x: Kr(e.x, t.x), y: Kr(e.y, t.y) }), e.distance = (e, t) => { let n = Math.abs(e.x - t.x), r = Math.abs(e.y - t.y); return Math.sqrt(n * n + r * r) }, e.angle = (e, t) => Math.atan2(t.y - e.y, t.x - e.x) * 180 / Math.PI - 90, e.angleFromX = (e, t) => Math.atan2(t.y - e.y, t.x - e.x) * 180 / Math.PI, e.isEqual = (e, t) => e.x === t.x && e.y === t.y, e.rotationNormalizer = () => { let e; return t => { typeof e != `number` && (e = t); let n = e - t, r = Math.abs(n) + 180, i = Math.floor(r / 360); return n < 180 && (t -= i * 360), n > 180 && (t += i * 360), e = t, t } }; function t(e, t) { return { x: (e.x + t.x) / 2, y: (e.y + t.y) / 2 } } e.center = t; function n(e) { let t = 0, n = 0; return e.forEach(e => { t += e.x, n += e.y }), { x: t / e.length, y: n / e.length } } e.centroid = n; function r(t) { let n = e.centroid(t), r = new Map; for (let e = 0; e < t.length; e++) { let i = t[e]; i && r.set(i, Math.atan2(i.y - n.y, i.x - n.x)) } return t.sort((e, t) => (r.get(e) ?? 0) - (r.get(t) ?? 0)) } e.sortClockwise = r })(Jr ||= {}), M_ = { aliceblue: `f0f8ff`, antiquewhite: `faebd7`, aqua: `0ff`, aquamarine: `7fffd4`, azure: `f0ffff`, beige: `f5f5dc`, bisque: `ffe4c4`, black: `000`, blanchedalmond: `ffebcd`, blue: `00f`, blueviolet: `8a2be2`, brown: `a52a2a`, burlywood: `deb887`, burntsienna: `ea7e5d`, cadetblue: `5f9ea0`, chartreuse: `7fff00`, chocolate: `d2691e`, coral: `ff7f50`, cornflowerblue: `6495ed`, cornsilk: `fff8dc`, crimson: `dc143c`, cyan: `0ff`, darkblue: `00008b`, darkcyan: `008b8b`, darkgoldenrod: `b8860b`, darkgray: `a9a9a9`, darkgreen: `006400`, darkgrey: `a9a9a9`, darkkhaki: `bdb76b`, darkmagenta: `8b008b`, darkolivegreen: `556b2f`, darkorange: `ff8c00`, darkorchid: `9932cc`, darkred: `8b0000`, darksalmon: `e9967a`, darkseagreen: `8fbc8f`, darkslateblue: `483d8b`, darkslategray: `2f4f4f`, darkslategrey: `2f4f4f`, darkturquoise: `00ced1`, darkviolet: `9400d3`, deeppink: `ff1493`, deepskyblue: `00bfff`, dimgray: `696969`, dimgrey: `696969`, dodgerblue: `1e90ff`, firebrick: `b22222`, floralwhite: `fffaf0`, forestgreen: `228b22`, fuchsia: `f0f`, gainsboro: `dcdcdc`, ghostwhite: `f8f8ff`, gold: `ffd700`, goldenrod: `daa520`, gray: `808080`, green: `008000`, greenyellow: `adff2f`, grey: `808080`, honeydew: `f0fff0`, hotpink: `ff69b4`, indianred: `cd5c5c`, indigo: `4b0082`, ivory: `fffff0`, khaki: `f0e68c`, lavender: `e6e6fa`, lavenderblush: `fff0f5`, lawngreen: `7cfc00`, lemonchiffon: `fffacd`, lightblue: `add8e6`, lightcoral: `f08080`, lightcyan: `e0ffff`, lightgoldenrodyellow: `fafad2`, lightgray: `d3d3d3`, lightgreen: `90ee90`, lightgrey: `d3d3d3`, lightpink: `ffb6c1`, lightsalmon: `ffa07a`, lightseagreen: `20b2aa`, lightskyblue: `87cefa`, lightslategray: `789`, lightslategrey: `789`, lightsteelblue: `b0c4de`, lightyellow: `ffffe0`, lime: `0f0`, limegreen: `32cd32`, linen: `faf0e6`, magenta: `f0f`, maroon: `800000`, mediumaquamarine: `66cdaa`, mediumblue: `0000cd`, mediumorchid: `ba55d3`, mediumpurple: `9370db`, mediumseagreen: `3cb371`, mediumslateblue: `7b68ee`, mediumspringgreen: `00fa9a`, mediumturquoise: `48d1cc`, mediumvioletred: `c71585`, midnightblue: `191970`, mintcream: `f5fffa`, mistyrose: `ffe4e1`, moccasin: `ffe4b5`, navajowhite: `ffdead`, navy: `000080`, oldlace: `fdf5e6`, olive: `808000`, olivedrab: `6b8e23`, orange: `ffa500`, orangered: `ff4500`, orchid: `da70d6`, palegoldenrod: `eee8aa`, palegreen: `98fb98`, paleturquoise: `afeeee`, palevioletred: `db7093`, papayawhip: `ffefd5`, peachpuff: `ffdab9`, peru: `cd853f`, pink: `ffc0cb`, plum: `dda0dd`, powderblue: `b0e0e6`, purple: `800080`, rebeccapurple: `663399`, red: `f00`, rosybrown: `bc8f8f`, royalblue: `4169e1`, saddlebrown: `8b4513`, salmon: `fa8072`, sandybrown: `f4a460`, seagreen: `2e8b57`, seashell: `fff5ee`, sienna: `a0522d`, silver: `c0c0c0`, skyblue: `87ceeb`, slateblue: `6a5acd`, slategray: `708090`, slategrey: `708090`, snow: `fffafa`, springgreen: `00ff7f`, steelblue: `4682b4`, tan: `d2b48c`, teal: `008080`, thistle: `d8bfd8`, tomato: `ff6347`, turquoise: `40e0d0`, violet: `ee82ee`, wheat: `f5deb3`, white: `fff`, whitesmoke: `f5f5f5`, yellow: `ff0`, yellowgreen: `9acd32` }, N_ = new ((() => Ch().Hsluv)()), P_ = (() => { let e = `(?:[-\\+]?\\d*\\.\\d+%?)|(?:[-\\+]?\\d+%?)`, t = `[\\s|\\(]+(` + e + `)[,|\\s]+((?:[-\\+]?\\d*\\.\\d+%?)|(?:[-\\+]?\\d+%?))[,|\\s]+((?:[-\\+]?\\d*\\.\\d+%?)|(?:[-\\+]?\\d+%?))\\s*\\)?`, n = `[\\s|\\(]+(` + e + `)[,|\\s]+((?:[-\\+]?\\d*\\.\\d+%?)|(?:[-\\+]?\\d+%?))[,|\\s]+((?:[-\\+]?\\d*\\.\\d+%?)|(?:[-\\+]?\\d+%?))[,|\\s]+((?:[-\\+]?\\d*\\.\\d+%?)|(?:[-\\+]?\\d+%?))\\s*\\)?`; return { rgb: RegExp(`rgb` + t), rgba: RegExp(`rgba` + n), hsl: RegExp(`hsl` + t), hsla: RegExp(`hsla` + n), hsv: RegExp(`hsv` + t), hsva: RegExp(`hsva` + n), hex3: /^([\da-f])([\da-f])([\da-f])$/iu, hex6: /^([\da-f]{2})([\da-f]{2})([\da-f]{2})$/iu, hex4: /^#?([\da-f])([\da-f])([\da-f])([\da-f])$/iu, hex8: /^#?([\da-f]{2})([\da-f]{2})([\da-f]{2})([\da-f]{2})$/iu } })(), F_ = /^color\(display-p3\s+(?<r>\d+\.\d+|\d+|\.\d+)\s+(?<g>\d+\.\d+|\d+|\.\d+)\s+(?<b>\d+\.\d+|\d+|\.\d+)(?:\s*\/\s*(?<a>\d+\.\d+|\d+|\.\d+))?\)$/u, I_ = e => { let { r: t, g: n, b: r, a: i } = vi(e); return { x: .486570948648216 * t + .265667693169093 * n + .1982172852343625 * r, y: .2289745640697487 * t + .6917385218365062 * n + .079286914093745 * r, z: 0 * t + .0451133818589026 * n + 1.043944368900976 * r, a: i } }, L_ = ({ x: e = 0, y: t = 0, z: n = 0, a: r = 1 }) => bi({ r: e * 3.2409699419045226 - t * 1.537383177570094 - .4986107602930034 * n, g: e * -.9692436362808796 + t * 1.8759675015077204 + .0415550574071756 * n, b: e * .0556300796969936 - t * .2039769588889765 + 1.0569715142428784 * n, a: r }), R_ = e => { let { r: t, g: n, b: r, a: i } = vi(e); return { x: .4123907992659593 * t + .357584339383878 * n + .1804807884018343 * r, y: .2126390058715102 * t + .715168678767756 * n + .0721923153607337 * r, z: .0193308187155918 * t + .119194779794626 * n + .9505321522496607 * r, a: i } }, z_ = ({ x: e = 0, y: t = 0, z: n = 0, a: r = 1 }) => bi({ r: e * 2.4934969119414263 - t * .9313836179191242 - .402710784450717 * n, g: e * -.8294889695615749 + t * 1.7626640603183465 + .0236246858419436 * n, b: e * .0358458302437845 - t * .0761723892680418 + .9568845240076871 * n, a: r }), B_ = class e { constructor(e) { M(this, `format`, `p3`), M(this, `r`), M(this, `g`), M(this, `b`), M(this, `a`), this.r = e.r ?? 0, this.g = e.g ?? 0, this.b = e.b ?? 0, this.a = e.a ?? 1 } hsv() { return xi(this) } rgb() { return Ti(this) } hsl() { return ii(this.r, this.g, this.b) } toString(e = `p3`, t) { switch (e) { case `p3`: { let e = t?.r ?? this.r, n = t?.g ?? this.g, r = t?.b ?? this.b, i = t?.a ?? this.a; return i === 1 ? `color(display-p3 ${e} ${n} ${r})` : `color(display-p3 ${e} ${n} ${r} / ${i})` } case `srgb`: { let e = this.rgb(), n = Math.round(Math.max(0, Math.min(e.r, 1)) * 100) / 100, r = Math.round(Math.max(0, Math.min(e.g, 1)) * 100) / 100, i = Math.round(Math.max(0, Math.min(e.b, 1)) * 100) / 100, a = t?.r ?? n * 255, o = t?.g ?? r * 255, s = t?.b ?? i * 255, c = t?.a ?? e.a ?? 1; return c === 1 ? `rgb(${a}, ${o}, ${s})` : `rgba(${a}, ${o}, ${s}, ${c})` } } } static isP3String(e) { return e.startsWith(`color(display-p3`) } static fromHSV(t, n = `p3`) { switch (n) { case `p3`: return new e(Ci(t)); case `srgb`: return new e(wi(Ci(t))) } } static fromRGB(t) { return new e(wi({ r: Math.round(t.r / 255 * 1e4) / 1e4, g: Math.round(t.g / 255 * 1e4) / 1e4, b: Math.round(t.b / 255 * 1e4) / 1e4, a: t.a ?? 1 })) } static fromRGBString(t) { let n = q(t); if (n) return e.fromRGB(n) } static fromString(t) { if (!e.isP3String(t)) return; let n = gi(t); if (n) return new e({ r: n.r, g: n.g, b: n.b, a: n.a }) } static srgbFromValue(t) { if (!L(t) || !q.isP3String(t)) return t; let n = e.fromString(t); return n ? n.toString(`srgb`) : t } static multiplyAlpha(t, n) { return new e({ r: t.r, g: t.g, b: t.b, a: t.a * n }) } }, V_ = new Map, q = (() => { function e(n, r, i, a) { if (typeof n == `string`) { let r = V_.get(n); return r || (r = t(n), r === void 0 ? { ...e(`black`), isValid: !1 } : (V_.set(n, r), r)) } let o = t(n, r, i, a); return o === void 0 ? { ...e(`black`), isValid: !1 } : o } function t(t, n, r, i) { if (t === ``) return; let a = Ei(t, n, r, i); if (a) { let n = { r: a.r, g: a.g, b: a.b, a: a.a, h: a.h, s: a.s, l: a.l, initialValue: typeof t == `string` && a.format !== `hsv` ? t : void 0, roundA: Math.round(100 * a.a) / 100, format: a.format, mix: e.mix, toValue: () => e.toRgbString(n) }; return n } else return } let n = { isRGB(e) { return e === `rgb` || e === `rgba` }, isHSL(e) { return e === `hsl` || e === `hsla` } }; e.inspect = (e, t) => e.format === `hsl` ? `<${e.constructor.name} h:${e.h} s:${e.s} l:${e.l} a:${e.a}>` : e.format === `hex` || e.format === `name` ? `<${e.constructor.name} "${t}">` : `<${e.constructor.name} r:${e.r} g:${e.g} b:${e.b} a:${e.a}>`, e.isColor = t => typeof t == `string` ? e.isColorString(t) : e.isColorObject(t), e.isColorString = e => typeof e == `string` ? pi(e) !== !1 : !1, e.isColorObject = e => z(e) && typeof e.r == `number` && typeof e.g == `number` && typeof e.b == `number` && typeof e.h == `number` && typeof e.s == `number` && typeof e.l == `number` && typeof e.a == `number` && typeof e.roundA == `number` && typeof e.format == `string`, e.toString = t => e.toRgbString(t), e.toHex = (e, t = !1) => ri(e.r, e.g, e.b, t), e.toHexString = (t, n = !1) => `#${e.toHex(t, n)}`, e.isP3String = e => typeof e == `string` ? B_.isP3String(e) : !1, e.toRgbString = e => e.a === 1 ? `rgb(` + Math.round(e.r) + `, ` + Math.round(e.g) + `, ` + Math.round(e.b) + `)` : `rgba(` + Math.round(e.r) + `, ` + Math.round(e.g) + `, ` + Math.round(e.b) + `, ` + e.roundA + `)`, e.toHusl = e => ({ ...$r(e.r, e.g, e.b), a: e.roundA }), e.toHslString = t => { let n = e.toHsl(t), r = Math.round(n.h), i = Math.round(n.s * 100), a = Math.round(n.l * 100); return t.a === 1 ? `hsl(` + r + `, ` + i + `%, ` + a + `%)` : `hsla(` + r + `, ` + i + `%, ` + a + `%, ` + t.roundA + `)` }, e.toHsv = e => { let t = si(e.r, e.g, e.b); return { h: t.h * 360, s: t.s, v: t.v, a: e.a } }, e.toHsvString = e => { let t = si(e.r, e.g, e.b), n = Math.round(t.h * 360), r = Math.round(t.s * 100), i = Math.round(t.v * 100); return e.a === 1 ? `hsv(` + n + `, ` + r + `%, ` + i + `%)` : `hsva(` + n + `, ` + r + `%, ` + i + `%, ` + e.roundA + `)` }, e.toName = e => { if (e.a === 0) return `transparent`; if (e.a < 1) return !1; let t = ri(e.r, e.g, e.b, !0); for (let e of Object.keys(M_)) if (M_[e] === t) return e; return !1 }, e.toHsl = e => ({ h: Math.round(e.h), s: e.s, l: e.l, a: e.a }), e.toRgb = e => ({ r: Math.round(e.r), g: Math.round(e.g), b: Math.round(e.b), a: e.a }), e.brighten = (t, n = 10) => { let r = e.toRgb(t); return r.r = Math.max(0, Math.min(255, r.r - Math.round(255 * -(n / 100)))), r.g = Math.max(0, Math.min(255, r.g - Math.round(255 * -(n / 100)))), r.b = Math.max(0, Math.min(255, r.b - Math.round(255 * -(n / 100)))), e(r) }, e.lighten = (t, n = 10) => { let r = e.toHsl(t); return r.l += n / 100, r.l = Math.min(1, Math.max(0, r.l)), e(r) }, e.darken = (t, n = 10) => { let r = e.toHsl(t); return r.l -= n / 100, r.l = Math.min(1, Math.max(0, r.l)), e(r) }, e.saturate = (t, n = 10) => { let r = e.toHsl(t); return r.s += n / 100, r.s = Math.min(1, Math.max(0, r.s)), e(r) }, e.desaturate = (t, n = 10) => { let r = e.toHsl(t); return r.s -= n / 100, r.s = Math.min(1, Math.max(0, r.s)), e(r) }, e.grayscale = t => e.desaturate(t, 100), e.hueRotate = (t, n) => { let r = e.toHsl(t); return r.h += n, r.h = r.h > 360 ? r.h - 360 : r.h, e(r) }, e.alpha = (t, n = 1) => e({ r: t.r, g: t.g, b: t.b, a: n }), e.transparent = t => e.alpha(t, 0), e.multiplyAlpha = (t, n = 1) => e({ r: t.r, g: t.g, b: t.b, a: t.a * n }), e.interpolate = (t, n, r = `rgb`) => { if (!e.isColorObject(t) || !e.isColorObject(n)) throw TypeError(`Both arguments for Color.interpolate must be Color objects`); return i => e.mixAsColor(t, n, i, !1, r) }, e.mix = (t, n, { model: r = `rgb` } = {}) => { let i = typeof t == `string` ? e(t) : t, a = e.interpolate(i, n, r); return t => e.toRgbString(a(t)) }, e.mixAsColor = (t, r, i = .5, a = !1, o = `rgb`) => { let s = null; if (n.isRGB(o)) s = e({ r: Yr(i, [0, 1], [t.r, r.r], a), g: Yr(i, [0, 1], [t.g, r.g], a), b: Yr(i, [0, 1], [t.b, r.b], a), a: Yr(i, [0, 1], [t.a, r.a], a) }); else { let c, l; n.isHSL(o) ? (c = e.toHsl(t), l = e.toHsl(r)) : (c = e.toHusl(t), l = e.toHusl(r)), c.s === 0 ? c.h = l.h : l.s === 0 && (l.h = c.h); let u = c.h, d = l.h, f = d - u; f > 180 ? f = d - 360 - u : f < -180 && (f = d + 360 - u); let p = { h: Yr(i, [0, 1], [u, u + f], a), s: Yr(i, [0, 1], [c.s, l.s], a), l: Yr(i, [0, 1], [c.l, l.l], a), a: Yr(i, [0, 1], [t.a, r.a], a) }; s = n.isHSL(o) ? e(p) : e(ei(p.h, p.s, p.l, p.a)) } return s }, e.random = (t = 1) => { function n() { return Math.floor(Math.random() * 255) } return e(`rgba(` + n() + `, ` + n() + `, ` + n() + `, ` + t + `)`) }, e.grey = (t = .5, n = 1) => (t = Math.floor(t * 255), e(`rgba(` + t + `, ` + t + `, ` + t + `, ` + n + `)`)), e.gray = e.grey, e.rgbToHsl = (e, t, n) => ii(e, t, n), e.isValidColorProperty = (t, n) => !!((t.toLowerCase().slice(-5) === `color` || t === `fill` || t === `stroke`) && typeof n == `string` && e.isColorString(n)), e.difference = (e, t) => { let n = (e.r + t.r) / 2, r = e.r - t.r, i = e.g - t.g, a = e.b - t.b, o = r ** 2, s = i ** 2, c = a ** 2; return Math.sqrt(2 * o + 4 * s + 3 * c + n * (o - c) / 256) }, e.equal = (e, t, n = .1) => !(Math.abs(e.r - t.r) >= n || Math.abs(e.g - t.g) >= n || Math.abs(e.b - t.b) >= n || Math.abs(e.a - t.a) * 256 >= n); let r = We([0, 255], [0, 1]); function i(e) { e = r(e); let t = Math.abs(e); return t < .04045 ? e / 12.92 : (Math.sign(e) || 1) * ((t + .055) / 1.055) ** 2.4 } return e.luminance = t => { let { r: n, g: r, b: a } = e.toRgb(t); return .2126 * i(n) + .7152 * i(r) + .0722 * i(a) }, e.contrast = (t, n) => { let r = e.luminance(t), i = e.luminance(n); return (Math.max(r, i) + .05) / (Math.min(r, i) + .05) }, e })(), H_ = e => e instanceof Ve, U_ = (() => wh().EventEmitter)(), W_ = class { constructor() { M(this, `_emitter`, new U_) } eventNames() { return this._emitter.eventNames() } eventListeners() { let e = {}; for (let t of this._emitter.eventNames()) e[t] = this._emitter.listeners(t); return e } on(e, t) { this.addEventListener(e, t, !1, !1, this) } off(e, t) { this.removeEventListeners(e, t) } once(e, t) { this.addEventListener(e, t, !0, !1, this) } unique(e, t) { this.addEventListener(e, t, !1, !0, this) } addEventListener(e, t, n, r, i) { if (r) { for (let e of this._emitter.eventNames()) if (t === this._emitter.listeners(e)) return } n === !0 ? this._emitter.once(e, t, i) : this._emitter.addListener(e, t, i) } removeEventListeners(e, t) { e ? this._emitter.removeListener(e, t) : this.removeAllEventListeners() } removeAllEventListeners() { this._emitter.removeAllListeners() } countEventListeners(e) { if (e) return this._emitter.listeners(e).length; { let e = 0; for (let t of this._emitter.eventNames()) e += this._emitter.listeners(t).length; return e } } emit(e, ...t) { this._emitter.emit(e, ...t) } }, G_ = e => { setTimeout(e, 1 / 60) }, K_ = (() => K.requestAnimationFrame || G_)(), q_ = e => K_(e), J_ = (() => 1 / 60)(), Y_ = class extends W_ { constructor(e = !1) { super(), M(this, `_started`, !1), M(this, `_frame`, 0), M(this, `_frameTasks`, []), M(this, `tick`, () => { this._started && (q_(this.tick), this.emit(`update`, this._frame, J_), this.emit(`render`, this._frame, J_), this._processFrameTasks(), this._frame++) }), e && this.start() } addFrameTask(e) { this._frameTasks.push(e) } _processFrameTasks() { let e = this._frameTasks, t = e.length; if (t !== 0) { for (let n = 0; n < t; n++)e[n]?.(); e.length = 0 } } static set TimeStep(e) { J_ = e } static get TimeStep() { return J_ } start() { return this._started ? this : (this._frame = 0, this._started = !0, q_(this.tick), this) } stop() { return this._started = !1, this } get frame() { return this._frame } get time() { return this._frame * J_ } }, X_ = new Y_, Z_ = { target: K.location.origin === `https://screenshot.framer.invalid` ? `EXPORT` : `PREVIEW`, zoom: 1 }, J = { canvas: `CANVAS`, export: `EXPORT`, thumbnail: `THUMBNAIL`, preview: `PREVIEW`, current: () => Z_.target, hasRestrictions: () => { let e = Z_.target; return e === `CANVAS` || e === `EXPORT` } }, Q_ = e => ({ correct: (t, { projectionDelta: n, treeScale: r }) => { if (typeof t == `string` && (t = parseFloat(t)), t === 0) return `0px`; let i = t; return n && r && (i = Math.round(t / n[e].scale / r[e]), i = Math.max(i, 1)), i + `px` } }), Te({ borderTopWidth: Q_(`y`), borderLeftWidth: Q_(`x`), borderRightWidth: Q_(`x`), borderBottomWidth: Q_(`y`) }), $_ = p.createContext({ getLayoutId: e => null, persistLayoutIdCache: () => { }, top: !1, enabled: !0 }), ev = { background: void 0, display: `flex`, flexDirection: `column`, justifyContent: `center`, alignItems: `center`, lineHeight: `1.4em`, textOverflow: `ellipsis`, overflow: `hidden`, minHeight: 0, width: `100%`, height: `100%` }, tv = (() => ({ ...ev, border: `1px solid rgba(149, 149, 149, 0.15)`, borderRadius: 6, fontSize: `12px`, backgroundColor: `rgba(149, 149, 149, 0.1)`, color: `#a5a5a5` }))(), nv = { overflow: `hidden`, whiteSpace: `nowrap`, textOverflow: `ellipsis`, maxWidth: `100%`, flexShrink: 0, padding: `0 10px` }, rv = (() => ({ ...nv, fontWeight: 500 }))(), iv = (() => ({ ...nv, whiteSpace: `pre`, maxHeight: `calc(50% - calc(20px * var(--framerInternalCanvas-canvasPlaceholderContentScaleFactor, 1)))`, WebkitMaskImage: `linear-gradient(to bottom, black 80%, transparent 100%)` }))(), av = (() => { function e(e, t) { return { a: e, b: t } } return e.offset = (t, n) => { let r = Vi(Jr.angleFromX(t.a, t.b)), i = n * Math.sin(r), a = n * Math.cos(r); return e({ x: t.a.x + i, y: t.a.y - a }, { x: t.b.x + i, y: t.b.y - a }) }, e.intersection = (e, t, n) => { let r = e.a.x, i = e.a.y, a = e.b.x, o = e.b.y, s = t.a.x, c = t.a.y, l = t.b.x, u = t.b.y, d = (l - s) * (c - i) - (u - c) * (s - r), f = (l - s) * (o - i) - (u - c) * (a - r), p = (a - r) * (c - i) - (o - i) * (s - r); if (d === 0 && f === 0 || f === 0) return null; let m = d / f, h = p / f; return n && (m < 0 || m > 1 || h < 0 || h > 1) ? null : { x: r + m * (a - r), y: i + m * (o - i) } }, e.intersectionAngle = (e, t) => { let n = e.b.x - e.a.x, r = e.b.y - e.a.y, i = t.b.x - t.a.x, a = t.b.y - t.a.y; return Math.atan2(n * a - r * i, n * i + r * a) * (180 / Math.PI) }, e.isOrthogonal = e => e.a.x === e.b.x || e.a.y === e.b.y, e.perpendicular = (t, n) => { let r = t.a.x - t.b.x, i = t.a.y - t.b.y; return e(Jr(n.x - i, n.y + r), n) }, e.projectPoint = (t, n) => { let r = e.perpendicular(t, n); return e.intersection(t, r) }, e.pointAtPercentDistance = (t, n) => { let r = e.distance(t), i = n * r / r; return { x: i * t.b.x + (1 - i) * t.a.x, y: i * t.b.y + (1 - i) * t.a.y } }, e.distance = e => Jr.distance(e.a, e.b), e })(), Y = { equals: function (e, t) { return e === t ? !0 : !e || !t ? !1 : e.x === t.x && e.y === t.y && e.width === t.width && e.height === t.height }, from: e => ({ x: e.x, y: e.y, width: e.width, height: e.height }), atOrigin: e => ({ x: 0, y: 0, width: e.width, height: e.height }), fromTwoPoints: (e, t) => ({ x: Math.min(e.x, t.x), y: Math.min(e.y, t.y), width: Math.abs(e.x - t.x), height: Math.abs(e.y - t.y) }), fromRect: e => ({ x: e.left, y: e.top, width: e.right - e.left, height: e.bottom - e.top }), multiply: (e, t) => ({ x: e.x * t, y: e.y * t, width: e.width * t, height: e.height * t }), divide: (e, t) => Y.multiply(e, 1 / t), offset: (e, t) => { let n = typeof t.x == `number` ? t.x : 0, r = typeof t.y == `number` ? t.y : 0; return { ...e, x: e.x + n, y: e.y + r } }, inflate: (e, t) => { if (t === 0) return e; let n = 2 * t; return { x: e.x - t, y: e.y - t, width: e.width + n, height: e.height + n } }, pixelAligned: e => { let t = Math.round(e.x), n = Math.round(e.y), r = Math.round(e.x + e.width), i = Math.round(e.y + e.height); return { x: t, y: n, width: Math.max(r - t, 0), height: Math.max(i - n, 0) } }, halfPixelAligned: e => { let t = Math.round(e.x * 2) / 2, n = Math.round(e.y * 2) / 2, r = Math.round((e.x + e.width) * 2) / 2, i = Math.round((e.y + e.height) * 2) / 2; return { x: t, y: n, width: Math.max(r - t, 1), height: Math.max(i - n, 1) } }, round: (e, t = 0) => ({ x: Gr(e.x, t), y: Gr(e.y, t), width: Gr(e.width, t), height: Gr(e.height, t) }), roundToOutside: e => { let t = Math.floor(e.x), n = Math.floor(e.y), r = Math.ceil(e.x + e.width), i = Math.ceil(e.y + e.height); return { x: t, y: n, width: Math.max(r - t, 0), height: Math.max(i - n, 0) } }, minX: e => e.x, maxX: e => e.x + e.width, minY: e => e.y, maxY: e => e.y + e.height, positions: e => ({ minX: e.x, midX: e.x + e.width / 2, maxX: Y.maxX(e), minY: e.y, midY: e.y + e.height / 2, maxY: Y.maxY(e) }), center: e => ({ x: e.x + e.width / 2, y: e.y + e.height / 2 }), boundingRectFromPoints: e => { let t = 1 / 0, n = -1 / 0, r = 1 / 0, i = -1 / 0; for (let a = 0; a < e.length; a++) { let o = e[a]; t = Math.min(t, o.x), n = Math.max(n, o.x), r = Math.min(r, o.y), i = Math.max(i, o.y) } return { x: t, y: r, width: n - t, height: i - r } }, fromPoints: e => { let [t, n, r, i] = e, { x: a, y: o } = t; return { x: a, y: o, width: Jr.distance(t, n), height: Jr.distance(t, i) } }, merge: (...e) => { let t = { x: Math.min(...e.map(Y.minX)), y: Math.min(...e.map(Y.minY)) }, n = { x: Math.max(...e.map(Y.maxX)), y: Math.max(...e.map(Y.maxY)) }; return Y.fromTwoPoints(t, n) }, intersection: (e, t) => { let n = Math.max(e.x, t.x), r = Math.min(e.x + e.width, t.x + t.width), i = Math.max(e.y, t.y), a = Math.min(e.y + e.height, t.y + t.height); return { x: n, y: i, width: r - n, height: a - i } }, points: e => [{ x: Y.minX(e), y: Y.minY(e) }, { x: Y.minX(e), y: Y.maxY(e) }, { x: Y.maxX(e), y: Y.minY(e) }, { x: Y.maxX(e), y: Y.maxY(e) }], pointsAtOrigin: e => [{ x: 0, y: 0 }, { x: e.width, y: 0 }, { x: e.width, y: e.height }, { x: 0, y: e.height }], transform: (e, t) => { let { x: n, y: r } = t.transformPoint({ x: e.x, y: e.y }), { x: i, y: a } = t.transformPoint({ x: e.x + e.width, y: e.y }), { x: o, y: s } = t.transformPoint({ x: e.x + e.width, y: e.y + e.height }), { x: c, y: l } = t.transformPoint({ x: e.x, y: e.y + e.height }), u = Math.min(n, i, o, c), d = Math.max(n, i, o, c) - u, f = Math.min(r, a, s, l); return { x: u, y: f, width: d, height: Math.max(r, a, s, l) - f } }, containsPoint: (e, t) => !(t.x < Y.minX(e) || t.x > Y.maxX(e) || t.y < Y.minY(e) || t.y > Y.maxY(e) || Number.isNaN(e.x) || Number.isNaN(e.y)), containsRect: (e, t) => { for (let n of Y.points(t)) if (!Y.containsPoint(e, n)) return !1; return !0 }, toCSS: e => ({ display: `block`, transform: `translate(${e.x}px, ${e.y}px)`, width: `${e.width}px`, height: `${e.height}px` }), inset: (e, t) => ({ x: e.x + t, y: e.y + t, width: Math.max(0, e.width - 2 * t), height: Math.max(0, e.height - 2 * t) }), intersects: (e, t) => !(t.x >= Y.maxX(e) || Y.maxX(t) <= e.x || t.y >= Y.maxY(e) || Y.maxY(t) <= e.y), overlapHorizontally: (e, t) => { let n = Y.maxX(e), r = Y.maxX(t); return n > t.x && r > e.x }, overlapVertically: (e, t) => { let n = Y.maxY(e), r = Y.maxY(t); return n > t.y && r > e.y }, doesNotIntersect: (e, t) => t.find(t => Y.intersects(t, e)) === void 0, isEqual: (e, t) => Y.equals(e, t), cornerPoints: e => { let t = e.x, n = e.x + e.width, r = e.y, i = e.y + e.height; return [{ x: t, y: r }, { x: n, y: r }, { x: n, y: i }, { x: t, y: i }] }, midPoints: e => { let t = e.x, n = e.x + e.width / 2, r = e.x + e.width, i = e.y, a = e.y + e.height / 2, o = e.y + e.height; return [{ x: n, y: i }, { x: r, y: a }, { x: n, y: o }, { x: t, y: a }] }, pointDistance: (e, t) => { let n = 0, r = 0; return t.x < e.x ? n = e.x - t.x : t.x > Y.maxX(e) && (n = t.x - Y.maxX(e)), t.y < e.y ? r = e.y - t.y : t.y > Y.maxY(e) && (r = t.y - Y.maxY(e)), Jr.distance({ x: n, y: r }, { x: 0, y: 0 }) }, delta: (e, t) => { let n = { x: Y.minX(e), y: Y.minY(e) }, r = { x: Y.minX(t), y: Y.minY(t) }; return { x: n.x - r.x, y: n.y - r.y } }, withMinSize: (e, t) => { let { width: n, height: r } = t, i = e.width - n, a = e.height - r; return { width: Math.max(e.width, n), height: Math.max(e.height, r), x: e.width < n ? e.x + i / 2 : e.x, y: e.height < r ? e.y + a / 2 : e.y } }, anyPointsOutsideRect: (e, t) => { let n = Y.minX(e), r = Y.minY(e), i = Y.maxX(e), a = Y.maxY(e); for (let e of t) if (e.x < n || e.x > i || e.y < r || e.y > a) return !0; return !1 }, edges: e => { let [t, n, r, i] = Y.cornerPoints(e); return [av(t, n), av(n, r), av(r, i), av(i, t)] }, rebaseRectOnto: (e, t, n, r) => { let i = { ...e }; switch (n) { case `bottom`: case `top`: switch (r) { case `start`: i.x = t.x; break; case `center`: i.x = t.x + t.width / 2 - e.width / 2; break; case `end`: i.x = t.x + t.width - e.width; break; default: V(r) }break; case `left`: i.x = t.x - e.width; break; case `right`: i.x = t.x + t.width; break; default: V(n) }switch (n) { case `left`: case `right`: switch (r) { case `start`: i.y = t.y; break; case `center`: i.y = t.y + t.height / 2 - e.height / 2; break; case `end`: i.y = t.y + t.height - e.height; break; default: V(r) }break; case `top`: i.y = t.y - e.height; break; case `bottom`: i.y = t.y + t.height; break; default: V(n) }return i }, constrain: (e, t) => { if (!t) return e; let n = Math.max(e.y, t.y); n = Math.min(n, t.y + t.height - e.height); let r = Math.max(e.x, t.x); return r = Math.min(r, t.x + t.width - e.width), { x: r, y: n, width: e.width, height: e.height } }, closestEdge: (e, t) => { let n = av(t, Y.center(e)), r = Y.edges(e); for (let e = 0; e < r.length; e++) { let t = r[e]; if (t && av.intersection(n, t, !0)) { let n = ov[e]; return B(n, `Invalid edge name`, ov), { edge: t, name: n } } } }, closestRect: (e, t) => { let n = 0, r = e[0]; B(r, `Rect array is empty`); let i = Y.pointDistance(r, t); for (let a = 1; a < e.length; a += 1) { let o = e[a]; B(o); let s = Y.pointDistance(o, t); if (s < i && (n = a, r = o, i = s), i === 0) break } return { rect: r, index: n } } }, ov = [`top`, `right`, `bottom`, `left`], sv = { quickfix: e => ((Hi(e.widthType) || Hi(e.heightType)) && (e.aspectRatio = null), H(e.aspectRatio) && (e.left && e.right && (e.widthType = 0), e.top && e.bottom && (e.heightType = 0), e.left && e.right && e.top && e.bottom && (e.bottom = !1), e.widthType !== 0 && e.heightType !== 0 && (e.heightType = 0)), e.left && e.right && ((e.fixedSize || Hi(e.widthType) || H(e.maxWidth)) && (e.right = !1), e.widthType = 0), e.top && e.bottom && ((e.fixedSize || Hi(e.heightType) || H(e.maxHeight)) && (e.bottom = !1), e.heightType = 0), e) }, cv = { fromProperties: e => { let { left: t, right: n, top: r, bottom: i, width: a, height: o, centerX: s, centerY: c, aspectRatio: l, autoSize: u } = e, d = sv.quickfix({ left: H(t) || Ur(t), right: H(n) || Ur(n), top: H(r) || Ur(r), bottom: H(i) || Ur(i), widthType: Ui(a), heightType: Ui(o), aspectRatio: l || null, fixedSize: u === !0 }), f = null, p = null, m = 0, h = 0; if (d.widthType !== 0 && typeof a == `string`) { let e = parseFloat(a); a.endsWith(`fr`) ? (m = 3, f = e) : a === `auto` ? m = 2 : (m = 1, f = e / 100) } else a !== void 0 && typeof a != `string` && (f = O_.getNumber(a)); if (d.heightType !== 0 && typeof o == `string`) { let e = parseFloat(o); o.endsWith(`fr`) ? (h = 3, p = e) : o === `auto` ? h = 2 : (h = 1, p = parseFloat(o) / 100) } else o !== void 0 && typeof o != `string` && (p = O_.getNumber(o)); let g = .5, _ = .5; return s && (g = parseFloat(s) / 100), c && (_ = parseFloat(c) / 100), { left: d.left ? O_.getNumber(t) : null, right: d.right ? O_.getNumber(n) : null, top: d.top ? O_.getNumber(r) : null, bottom: d.bottom ? O_.getNumber(i) : null, widthType: m, heightType: h, width: f, height: p, aspectRatio: d.aspectRatio || null, centerAnchorX: g, centerAnchorY: _ } }, toSize: (e, t, n, r) => { let i = null, a = null, o = t?.sizing ? O_.getNumber(t?.sizing.width) : null, s = t?.sizing ? O_.getNumber(t?.sizing.height) : null, c = Yi(e.left, e.right); if (o && H(c)) i = o - c; else if (n && Hi(e.widthType)) i = n.width; else if (H(e.width)) switch (e.widthType) { case 0: i = e.width; break; case 3: i = r ? r.freeSpaceInParent.width / r.freeSpaceUnitDivisor.width * e.width : null; break; case 1: case 4: o && (i = o * e.width); break; case 2: case 5: break; default: V(e.widthType) }let l = Yi(e.top, e.bottom); if (s && H(l)) a = s - l; else if (n && Hi(e.heightType)) a = n.height; else if (H(e.height)) switch (e.heightType) { case 0: a = e.height; break; case 3: a = r ? r.freeSpaceInParent.height / r.freeSpaceUnitDivisor.height * e.height : null; break; case 1: case 4: s && (a = s * e.height); break; case 2: case 5: break; default: V(e.heightType) }return Ji(i, a, e, { height: s ?? 0, width: o ?? 0 }, t?.viewport) }, toRect: (e, t = null, n = null, r = !1, i = null) => { let a = e.left || 0, o = e.top || 0, { width: s, height: c } = cv.toSize(e, t, n, i), l = t?.positioning ?? null, u = l ? O_.getNumber(l.width) : null, d = l ? O_.getNumber(l.height) : null; e.left === null ? u && e.right !== null ? a = u - e.right - s : u && (a = e.centerAnchorX * u - s / 2) : a = e.left, e.top === null ? d && e.bottom !== null ? o = d - e.bottom - c : d && (o = e.centerAnchorY * d - c / 2) : o = e.top; let f = { x: a, y: o, width: s, height: c }; return r ? Y.pixelAligned(f) : f } }, lv = 200, uv = 200, dv = p.createContext({ parentSize: 0 }), fv = e => { let t = ra(), { parentSize: n, children: r } = e, i = p.useMemo(() => ({ parentSize: n }), [aa(n), oa(n)]); return t === 1 ? r ? m(E, { children: r }) : null : m(dv.Provider, { value: i, children: r }) }, pv = (e => (e.Boolean = `boolean`, e.Number = `number`, e.String = `string`, e.RichText = `richtext`, e.FusedNumber = `fusednumber`, e.Enum = `enum`, e.SegmentedEnum = `segmentedenum`, e.Color = `color`, e.Image = `image`, e.ResponsiveImage = `responsiveimage`, e.File = `file`, e.ComponentInstance = `componentinstance`, e.Slot = `slot`, e.Array = `array`, e.EventHandler = `eventhandler`, e.Transition = `transition`, e.BoxShadow = `boxshadow`, e.Link = `link`, e.Date = `date`, e.Object = `object`, e.Font = `font`, e.PageScope = `pagescope`, e.ScrollSectionRef = `scrollsectionref`, e.CustomCursor = `customcursor`, e.Border = `border`, e.Cursor = `cursor`, e.Padding = `padding`, e.BorderRadius = `borderradius`, e.Gap = `gap`, e.CollectionReference = `collectionreference`, e.MultiCollectionReference = `multicollectionreference`, e.TrackingId = `trackingid`, e.VectorSetItem = `vectorsetitem`, e.LinkRelValues = `linkrelvalues`, e))(pv || {}), mv = /Mac/u, hv = /iPhone|iPod|iPad/iu, gv = /MacIntel/iu, _v = /Edg\//u, vv = /Chrome/u, yv = /Google Inc/u, bv = /Safari/u, xv = /Apple Computer/u, Sv = /Firefox\/\d+\.\d+$/u, Cv = /FramerX/u, wv = /tablet|iPad|Nexus 9/iu, Tv = /mobi/iu, Ev = p.createContext(void 0), Dv = new Set, kv = `style[data-framer-css-ssr-minified]`, Av = (() => { if (!va()) return new Set; let e = document.querySelector(kv)?.getAttribute(`data-framer-components`); return e ? new Set(e.split(` `)) : new Set })(), jv = `data-framer-css-ssr`, Mv = (e, t, n) => p.forwardRef((r, i) => {
        let { sheet: a, cache: o } = p.useContext(Ev) ?? {}, s = n; if (!va()) {
            Ye(t) && (t = t(J.current(), r)); let e = Array.isArray(t) ? t.join(`
`) : t; Pv.add(e, s)
        } return d(() => {
            s && Av.has(s) || (Ye(t) ? t(J.current(), r) : Array.isArray(t) ? t : t.split(`
`)).forEach(e => e && wa(e, a, o))
        }, []), m(e, { ...r, ref: i })
    }), Nv = class { constructor() { M(this, `styles`, new Set), M(this, `componentIds`, new Set) } add(e, t) { this.styles.add(e), t && this.componentIds.add(t) } getStyles() { return this.styles } getComponentIds() { return this.componentIds } clear() { this.styles.clear(), this.componentIds.clear() } }, Pv = new Nv, Iv = `flexbox-gap-not-supported`, Lv = !1, Rv = [`[data-framer-component-type="DeprecatedRichText"] { cursor: inherit; }`, `
[data-framer-component-type="DeprecatedRichText"] .text-styles-preset-reset {
    --framer-font-family: Inter, Inter Placeholder, sans-serif;
    --framer-font-style: normal;
    --framer-font-weight: 500;
    --framer-text-color: #000;
    --framer-font-size: 16px;
    --framer-letter-spacing: 0;
    --framer-text-transform: none;
    --framer-text-decoration: none;
    --framer-line-height: 1.2em;
    --framer-text-alignment: start;
    --framer-font-open-type-features: normal;
    --font-variation-settings: normal;
}
`, `
[data-framer-component-type="DeprecatedRichText"] p,
[data-framer-component-type="DeprecatedRichText"] div,
[data-framer-component-type="DeprecatedRichText"] h1,
[data-framer-component-type="DeprecatedRichText"] h2,
[data-framer-component-type="DeprecatedRichText"] h3,
[data-framer-component-type="DeprecatedRichText"] h4,
[data-framer-component-type="DeprecatedRichText"] h5,
[data-framer-component-type="DeprecatedRichText"] h6 {
    margin: 0;
    padding: 0;
}
`, `
[data-framer-component-type="DeprecatedRichText"] p,
[data-framer-component-type="DeprecatedRichText"] div,
[data-framer-component-type="DeprecatedRichText"] h1,
[data-framer-component-type="DeprecatedRichText"] h2,
[data-framer-component-type="DeprecatedRichText"] h3,
[data-framer-component-type="DeprecatedRichText"] h4,
[data-framer-component-type="DeprecatedRichText"] h5,
[data-framer-component-type="DeprecatedRichText"] h6,
[data-framer-component-type="DeprecatedRichText"] li,
[data-framer-component-type="DeprecatedRichText"] ol,
[data-framer-component-type="DeprecatedRichText"] ul,
[data-framer-component-type="DeprecatedRichText"] span:not([data-text-fill]) {
    font-family: var(--framer-font-family, Inter, Inter Placeholder, sans-serif);
    font-style: var(--framer-font-style, normal);
    font-weight: var(--framer-font-weight, 400);
    color: var(--framer-text-color, #000);
    font-size: var(--framer-font-size, 16px);
    letter-spacing: var(--framer-letter-spacing, 0);
    text-transform: var(--framer-text-transform, none);
    text-decoration: var(--framer-text-decoration, none);
    line-height: var(--framer-line-height, 1.2em);
    text-align: var(--framer-text-alignment, start);
}
`, `
[data-framer-component-type="DeprecatedRichText"] p:not(:first-child),
[data-framer-component-type="DeprecatedRichText"] div:not(:first-child),
[data-framer-component-type="DeprecatedRichText"] h1:not(:first-child),
[data-framer-component-type="DeprecatedRichText"] h2:not(:first-child),
[data-framer-component-type="DeprecatedRichText"] h3:not(:first-child),
[data-framer-component-type="DeprecatedRichText"] h4:not(:first-child),
[data-framer-component-type="DeprecatedRichText"] h5:not(:first-child),
[data-framer-component-type="DeprecatedRichText"] h6:not(:first-child),
[data-framer-component-type="DeprecatedRichText"] ol:not(:first-child),
[data-framer-component-type="DeprecatedRichText"] ul:not(:first-child),
[data-framer-component-type="DeprecatedRichText"] .framer-image:not(:first-child) {
    margin-top: var(--framer-paragraph-spacing, 0);
}
`, `
[data-framer-component-type="DeprecatedRichText"] span[data-text-fill] {
    display: inline-block;
    background-clip: text;
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
}
`, `
[data-framer-component-type="DeprecatedRichText"] a,
[data-framer-component-type="DeprecatedRichText"] a span:not([data-text-fill]) {
    font-family: var(--framer-link-font-family, var(--framer-font-family, Inter, Inter Placeholder, sans-serif));
    font-style: var(--framer-link-font-style, var(--framer-font-style, normal));
    font-weight: var(--framer-link-font-weight, var(--framer-font-weight, 400));
    color: var(--framer-link-text-color, var(--framer-text-color, #000));
    font-size: var(--framer-link-font-size, var(--framer-font-size, 16px));
    text-transform: var(--framer-link-text-transform, var(--framer-text-transform, none));
    text-decoration: var(--framer-link-text-decoration, var(--framer-text-decoration, none));
}
`, `
[data-framer-component-type="DeprecatedRichText"] a:hover,
[data-framer-component-type="DeprecatedRichText"] a:hover span:not([data-text-fill]) {
    font-family: var(--framer-link-hover-font-family, var(--framer-link-font-family, var(--framer-font-family, Inter, Inter Placeholder, sans-serif)));
    font-style: var(--framer-link-hover-font-style, var(--framer-link-font-style, var(--framer-font-style, normal)));
    font-weight: var(--framer-link-hover-font-weight, var(--framer-link-font-weight, var(--framer-font-weight, 400)));
    color: var(--framer-link-hover-text-color, var(--framer-link-text-color, var(--framer-text-color, #000)));
    font-size: var(--framer-link-hover-font-size, var(--framer-link-font-size, var(--framer-font-size, 16px)));
    text-transform: var(--framer-link-hover-text-transform, var(--framer-link-text-transform, var(--framer-text-transform, none)));
    text-decoration: var(--framer-link-hover-text-decoration, var(--framer-link-text-decoration, var(--framer-text-decoration, none)));
}
`, `
[data-framer-component-type="DeprecatedRichText"] a[data-framer-page-link-current],
[data-framer-component-type="DeprecatedRichText"] a[data-framer-page-link-current] span:not([data-text-fill]):not([data-nested-link]) {
    font-family: var(--framer-link-current-font-family, var(--framer-link-font-family, var(--framer-font-family, Inter, Inter Placeholder, sans-serif)));
    font-style: var(--framer-link-current-font-style, var(--framer-link-font-style, var(--framer-font-style, normal)));
    font-weight: var(--framer-link-current-font-weight, var(--framer-link-font-weight, var(--framer-font-weight, 400)));
    color: var(--framer-link-current-text-color, var(--framer-link-text-color, var(--framer-text-color, #000)));
    font-size: var(--framer-link-current-font-size, var(--framer-link-font-size, var(--framer-font-size, 16px)));
    text-transform: var(--framer-link-current-text-transform, var(--framer-link-text-transform, var(--framer-text-transform, none)));
    text-decoration: var(--framer-link-current-text-decoration, var(--framer-link-text-decoration, var(--framer-text-decoration, none)));
}
`, `
[data-framer-component-type="DeprecatedRichText"] a[data-framer-page-link-current]:hover,
[data-framer-component-type="DeprecatedRichText"] a[data-framer-page-link-current]:hover span:not([data-text-fill]):not([data-nested-link]) {
    font-family: var(--framer-link-hover-font-family, var(--framer-link-current-font-family, var(--framer-link-font-family, var(--framer-font-family, Inter, Inter Placeholder, sans-serif))));
    font-style: var(--framer-link-hover-font-style, var(--framer-link-current-font-style, var(--framer-link-font-style, var(--framer-font-style, normal))));
    font-weight: var(--framer-link-hover-font-weight, var(--framer-link-current-font-weight, var(--framer-link-font-weight, var(--framer-font-weight, 400))));
    color: var(--framer-link-hover-text-color, var(--framer-link-current-text-color, var(--framer-link-text-color, var(--framer-text-color, #000))));
    font-size: var(--framer-link-hover-font-size, var(--framer-link-current-font-size, var(--framer-link-font-size, var(--framer-font-size, 16px))));
    text-transform: var(--framer-link-hover-text-transform, var(--framer-link-current-text-transform, var(--framer-link-text-transform, var(--framer-text-transform, none))));
    text-decoration: var(--framer-link-hover-text-decoration, var(--framer-link-current-text-decoration, var(--framer-link-text-decoration, var(--framer-text-decoration, none))));
}
`, `
[data-framer-component-type="DeprecatedRichText"] strong {
    font-weight: bolder;
}
`, `
[data-framer-component-type="DeprecatedRichText"] em {
    font-style: italic;
}
`, `
[data-framer-component-type="DeprecatedRichText"] .framer-image {
    display: block;
    max-width: 100%;
    height: auto;
}
`, `
[data-framer-component-type="DeprecatedRichText"] ul,
[data-framer-component-type="DeprecatedRichText"] ol {
    display: table;
    width: 100%;
    padding-left: 0;
    margin: 0;
}
`, `
[data-framer-component-type="DeprecatedRichText"] li {
    display: table-row;
    counter-increment: list-item;
    list-style: none;
}
`, `
[data-framer-component-type="DeprecatedRichText"] ol > li::before {
    display: table-cell;
    width: 2.25ch;
    box-sizing: border-box;
    padding-right: 0.75ch;
    content: counter(list-item) ".";
    white-space: nowrap;
}
`, `
[data-framer-component-type="DeprecatedRichText"] ul > li::before {
    display: table-cell;
    width: 2.25ch;
    box-sizing: border-box;
    padding-right: 0.75ch;
    content: "";
}
`], zv = (e => (e.Padding = `--framer-input-padding`, e.BorderRadiusTopLeft = `--framer-input-border-radius-top-left`, e.BorderRadiusTopRight = `--framer-input-border-radius-top-right`, e.BorderRadiusBottomRight = `--framer-input-border-radius-bottom-right`, e.BorderRadiusBottomLeft = `--framer-input-border-radius-bottom-left`, e.CornerShape = `--framer-input-corner-shape`, e.BorderColor = `--framer-input-border-color`, e.BorderTopWidth = `--framer-input-border-top-width`, e.BorderRightWidth = `--framer-input-border-right-width`, e.BorderBottomWidth = `--framer-input-border-bottom-width`, e.BorderLeftWidth = `--framer-input-border-left-width`, e.BorderStyle = `--framer-input-border-style`, e.Background = `--framer-input-background`, e.FontFamily = `--framer-input-font-family`, e.FontWeight = `--framer-input-font-weight`, e.FontSize = `--framer-input-font-size`, e.FontColor = `--framer-input-font-color`, e.FontStyle = `--framer-input-font-style`, e.FontLetterSpacing = `--framer-input-font-letter-spacing`, e.FontTextAlignment = `--framer-input-font-text-alignment`, e.FontLineHeight = `--framer-input-font-line-height`, e.FontOpenType = `--framer-input-font-open-type-features`, e.FontVariationAxes = `--framer-input-font-variation-axes`, e.PlaceholderColor = `--framer-input-placeholder-color`, e.BoxShadow = `--framer-input-box-shadow`, e.FocusedBorderColor = `--framer-input-focused-border-color`, e.FocusedBorderWidth = `--framer-input-focused-border-width`, e.FocusedBorderStyle = `--framer-input-focused-border-style`, e.FocusedBackground = `--framer-input-focused-background`, e.FocusedBoxShadow = `--framer-input-focused-box-shadow`, e.FocusedTransition = `--framer-input-focused-transition`, e.BooleanCheckedBackground = `--framer-input-boolean-checked-background`, e.BooleanCheckedBorderColor = `--framer-input-boolean-checked-border-color`, e.BooleanCheckedBorderWidth = `--framer-input-boolean-checked-border-width`, e.BooleanCheckedBorderStyle = `--framer-input-boolean-checked-border-style`, e.BooleanCheckedBoxShadow = `--framer-input-boolean-checked-box-shadow`, e.BooleanCheckedTransition = `--framer-input-boolean-checked-transition`, e.InvalidTextColor = `--framer-input-invalid-text-color`, e.IconBackgroundImage = `--framer-input-icon-image`, e.IconMaskImage = `--framer-input-icon-mask-image`, e.IconColor = `--framer-input-icon-color`, e.WrapperHeight = `--framer-input-wrapper-height`, e))(zv || {}), X = zv, Bv = `framer-form-input`, Vv = `framer-form-input-wrapper`, Hv = `framer-form-input-empty`, Uv = `framer-form-input-forced-focus`, Z = (() => { function e(e, t) { let n = ` `; for (let e in t) { let r = t[e]; B(r !== void 0, "Encountered `undefined` in CSSDeclaration"), n += `${e.replace(/([A-Z])/gu, `-$1`).toLowerCase()}: ${Da(r)}; ` } return e + ` {` + n + `}` } return e.variable = (...e) => { let t = e[e.length - 1]; B(t !== void 0, "Zero variables passed to `css.variable`"); let n = t.startsWith(`--`) ? `var(${t})` : t; for (let t = e.length - 2; t >= 0; t--)n = `var(${e[t]}, ${n})`; return n }, e })(), Wv = (() => [Z(`.${Bv}`, { padding: Z.variable(X.Padding), background: `transparent`, fontFamily: Z.variable(X.FontFamily), fontWeight: Z.variable(X.FontWeight), fontSize: Z.variable(X.FontSize), fontStyle: Z.variable(X.FontStyle), color: Z.variable(X.FontColor), fontFeatureSettings: Z.variable(X.FontOpenType), fontVariationSettings: Z.variable(X.FontVariationAxes), border: `none`, textOverflow: `ellipsis`, whiteSpace: `nowrap`, overflow: `hidden`, width: `100%`, height: Z.variable(X.WrapperHeight, `100%`), letterSpacing: Z.variable(X.FontLetterSpacing), textAlign: Z.variable(X.FontTextAlignment), lineHeight: Z.variable(X.FontLineHeight) }), Z(`.${Bv}:focus-visible`, { outline: `none` })])(), Gv = (() => [Z(`.${Vv}`, { overflow: `hidden` })])(), Kv = `var(${X.BorderTopWidth}) var(${X.BorderRightWidth}) var(${X.BorderBottomWidth}) var(${X.BorderLeftWidth})`, qv = (() => [`.${Vv}:after {
        content: "";
        pointer-events: none;
        box-sizing: border-box;
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        border-top-left-radius: var(${X.BorderRadiusTopLeft});
        border-top-right-radius: var(${X.BorderRadiusTopRight});
        border-bottom-right-radius: var(${X.BorderRadiusBottomRight});
        border-bottom-left-radius: var(${X.BorderRadiusBottomLeft});
        corner-shape: var(${X.CornerShape});
        border-color: var(${X.BorderColor});
        border-top-width: var(${X.BorderTopWidth});
        border-right-width: var(${X.BorderRightWidth});
        border-bottom-width: var(${X.BorderBottomWidth});
        border-left-width: var(${X.BorderLeftWidth});
        border-style: var(${X.BorderStyle});
        transition: var(${X.FocusedTransition});
        transition-property: border-color, border-width, border-style, border-top-left-radius, border-top-right-radius, border-bottom-right-radius, border-bottom-left-radius, corner-shape;
    }`])(), Jv = `customError`, Yv = `valid`, Xv = 10, Zv = 16, Qv = (() => ({ content: ``, display: `block`, position: `absolute`, right: 0, top: 0, bottom: 0, width: `${Zv}px`, boxSizing: `content-box`, padding: Z.variable(X.Padding), border: `none`, pointerEvents: `none`, backgroundRepeat: `no-repeat`, backgroundSize: `${Zv}px`, maskRepeat: `no-repeat`, maskSize: `${Zv}px`, backgroundColor: Z.variable(X.IconColor) }))(), $v = { display: `flex`, flexDirection: `column`, justifyContent: `flex-start` }, ey = { display: `inline-block` }, ty = { display: `block` }, ny = (() => [`
        [data-framer-component-type="RichTextContainer"] {
            display: ${$v.display};
            flex-direction: ${$v.flexDirection};
            justify-content: ${$v.justifyContent};
            outline: none;
            flex-shrink: 0;
        }
    `, `
        p.framer-text,
        div.framer-text,
        figure.framer-text,
        h1.framer-text,
        h2.framer-text,
        h3.framer-text,
        h4.framer-text,
        h5.framer-text,
        h6.framer-text,
        ol.framer-text,
        ul.framer-text {
            margin: 0;
            padding: 0;
        }
    `, `
        p.framer-text,
        div.framer-text,
        h1.framer-text,
        h2.framer-text,
        h3.framer-text,
        h4.framer-text,
        h5.framer-text,
        h6.framer-text,
        li.framer-text,
        ol.framer-text,
        ul.framer-text,
        mark.framer-text,
        span.framer-text:not([data-text-fill]) {
            font-family: var(--framer-font-family-preview, var(--framer-blockquote-font-family, var(--framer-font-family, Inter, Inter Placeholder, sans-serif)));
            font-style: var(--framer-font-style-preview, var(--framer-blockquote-font-style, var(--framer-font-style, normal)));
            font-weight: var(--framer-font-weight-preview, var(--framer-blockquote-font-weight, var(--framer-font-weight, 400)));
            color: var(--framer-blockquote-text-color, var(--framer-text-color, #000));
            font-size: calc(var(--framer-blockquote-font-size, var(--framer-font-size, 16px)) * var(--framer-font-size-scale, 1));
            letter-spacing: var(--framer-blockquote-letter-spacing, var(--framer-letter-spacing, 0));
            text-transform: var(--framer-blockquote-text-transform, var(--framer-text-transform, none));
            text-decoration-line: var(--framer-blockquote-text-decoration, var(--framer-text-decoration, initial));
            text-decoration-style: var(--framer-blockquote-text-decoration-style, var(--framer-text-decoration-style, initial));
            text-decoration-color: var(--framer-blockquote-text-decoration-color, var(--framer-text-decoration-color, initial));
            text-decoration-thickness: var(--framer-blockquote-text-decoration-thickness, var(--framer-text-decoration-thickness, initial));
            text-decoration-skip-ink: var(--framer-blockquote-text-decoration-skip-ink, var(--framer-text-decoration-skip-ink, initial));
            text-underline-offset: var(--framer-blockquote-text-decoration-offset, var(--framer-text-decoration-offset, initial));
            line-height: var(--framer-blockquote-line-height, var(--framer-line-height, 1.2em));
            text-align: var(--framer-blockquote-text-alignment, var(--framer-text-alignment, start));
            -webkit-text-stroke-width: var(--framer-text-stroke-width, initial);
            -webkit-text-stroke-color: var(--framer-text-stroke-color, initial);
            -moz-font-feature-settings: var(--framer-font-open-type-features, initial);
            -webkit-font-feature-settings: var(--framer-font-open-type-features, initial);
            font-feature-settings: var(--framer-font-open-type-features, initial);
            font-variation-settings: var(--framer-font-variation-axes-preview, var(--framer-font-variation-axes, normal));
            text-wrap: var(--framer-text-wrap-override, var(--framer-text-wrap));
        }
    `, `
        mark.framer-text,
        p.framer-text,
        div.framer-text,
        h1.framer-text,
        h2.framer-text,
        h3.framer-text,
        h4.framer-text,
        h5.framer-text,
        h6.framer-text,
        li.framer-text,
        ol.framer-text,
        ul.framer-text {
            background-color: var(--framer-blockquote-text-background-color, var(--framer-text-background-color, initial));
            border-radius: var(--framer-blockquote-text-background-radius, var(--framer-text-background-radius, initial));
            corner-shape: var(--framer-blockquote-text-background-corner-shape, var(--framer-text-background-corner-shape, initial));
            padding: var(--framer-blockquote-text-background-padding, var(--framer-text-background-padding, initial));
        }
    `, `
        @supports not (color: color(display-p3 1 1 1)) {
            p.framer-text,
            div.framer-text,
            h1.framer-text,
            h2.framer-text,
            h3.framer-text,
            h4.framer-text,
            h5.framer-text,
            h6.framer-text,
            li.framer-text,
            ol.framer-text,
            ul.framer-text,
            span.framer-text:not([data-text-fill]) {
                color: ${ja([`--framer-blockquote-text-color`, `--framer-text-color`], `#000`)};
                -webkit-text-stroke-color: ${ja([`--framer-text-stroke-color`], `initial`)};
            }

            mark.framer-text {
                background-color: ${ja([`--framer-blockquote-text-background-color`, `--framer-text-background-color`], `initial`)};
            }
        }
    `, `
        .framer-fit-text .framer-text {
            white-space: nowrap;
            white-space-collapse: preserve;
        }
    `, `
        strong.framer-text {
            font-family: var(--framer-blockquote-font-family-bold, var(--framer-font-family-bold));
            font-style: var(--framer-blockquote-font-style-bold, var(--framer-font-style-bold));
            font-weight: var(--framer-blockquote-font-weight-bold, var(--framer-font-weight-bold, bolder));
            font-variation-settings: var(--framer-blockquote-font-variation-axes-bold, var(--framer-font-variation-axes-bold));
        }
    `, `
        em.framer-text {
            font-family: var(--framer-blockquote-font-family-italic, var(--framer-font-family-italic));
            font-style: var(--framer-blockquote-font-style-italic, var(--framer-font-style-italic, italic));
            font-weight: var(--framer-blockquote-font-weight-italic, var(--framer-font-weight-italic));
            font-variation-settings: var(--framer-blockquote-font-variation-axes-italic, var(--framer-font-variation-axes-italic));
        }
    `, `
        em.framer-text > strong.framer-text {
            font-family: var(--framer-blockquote-font-family-bold-italic, var(--framer-font-family-bold-italic));
            font-style: var(--framer-blockquote-font-style-bold-italic, var(--framer-font-style-bold-italic, italic));
            font-weight: var(--framer-blockquote-font-weight-bold-italic, var(--framer-font-weight-bold-italic, bolder));
            font-variation-settings: var(--framer-blockquote-font-variation-axes-bold-italic, var(--framer-font-variation-axes-bold-italic));
        }
    `, `
        p.framer-text:not(:first-child),
        div.framer-text:not(:first-child),
        h1.framer-text:not(:first-child),
        h2.framer-text:not(:first-child),
        h3.framer-text:not(:first-child),
        h4.framer-text:not(:first-child),
        h5.framer-text:not(:first-child),
        h6.framer-text:not(:first-child),
        ol.framer-text:not(:first-child),
        ul.framer-text:not(:first-child),
        blockquote.framer-text:not(:first-child),
        table.framer-text:not(:first-child),
        figure.framer-text:not(:first-child),
        .framer-image.framer-text:not(:first-child) {
            margin-top: var(--framer-blockquote-paragraph-spacing, var(--framer-paragraph-spacing, 0));
        }
    `, `
        li.framer-text > ul.framer-text:nth-child(2),
        li.framer-text > ol.framer-text:nth-child(2) {
            margin-top: 0;
        }
    `, `
        .framer-text[data-text-fill] {
            display: ${ey.display};
            background-clip: text;
            -webkit-background-clip: text;
            /* make this a transparent color if you want to visualise the clipping  */
            -webkit-text-fill-color: transparent;
            padding: max(0em, calc(calc(1.3em - var(--framer-blockquote-line-height, var(--framer-line-height, 1.3em))) / 2));
            margin: min(0em, calc(calc(1.3em - var(--framer-blockquote-line-height, var(--framer-line-height, 1.3em))) / -2));
        }
    `, `
        code.framer-text,
        code.framer-text span.framer-text:not([data-text-fill]) {
            font-family: var(--framer-code-font-family, var(--framer-font-family, Inter, Inter Placeholder, sans-serif));
            font-style: var(--framer-blockquote-font-style, var(--framer-code-font-style, var(--framer-font-style, normal)));
            font-weight: var(--framer-blockquote-font-weight, var(--framer-code-font-weight, var(--framer-font-weight, 400)));
            color: var(--framer-blockquote-text-color, var(--framer-code-text-color, var(--framer-text-color, #000)));
            font-size: calc(var(--framer-blockquote-font-size, var(--framer-font-size, 16px)) * var(--framer-font-size-scale, 1));
            letter-spacing: var(--framer-blockquote-letter-spacing, var(--framer-letter-spacing, 0));
            line-height: var(--framer-blockquote-line-height, var(--framer-line-height, 1.2em));
        }
    `, `
        @supports not (color: color(display-p3 1 1 1)) {
            code.framer-text,
            code.framer-text span.framer-text:not([data-text-fill]) {
                color: ${ja([`--framer-blockquote-text-color`, `--framer-code-text-color`, `--framer-text-color`], `#000`)};
            }
        }
    `, `
        blockquote.framer-text {
            margin-block-start: initial;
            margin-block-end: initial;
            margin-inline-start: initial;
            margin-inline-end: initial;
            unicode-bidi: initial;
        }
    `, `
        a.framer-text,
        a.framer-text span.framer-text:not([data-text-fill]),
        span.framer-text[data-nested-link],
        span.framer-text[data-nested-link] span.framer-text:not([data-text-fill]) {
            /* Ensure the color is inherited from the link style rather than the parent text for nested spans */
            color: inherit;
            font-family: var(--framer-font-family-preview, var(--framer-blockquote-font-family, var(--framer-link-font-family, var(--framer-font-family, Inter, Inter Placeholder, sans-serif))));
            font-style: var(--framer-font-style-preview, var(--framer-blockquote-font-style, var(--framer-link-font-style, var(--framer-font-style, normal))));
            font-weight: var(--framer-font-weight-preview, var(--framer-blockquote-font-weight, var(--framer-link-font-weight, var(--framer-font-weight, 400))));
            font-size: calc(var(--framer-blockquote-font-size, var(--framer-font-size, 16px)) * var(--framer-font-size-scale, 1));
            text-transform: var(--framer-blockquote-text-transform, var(--framer-link-text-transform, var(--framer-text-transform, none)));
            /* Cursor inherit to overwrite the user agent stylesheet on rich text links. */
            cursor: var(--framer-custom-cursors, pointer);
            /* Don't inherit background styles from any parent text style. */
            background-color: initial;
            border-radius: var(--framer-link-text-background-radius, initial);
            corner-shape: var(--framer-link-text-background-corner-shape, initial);
            padding: var(--framer-link-text-background-padding, initial);
        }
    `, `
        a.framer-text,
        span.framer-text[data-nested-link] {
            color: var(--framer-blockquote-text-color, var(--framer-link-text-color, var(--framer-text-color, #000)));
            text-decoration-line: var(--framer-blockquote-text-decoration, var(--framer-link-text-decoration, var(--framer-text-decoration, initial)));
            text-decoration-style: var(--framer-blockquote-text-decoration-style, var(--framer-link-text-decoration-style, var(--framer-text-decoration-style, initial)));
            text-decoration-color: var(--framer-blockquote-text-decoration-color, var(--framer-link-text-decoration-color, var(--framer-text-decoration-color, initial)));
            text-decoration-thickness: var(--framer-blockquote-text-decoration-thickness, var(--framer-link-text-decoration-thickness, var(--framer-text-decoration-thickness, initial)));
            text-decoration-skip-ink: var(--framer-blockquote-text-decoration-skip-ink, var(--framer-link-text-decoration-skip-ink, var(--framer-text-decoration-skip-ink, initial)));
            text-underline-offset: var(--framer-blockquote-text-decoration-offset, var(--framer-link-text-decoration-offset, var(--framer-text-decoration-offset, initial)));
            /* Don't inherit background styles from any parent text style. */
            background-color: var(--framer-link-text-background-color, initial);
        }
    `, `
        @supports not (color: color(display-p3 1 1 1)) {
            a.framer-text,
            span.framer-text[data-nested-link] {
                color: ${ja([`--framer-blockquote-text-color`, `--framer-link-text-color`, `--framer-text-color`], `#000`)};
                background-color: ${ja([`--framer-link-text-background-color`], `initial`)};
                text-decoration-color: ${ja([`--framer-link-text-decoration-color`, `--framer-text-decoration-color`], `currentcolor`)};
            }
        }
    `, `
    code.framer-text a.framer-text,
    code.framer-text a.framer-text span.framer-text:not([data-text-fill]),
    code.framer-text span.framer-text[data-nested-link],
    code.framer-text span.framer-text[data-nested-link] span.framer-text:not([data-text-fill]) {
        font-family: var(--framer-code-font-family, var(--framer-font-family, Inter, Inter Placeholder, sans-serif));
        font-style: var(--framer-blockquote-font-style, var(--framer-code-font-style, var(--framer-font-style, normal)));
        font-weight: var(--framer-blockquote-font-weight, var(--framer-code-font-weight, var(--framer-font-weight, 400)));
        color: inherit;
        font-size: calc(var(--framer-blockquote-font-size, var(--framer-font-size, 16px)) * var(--framer-font-size-scale, 1));
    }
`, `
    code.framer-text a.framer-text,
    code.framer-text span.framer-text[data-nested-link] {
        color: var(--framer-blockquote-text-color, var(--framer-link-text-color, var(--framer-code-text-color, var(--framer-text-color, #000))));
    }
`, `
    @supports not (color: color(display-p3 1 1 1)) {
        code.framer-text a.framer-text,
        code.framer-text a.framer-text span.framer-text:not([data-text-fill]),
        code.framer-text span.framer-text[data-nested-link],
        code.framer-text span.framer-text[data-nested-link] span.framer-text:not([data-text-fill]) {
            color: ${ja([`--framer-blockquote-text-color`, `--framer-link-text-color`, `--framer-code-text-color`, `--framer-text-color`], `#000`)};
        }
    }
`, `
        a.framer-text:hover,
        a.framer-text:hover span.framer-text:not([data-text-fill]),
        span.framer-text[data-nested-link]:hover,
        span.framer-text[data-nested-link]:hover span.framer-text:not([data-text-fill]) {
            font-family: var(--framer-font-family-preview, var(--framer-link-hover-font-family, var(--framer-blockquote-font-family, var(--framer-link-font-family, var(--framer-font-family, Inter, Inter Placeholder, sans-serif)))));
            font-style: var(--framer-font-style-preview, var(--framer-link-hover-font-style, var(--framer-blockquote-font-style, var(--framer-link-font-style, var(--framer-font-style, normal)))));
            font-weight: var(--framer-font-weight-preview, var(--framer-link-hover-font-weight, var(--framer-blockquote-font-weight, var(--framer-link-font-weight, var(--framer-font-weight, 400)))));
            font-size: calc(var(--framer-link-hover-font-size, var(--framer-blockquote-font-size, var(--framer-font-size, 16px))) * var(--framer-font-size-scale, 1));
            text-transform: var(--framer-link-hover-text-transform, var(--framer-blockquote-text-transform, var(--framer-link-text-transform, var(--framer-text-transform, none))));
            border-radius: var(--framer-link-hover-text-background-radius, var(--framer-link-text-background-radius, var(--framer-text-background-radius, initial)));
            corner-shape: var(--framer-link-hover-text-background-corner-shape, var(--framer-link-text-background-corner-shape, var(--framer-text-background-corner-shape, initial)));
            padding: var(--framer-link-hover-text-background-padding, var(--framer-link-text-background-padding, var(--framer-text-background-padding, initial)));
        }
    `, `
        a.framer-text:hover,
        span.framer-text[data-nested-link]:hover {
            color: var(--framer-link-hover-text-color, var(--framer-blockquote-text-color, var(--framer-link-text-color, var(--framer-text-color, #000))));
            text-decoration-line: var(--framer-link-hover-text-decoration, var(--framer-blockquote-text-decoration, var(--framer-link-text-decoration, var(--framer-text-decoration, initial))));
            text-decoration-style: var(--framer-link-hover-text-decoration-style, var(--framer-blockquote-text-decoration-style, var(--framer-link-text-decoration-style, var(--framer-text-decoration-style, initial))));
            text-decoration-color: var(--framer-link-hover-text-decoration-color, var(--framer-blockquote-text-decoration-color, var(--framer-link-text-decoration-color, var(--framer-text-decoration-color, initial))));
            text-decoration-thickness: var(--framer-link-hover-text-decoration-thickness, var(--framer-blockquote-text-decoration-thickness, var(--framer-link-text-decoration-thickness, var(--framer-text-decoration-thickness, initial))));
            text-decoration-skip-ink: var(--framer-link-hover-text-decoration-skip-ink, var(--framer-blockquote-text-decoration-skip-ink, var(--framer-link-text-decoration-skip-ink, var(--framer-text-decoration-skip-ink, initial))));
            text-underline-offset: var(--framer-link-hover-text-decoration-offset, var(--framer-blockquote-text-decoration-offset, var(--framer-link-text-decoration-offset, var(--framer-text-decoration-offset, initial))));
            background-color: var(--framer-link-hover-text-background-color, var(--framer-link-text-background-color, var(--framer-text-background-color, initial)));
        }
    `, `
    @supports not (color: color(display-p3 1 1 1)) {
        a.framer-text:hover,
        span.framer-text[data-nested-link]:hover {
            color: ${ja([`--framer-link-hover-text-color`, `--framer-blockquote-text-color`, `--framer-link-text-color`, `--framer-text-color`], `#000`)};
            background-color: ${ja([`--framer-link-hover-text-background-color`, `--framer-link-text-background-color`, `--framer-text-background-color`], `initial`)};
            text-decoration-color: ${ja([`--framer-link-hover-text-decoration-color`, `--framer-link-text-decoration-color`, `--framer-text-decoration-color`], `currentcolor`)};
        }
    }
    `, `
        code.framer-text a.framer-text:hover,
        code.framer-text span.framer-text[data-nested-link]:hover {
            color: var(--framer-link-hover-text-color, var(--framer-blockquote-text-color, var(--framer-link-text-color, var(--framer-code-text-color, var(--framer-text-color, #000)))));
        }
    `, `
    @supports not (color: color(display-p3 1 1 1)) {
        code.framer-text a.framer-text:hover,
        code.framer-text span.framer-text[data-nested-link]:hover {
            color: ${ja([`--framer-link-hover-text-color`, `--framer-blockquote-text-color`, `--framer-link-text-color`, `--framer-code-text-color`, `--framer-text-color`], `#000`)};
        }
    }
   `, `
        a.framer-text[data-framer-page-link-current],
        a.framer-text[data-framer-page-link-current] span.framer-text:not([data-text-fill]),
        span.framer-text[data-framer-page-link-current],
        span.framer-text[data-framer-page-link-current] span.framer-text:not([data-text-fill]) {
            font-family: var(--framer-font-family-preview, var(--framer-link-current-font-family, var(--framer-link-font-family, var(--framer-font-family, Inter, Inter Placeholder, sans-serif))));
            font-style: var(--framer-font-style-preview, var(--framer-link-current-font-style, var(--framer-link-font-style, var(--framer-font-style, normal))));
            font-weight: var(--framer-font-weight-preview, var(--framer-link-current-font-weight, var(--framer-link-font-weight, var(--framer-font-weight, 400))));
            font-size: calc(var(--framer-link-current-font-size, var(--framer-link-font-size, var(--framer-font-size, 16px))) * var(--framer-font-size-scale, 1));
            text-transform: var(--framer-link-current-text-transform, var(--framer-link-text-transform, var(--framer-text-transform, none)));
            border-radius: var(--framer-link-current-text-background-radius, var(--framer-link-text-background-radius, initial));
            corner-shape: var(--framer-link-current-text-background-corner-shape, var(--framer-link-text-background-corner-shape, initial));
            padding: var(--framer-link-current-text-background-padding, var(--framer-link-text-background-padding, initial));
        }
    `, `
        a.framer-text[data-framer-page-link-current],
        span.framer-text[data-framer-page-link-current] {
            color: var(--framer-link-current-text-color, var(--framer-link-text-color, var(--framer-text-color, #000)));
            text-decoration-line: var(--framer-link-current-text-decoration, var(--framer-link-text-decoration, var(--framer-text-decoration, initial)));
            text-decoration-style: var(--framer-link-current-text-decoration-style, var(--framer-link-text-decoration-style, var(--framer-text-decoration-style, initial)));
            text-decoration-color: var(--framer-link-current-text-decoration-color, var(--framer-link-text-decoration-color, var(--framer-text-decoration-color, initial)));
            text-decoration-thickness: var(--framer-link-current-text-decoration-thickness, var(--framer-link-text-decoration-thickness, var(--framer-text-decoration-thickness, initial)));
            text-decoration-skip-ink: var(--framer-link-current-text-decoration-skip-ink, var(--framer-link-text-decoration-skip-ink, var(--framer-text-decoration-skip-ink, initial)));
            text-underline-offset: var(--framer-link-current-text-decoration-offset, var(--framer-link-text-decoration-offset, var(--framer-text-decoration-offset, initial)));
            background-color: var(--framer-link-current-text-background-color, var(--framer-link-text-background-color, var(--framer-text-background-color, initial)));
        }
    `, `
        @supports not (color: color(display-p3 1 1 1)) {
            a.framer-text[data-framer-page-link-current],
            span.framer-text[data-framer-page-link-current]{
                color: ${ja([`--framer-link-current-text-color`, `--framer-link-text-color`, `--framer-text-color`], `#000`)};
                background-color: ${ja([`--framer-link-current-text-background-color`, `--framer-link-text-background-color`, `--framer-text-background-color`], `initial`)};
                text-decoration-color: ${ja([`--framer-link-current-text-decoration-color`, `--framer-link-text-decoration-color`, `--framer-text-decoration-color`], `currentcolor`)};
            }
        }
    `, `
        code.framer-text a.framer-text[data-framer-page-link-current],
        code.framer-text a.framer-text[data-framer-page-link-current] span.framer-text:not([data-text-fill]),
        code.framer-text span.framer-text[data-framer-page-link-current],
        code.framer-text span.framer-text[data-framer-page-link-current] span.framer-text:not([data-text-fill]) {
            font-family: var(--framer-code-font-family, var(--framer-font-family, Inter, Inter Placeholder, sans-serif));
            font-style: var(--framer-code-font-style, var(--framer-font-style, normal));
            font-weight: var(--framer-code-font-weight, var(--framer-font-weight, 400));
            color: inherit;
            font-size: calc(var(--framer-link-current-font-size, var(--framer-link-font-size, var(--framer-font-size, 16px))) * var(--framer-font-size-scale, 1));
        }
    `, `
        code.framer-text a.framer-text[data-framer-page-link-current],
        code.framer-text span.framer-text[data-framer-page-link-current] {
            color: var(--framer-link-current-text-color, var(--framer-link-text-color, var(--framer-code-text-color, var(--framer-text-color, #000))));
        }
    `, `
        @supports not (color: color(display-p3 1 1 1)) {
            code.framer-text a.framer-text[data-framer-page-link-current],
            code.framer-text a.framer-text[data-framer-page-link-current] span.framer-text:not([data-text-fill]),
            code.framer-text span.framer-text[data-framer-page-link-current],
            code.framer-text span.framer-text[data-framer-page-link-current] span.framer-text:not([data-text-fill]) {
                color: ${ja([`--framer-link-current-text-color`, `--framer-link-text-color`, `--framer-code-text-color`, `--framer-text-color`], `#000`)};
                background-color: ${ja([`--framer-link-current-text-background-color`, `--framer-link-text-background-color`, `--framer-text-background-color`], `initial`)};
            }
        }
    `, `
        a.framer-text[data-framer-page-link-current]:hover,
        a.framer-text[data-framer-page-link-current]:hover span.framer-text:not([data-text-fill]),
        span.framer-text[data-framer-page-link-current]:hover,
        span.framer-text[data-framer-page-link-current]:hover span.framer-text:not([data-text-fill]) {
            color: inherit;
            font-family: var(--framer-font-family-preview, var(--framer-link-hover-font-family, var(--framer-link-current-font-family, var(--framer-link-font-family, var(--framer-font-family, Inter, Inter Placeholder, sans-serif)))));
            font-style: var(--framer-font-style-preview, var(--framer-link-hover-font-style, var(--framer-link-current-font-style, var(--framer-link-font-style, var(--framer-font-style, normal)))));
            font-weight: var(--framer-font-weight-preview, var(--framer-link-hover-font-weight, var(--framer-link-current-font-weight, var(--framer-link-font-weight, var(--framer-font-weight, 400)))));
            font-size: calc(var(--framer-link-hover-font-size, var(--framer-link-current-font-size, var(--framer-link-font-size, var(--framer-font-size, 16px)))) * var(--framer-font-size-scale, 1));
            text-transform: var(--framer-link-hover-text-transform, var(--framer-link-current-text-transform, var(--framer-link-text-transform, var(--framer-text-transform, none))));
            border-radius: var(--framer-link-hover-text-background-radius, var(--framer-link-current-text-background-radius, var(--framer-link-text-background-radius, initial)));
            corner-shape: var(--framer-link-hover-text-background-corner-shape, var(--framer-link-current-text-background-corner-shape, var(--framer-link-text-background-corner-shape, initial)));
            padding: var(--framer-link-hover-text-background-padding, var(--framer-link-current-text-background-padding, var(--framer-link-text-background-padding, initial)));
        }
    `, `
        a.framer-text[data-framer-page-link-current]:hover,
        span.framer-text[data-framer-page-link-current]:hover {
            color: var(--framer-link-hover-text-color, var(--framer-link-current-text-color, var(--framer-link-text-color, var(--framer-text-color, #000))));
            text-decoration-line: var(--framer-link-hover-text-decoration, var(--framer-link-current-text-decoration, var(--framer-link-text-decoration, var(--framer-text-decoration, initial))));
            text-decoration-style: var(--framer-link-hover-text-decoration-style, var(--framer-link-current-text-decoration-style, var(--framer-link-text-decoration-style, var(--framer-text-decoration-style, initial))));
            text-decoration-color: var(--framer-link-hover-text-decoration-color, var(--framer-link-current-text-decoration-color, var(--framer-link-text-decoration-color, var(--framer-text-decoration-color, initial))));
            text-decoration-thickness: var(--framer-link-hover-text-decoration-thickness, var(--framer-link-current-text-decoration-thickness, var(--framer-link-text-decoration-thickness, var(--framer-text-decoration-thickness, initial))));
            text-decoration-skip-ink: var(--framer-link-hover-text-decoration-skip-ink, var(--framer-link-current-text-decoration-skip-ink, var(--framer-link-text-decoration-skip-ink, var(--framer-text-decoration-skip-ink, initial))));
            text-underline-offset: var(--framer-link-hover-text-decoration-offset, var(--framer-link-current-text-decoration-offset, var(--framer-link-text-decoration-offset, var(--framer-text-decoration-offset, initial))));
            background-color: var(--framer-link-hover-text-background-color, var(--framer-link-current-text-background-color, var(--framer-link-text-background-color, initial)));
        }
    `, `
        @supports not (color: color(display-p3 1 1 1)) {
            a.framer-text[data-framer-page-link-current]:hover,
            span.framer-text[data-framer-page-link-current]:hover {
                color: ${ja([`--framer-link-hover-text-color`, `--framer-link-current-text-color`, `--framer-link-text-color`, `--framer-code-text-color`, `--framer-text-color`], `#000`)};
                background-color: ${ja([`--framer-link-hover-text-background-color`, `--framer-link-current-text-background-color`, `--framer-link-text-background-color`], `initial`)};
                text-decoration-color: ${ja([`--framer-link-hover-text-decoration-color`, `--framer-link-current-text-decoration-color`, `--framer-link-text-decoration-color`, `--framer-text-decoration-color`], `currentcolor`)};
            }
        }
    `, `
        code.framer-text a.framer-text[data-framer-page-link-current]:hover,
        code.framer-text span.framer-text[data-framer-page-link-current]:hover {
            color: var(--framer-link-hover-text-color, var(--framer-link-current-text-color, var(--framer-link-text-color, var(--framer-code-text-color, var(--framer-text-color, #000)))));
        }
    `, `
        @supports not (color: color(display-p3 1 1 1)) {
            code.framer-text a.framer-text[data-framer-page-link-current]:hover,
            code.framer-text a.framer-text[data-framer-page-link-current]:hover span.framer-text:not([data-text-fill]),
            code.framer-text span.framer-text[data-framer-page-link-current]:hover,
            code.framer-text span.framer-text[data-framer-page-link-current]:hover span.framer-text:not([data-text-fill]) {
                color: ${ja([`--framer-link-hover-text-color`, `--framer-link-current-text-color`, `--framer-link-text-color`, `--framer-code-text-color`, `--framer-text-color`], `#000`)};
                background-color: ${ja([`--framer-link-hover-text-background-color`, `--framer-link-current-text-background-color`, `--framer-link-text-background-color`], `initial`)};
            }
        }
    `, `
        .framer-image.framer-text {
            display: ${ty.display};
            max-width: 100%;
            height: auto;
        }
    `, `
        .text-styles-preset-reset.framer-text {
            --framer-font-family: Inter, Inter Placeholder, sans-serif;
            --framer-font-style: normal;
            --framer-font-weight: 500;
            --framer-text-color: #000;
            --framer-font-size: 16px;
            --framer-letter-spacing: 0;
            --framer-text-transform: none;
            --framer-text-decoration: none;
            --framer-text-decoration-style: none;
            --framer-text-decoration-color: none;
            --framer-text-decoration-thickness: none;
            --framer-text-decoration-skip-ink: none;
            --framer-text-decoration-offset: none;
            --framer-line-height: 1.2em;
            --framer-text-alignment: start;
            --framer-font-open-type-features: normal;
            --framer-text-background-color: initial;
            --framer-text-background-radius: initial;
            --framer-text-background-corner-shape: initial;
            --framer-text-background-padding: initial;
        }
    `, `
        ol.framer-text {
            --list-style-type: decimal;
        }
    `, `
        ul.framer-text,
        ol.framer-text {
            padding-inline-start: 0;
            position: relative;
        }
    `, `
        li.framer-text {
            counter-increment: list-item;
            list-style: none;
            padding-inline-start: 2ch;
        }
    `, `
        ol.framer-text > li.framer-text::before {
            position: absolute;
            inset-inline-start: 0;
            content: counter(list-item, var(--list-style-type)) ".";
            font-variant-numeric: tabular-nums;
        }
    `, `
        ol.framer-text > li.framer-text:nth-last-child(n + 10),
        ol.framer-text > li.framer-text:nth-last-child(n + 10) ~ li {
            padding-inline-start: 3ch;
        }
    `, `
        ol.framer-text > li.framer-text:nth-last-child(n + 100),
        ol.framer-text > li.framer-text:nth-last-child(n + 100) ~ li {
            padding-inline-start: 4ch;
        }
    `, `
        ol.framer-text > li.framer-text:nth-last-child(n + 1000),
        ol.framer-text > li.framer-text:nth-last-child(n + 1000) ~ li {
            padding-inline-start: 5ch;
        }
    `, `
        ol.framer-text > li.framer-text:nth-last-child(n + 10000),
        ol.framer-text > li.framer-text:nth-last-child(n + 10000) ~ li {
            padding-inline-start: 6ch;
        }
    `, `
        ol.framer-text > li.framer-text:nth-last-child(n + 100000),
        ol.framer-text > li.framer-text:nth-last-child(n + 100000) ~ li {
            padding-inline-start: 7ch;
        }
    `, `
        ol.framer-text > li.framer-text:nth-last-child(n + 1000000),
        ol.framer-text > li.framer-text:nth-last-child(n + 1000000) ~ li {
            padding-inline-start: 8ch;
        }
    `, `
        ul.framer-text > li.framer-text::before {
            position: absolute;
            inset-inline-start: 0;
            content: "";
        }
    `, `
        .framer-table-wrapper {
            overflow-x: auto;
        }
    `, `
        table.framer-text,
        .framer-table-wrapper table.framer-text {
            border-collapse: separate;
            border-spacing: 0;
            table-layout: auto;
            word-break: normal;
            width: 100%;
        }
    `, `
        td.framer-text,
        th.framer-text {
            min-width: 16ch;
            vertical-align: top;
        }
    `, `
        ${Ma(`.framer-text-module[data-width="fill"]`, `:first-child`)},
        ${Ma(`.framer-text-module:not([data-width="fit"])[style*="aspect-ratio"]`, `:first-child`)} {
            width: 100% !important;
        }
    `, `
        @supports not (aspect-ratio: 1) {
            .framer-text-module:not([data-width="fit"])[style*="aspect-ratio"] {
                position: relative !important;
            }
        }
    `, `
        @supports not (aspect-ratio: 1) {
            .framer-text-module:not([data-width="fit"])[style*="aspect-ratio"]::before {
                content: "";
                display: block;
                padding-bottom: calc(100% / calc(var(--aspect-ratio)));
            }
        }
    `, `
        @supports not (aspect-ratio: 1) {
            ${Ma(`.framer-text-module[data-width="fill"]`, `:first-child`)},
            ${Ma(`.framer-text-module:not([data-width="fit"])[style*="aspect-ratio"]`, `:first-child`)} {
                position: absolute;
                top: 0;
                left: 0;
                height: 100% !important;
            }
        }
    `])(), ry = `--text-truncation-display-inline-for-safari-16`, iy = `--text-truncation-display-none-for-safari-16`, ay = `--text-truncation-line-break-for-safari-16`, oy = [`div.framer-text`, `p.framer-text`, `h1.framer-text`, `h2.framer-text`, `h3.framer-text`, `h4.framer-text`, `h5.framer-text`, `h6.framer-text`, `ol.framer-text`, `ul.framer-text`, `li.framer-text`, `blockquote.framer-text`, `.framer-text.framer-image`], sy = `(background: -webkit-named-image(i))`, cy = `(contain-intrinsic-size: inherit)`, ly = (() => [`@supports ${sy} and (not ${cy}) {
        /* Render block-like elements inline when text is truncated, otherwise default to user agent (revert)  */
        ${oy.join(`, `)} { display: var(${ry}, revert) }

        /* Add a line break after each block-like element that we render inline, to resemble the block-like behavior */
        ${oy.map(e => `${e}::after`).join(`, `)} { content: var(${ay}); white-space: pre; }

        /* Don't render modules (e.g. videos, code-blocks), or tables when text is truncated, because often these can't be truncated and their children might be block elements */
        .framer-text.framer-text-module,
        .framer-text.framer-table-wrapper { display: var(${iy}, revert) }

        /* Render text-fill elements inline when text is truncated, otherwise default to their default value (e.g. inline-block) */
        p.framer-text[data-text-fill] { display: var(${ry}, ${ey.display}) }
    }`])(), uy = [`[data-framer-component-type] { position: absolute; }`], dy = [`[data-framer-component-type="Text"] { cursor: inherit; }`, `[data-framer-component-text-autosized] * { white-space: pre; }`, `
[data-framer-component-type="Text"] > * {
    text-align: var(--framer-text-alignment, start);
}`, `
[data-framer-component-type="Text"] span span,
[data-framer-component-type="Text"] p span,
[data-framer-component-type="Text"] h1 span,
[data-framer-component-type="Text"] h2 span,
[data-framer-component-type="Text"] h3 span,
[data-framer-component-type="Text"] h4 span,
[data-framer-component-type="Text"] h5 span,
[data-framer-component-type="Text"] h6 span {
    display: block;
}`, `
[data-framer-component-type="Text"] span span span,
[data-framer-component-type="Text"] p span span,
[data-framer-component-type="Text"] h1 span span,
[data-framer-component-type="Text"] h2 span span,
[data-framer-component-type="Text"] h3 span span,
[data-framer-component-type="Text"] h4 span span,
[data-framer-component-type="Text"] h5 span span,
[data-framer-component-type="Text"] h6 span span {
    display: unset;
}`, `
[data-framer-component-type="Text"] div div span,
[data-framer-component-type="Text"] a div span,
[data-framer-component-type="Text"] span span span,
[data-framer-component-type="Text"] p span span,
[data-framer-component-type="Text"] h1 span span,
[data-framer-component-type="Text"] h2 span span,
[data-framer-component-type="Text"] h3 span span,
[data-framer-component-type="Text"] h4 span span,
[data-framer-component-type="Text"] h5 span span,
[data-framer-component-type="Text"] h6 span span,
[data-framer-component-type="Text"] a {
    font-family: var(--font-family);
    font-style: var(--font-style);
    font-weight: min(calc(var(--framer-font-weight-increase, 0) + var(--font-weight, 400)), 900);
    color: var(--text-color);
    letter-spacing: var(--letter-spacing);
    font-size: var(--font-size);
    text-transform: var(--text-transform);
    --text-decoration: var(--framer-text-decoration-style, solid) var(--framer-text-decoration, none) var(--framer-text-decoration-color, currentcolor) var(--framer-text-decoration-thickness, auto);
    --text-decoration-skip-ink: var(--framer-text-decoration-skip-ink);
    --text-underline-offset: var(--framer-text-decoration-offset);
    line-height: var(--line-height);
}`, `
[data-framer-component-type="Text"] div div span,
[data-framer-component-type="Text"] a div span,
[data-framer-component-type="Text"] span span span,
[data-framer-component-type="Text"] p span span,
[data-framer-component-type="Text"] h1 span span,
[data-framer-component-type="Text"] h2 span span,
[data-framer-component-type="Text"] h3 span span,
[data-framer-component-type="Text"] h4 span span,
[data-framer-component-type="Text"] h5 span span,
[data-framer-component-type="Text"] h6 span span,
[data-framer-component-type="Text"] a {
    --font-family: var(--framer-font-family);
    --font-style: var(--framer-font-style);
    --font-weight: var(--framer-font-weight);
    --text-color: var(--framer-text-color);
    --letter-spacing: var(--framer-letter-spacing);
    --font-size: var(--framer-font-size);
    --text-transform: var(--framer-text-transform);
    --text-decoration: var(--framer-text-decoration-style, solid) var(--framer-text-decoration, none) var(--framer-text-decoration-color, currentcolor) var(--framer-text-decoration-thickness, auto);
    --text-decoration-skip-ink: var(--framer-text-decoration-skip-ink);
    --text-underline-offset: var(--framer-text-decoration-offset);
    --line-height: var(--framer-line-height);
}`, `
[data-framer-component-type="Text"] a,
[data-framer-component-type="Text"] a div span,
[data-framer-component-type="Text"] a span span span,
[data-framer-component-type="Text"] a p span span,
[data-framer-component-type="Text"] a h1 span span,
[data-framer-component-type="Text"] a h2 span span,
[data-framer-component-type="Text"] a h3 span span,
[data-framer-component-type="Text"] a h4 span span,
[data-framer-component-type="Text"] a h5 span span,
[data-framer-component-type="Text"] a h6 span span {
    --font-family: var(--framer-link-font-family, var(--framer-font-family));
    --font-style: var(--framer-link-font-style, var(--framer-font-style));
    --font-weight: var(--framer-link-font-weight, var(--framer-font-weight));
    --text-color: var(--framer-link-text-color, var(--framer-text-color));
    --font-size: var(--framer-link-font-size, var(--framer-font-size));
    --text-transform: var(--framer-link-text-transform, var(--framer-text-transform));
    --text-decoration: var(--framer-link-text-decoration-style, var(--framer-text-decoration-style, solid)) var(--framer-link-text-decoration, var(--framer-text-decoration, none)) var(--framer-link-text-decoration-color, var(--framer-text-decoration-color, currentcolor)) var(--framer-link-text-decoration-thickness, var(--framer-text-decoration-thickness, auto));
    --text-decoration-skip-ink: var(--framer-link-text-decoration-skip-ink, var(--framer-text-decoration-skip-ink));
    --text-underline-offset: var(--framer-link-text-decoration-offset, var(--framer-text-decoration-offset));
}`, `
[data-framer-component-type="Text"] a:hover,
[data-framer-component-type="Text"] a div span:hover,
[data-framer-component-type="Text"] a span span span:hover,
[data-framer-component-type="Text"] a p span span:hover,
[data-framer-component-type="Text"] a h1 span span:hover,
[data-framer-component-type="Text"] a h2 span span:hover,
[data-framer-component-type="Text"] a h3 span span:hover,
[data-framer-component-type="Text"] a h4 span span:hover,
[data-framer-component-type="Text"] a h5 span span:hover,
[data-framer-component-type="Text"] a h6 span span:hover {
    --font-family: var(--framer-link-hover-font-family, var(--framer-link-font-family, var(--framer-font-family)));
    --font-style: var(--framer-link-hover-font-style, var(--framer-link-font-style, var(--framer-font-style)));
    --font-weight: var(--framer-link-hover-font-weight, var(--framer-link-font-weight, var(--framer-font-weight)));
    --text-color: var(--framer-link-hover-text-color, var(--framer-link-text-color, var(--framer-text-color)));
    --font-size: var(--framer-link-hover-font-size, var(--framer-link-font-size, var(--framer-font-size)));
    --text-transform: var(--framer-link-hover-text-transform, var(--framer-link-text-transform, var(--framer-text-transform)));
    --text-decoration: var(--framer-link-hover-text-decoration-style, var(--framer-link-text-decoration-style, var(--framer-text-decoration-style, solid))) var(--framer-link-hover-text-decoration, var(--framer-link-text-decoration, var(--framer-text-decoration, none))) var(--framer-link-hover-text-decoration-color, var(--framer-link-text-decoration-color, var(--framer-text-decoration-color, currentcolor))) var(--framer-link-hover-text-decoration-thickness, var(--framer-link-text-decoration-thickness, var(--framer-text-decoration-thickness, auto)));
    --text-decoration-skip-ink: var(--framer-link-hover-text-decoration-skip-ink, var(--framer-link-text-decoration-skip-ink, var(--framer-text-decoration-skip-ink)));
    --text-underline-offset: var(--framer-link-hover-text-decoration-offset, var(--framer-link-text-decoration-offset, var(--framer-text-decoration-offset)));
}`, `
[data-framer-component-type="Text"].isCurrent a,
[data-framer-component-type="Text"].isCurrent a div span,
[data-framer-component-type="Text"].isCurrent a span span span,
[data-framer-component-type="Text"].isCurrent a p span span,
[data-framer-component-type="Text"].isCurrent a h1 span span,
[data-framer-component-type="Text"].isCurrent a h2 span span,
[data-framer-component-type="Text"].isCurrent a h3 span span,
[data-framer-component-type="Text"].isCurrent a h4 span span,
[data-framer-component-type="Text"].isCurrent a h5 span span,
[data-framer-component-type="Text"].isCurrent a h6 span span {
    --font-family: var(--framer-link-current-font-family, var(--framer-link-font-family, var(--framer-font-family)));
    --font-style: var(--framer-link-current-font-style, var(--framer-link-font-style, var(--framer-font-style)));
    --font-weight: var(--framer-link-current-font-weight, var(--framer-link-font-weight, var(--framer-font-weight)));
    --text-color: var(--framer-link-current-text-color, var(--framer-link-text-color, var(--framer-text-color)));
    --font-size: var(--framer-link-current-font-size, var(--framer-link-font-size, var(--framer-font-size)));
    --text-transform: var(--framer-link-current-text-transform, var(--framer-link-text-transform, var(--framer-text-transform)));
    --text-decoration: var(--framer-link-current-text-decoration-style, var(--framer-link-text-decoration-style, var(--framer-text-decoration-style, solid))) var(--framer-link-current-text-decoration, var(--framer-link-text-decoration, var(--framer-text-decoration, none))) var(--framer-link-current-text-decoration-color, var(--framer-link-text-decoration-color, var(--framer-text-decoration-color, currentcolor))) var(--framer-link-current-text-decoration-thickness, var(--framer-link-text-decoration-thickness, var(--framer-text-decoration-thickness, auto)));
    --text-decoration-skip-ink: var(--framer-link-current-text-decoration-skip-ink, var(--framer-link-text-decoration-skip-ink, var(--framer-text-decoration-skip-ink)));
    --text-underline-offset: var(--framer-link-current-text-decoration-offset, var(--framer-link-text-decoration-offset, var(--framer-text-decoration-offset)));
}`], fy = `
:not([data-framer-generated]) > [data-framer-stack-content-wrapper] > *,
:not([data-framer-generated]) > [data-framer-stack-content-wrapper] > [data-framer-component-type],
:not([data-framer-generated]) > [data-framer-stack-content-wrapper] > [data-framer-legacy-stack-gap-enabled] > *,
:not([data-framer-generated]) > [data-framer-stack-content-wrapper] > [data-framer-legacy-stack-gap-enabled] > [data-framer-component-type] {
    position: relative;
}`, py = (() => [`[data-framer-stack-content-wrapper][data-framer-stack-gap-enabled="true"] {
        row-gap: var(--stack-native-row-gap);
        column-gap: var(--stack-native-column-gap);
    }`, `.${Iv} [data-framer-stack-content-wrapper][data-framer-stack-gap-enabled="true"] {
        row-gap: unset;
        column-gap: unset;
    }`])(), my = (() => `
.${Iv} [data-framer-legacy-stack-gap-enabled="true"] > *, [data-framer-legacy-stack-gap-enabled="true"][data-framer-stack-flexbox-gap="false"] {
    margin-top: calc(var(--stack-gap-y) / 2);
    margin-bottom: calc(var(--stack-gap-y) / 2);
    margin-right: calc(var(--stack-gap-x) / 2);
    margin-left: calc(var(--stack-gap-x) / 2);
}
`)(), hy = (() => `
.${Iv}
[data-framer-stack-direction-reverse="false"]
[data-framer-legacy-stack-gap-enabled="true"]
> *:first-child,
[data-framer-stack-direction-reverse="false"]
[data-framer-legacy-stack-gap-enabled="true"][data-framer-stack-flexbox-gap="false"]
> *:first-child,
.${Iv}
[data-framer-stack-direction-reverse="true"]
[data-framer-legacy-stack-gap-enabled="true"]
> *:last-child,
[data-framer-stack-direction-reverse="true"]
[data-framer-legacy-stack-gap-enabled="true"][data-framer-stack-flexbox-gap="false"]
> *:last-child {
    margin-top: 0;
    margin-left: 0;
}`)(), gy = (() => `
.${Iv}
[data-framer-stack-direction-reverse="false"]
[data-framer-legacy-stack-gap-enabled="true"]
> *:last-child,
[data-framer-stack-direction-reverse="false"]
[data-framer-legacy-stack-gap-enabled="true"][data-framer-stack-flexbox-gap="false"]
> *:last-child,
.${Iv}
[data-framer-stack-direction-reverse="true"]
[data-framer-legacy-stack-gap-enabled="true"]
> *:first-child,
[data-framer-stack-direction-reverse="true"]
[data-framer-legacy-stack-gap-enabled="true"][data-framer-stack-flexbox-gap="false"]
> *:first-child {
    margin-right: 0;
    margin-bottom: 0;
}`)(), _y = (() => [fy, my, ...py, hy, gy])(), vy = [`
NavigationContainer
[data-framer-component-type="NavigationContainer"] > *,
[data-framer-component-type="NavigationContainer"] > [data-framer-component-type] {
    position: relative;
}`], yy = [`[data-framer-component-type="Scroll"]::-webkit-scrollbar { display: none; }`, `[data-framer-component-type="ScrollContentWrapper"] > * { position: relative; }`], by = [`[data-framer-component-type="NativeScroll"] { -webkit-overflow-scrolling: touch; }`, `[data-framer-component-type="NativeScroll"] > * { position: relative; }`, `[data-framer-component-type="NativeScroll"].direction-both { overflow-x: auto; overflow-y: auto; }`, `[data-framer-component-type="NativeScroll"].direction-vertical { overflow-x: hidden; overflow-y: auto; }`, `[data-framer-component-type="NativeScroll"].direction-horizontal { overflow-x: auto; overflow-y: hidden; }`, `[data-framer-component-type="NativeScroll"].direction-vertical > * { width: 100% !important; }`, `[data-framer-component-type="NativeScroll"].direction-horizontal > * { height: 100% !important; }`, `[data-framer-component-type="NativeScroll"].scrollbar-hidden::-webkit-scrollbar { display: none; }`], xy = [`[data-framer-component-type="DeviceComponent"].no-device > * { width: 100% !important; height: 100% !important; }`], Sy = [`[data-framer-component-type="PageContentWrapper"] > *, [data-framer-component-type="PageContentWrapper"] > [data-framer-component-type] { position: relative; }`], Cy = [`[data-is-present="false"], [data-is-present="false"] * { pointer-events: none !important; }`], wy = [`.framer-lightbox-container { opacity: 1 !important; pointer-events: auto !important; }`], Ty = [`[data-framer-cursor="pointer"] { cursor: pointer; }`, `[data-framer-cursor="grab"] { cursor: grab; }`, `[data-framer-cursor="grab"]:active { cursor: grabbing; }`], Ey = [`[data-framer-component-type="Frame"] *, [data-framer-component-type="Stack"] * { pointer-events: auto; }`, `[data-framer-generated] * { pointer-events: unset }`], Dy = [`[data-reset="button"] {
        border-width: 0;
        padding: 0;
        background: none;
}`], Oy = [`[data-hide-scrollbars="true"]::-webkit-scrollbar { width: 0px; height: 0px; }`, `[data-hide-scrollbars="true"]::-webkit-scrollbar-thumb { background: transparent; }`, `[data-hide-scrollbars="true"] { scrollbar-width: none; }`], ky = `--framer-will-change-override`, Ay = `--framer-will-change-effect-override`, jy = `--framer-will-change-filter-override`, My = `(background: -webkit-named-image(i))`, Ny = `(grid-template-rows: subgrid)`, Py = `(position-area: top right)`, Fy = e => e ? [`body { ${ky}: none; }`, `@supports ${My} and (not ${Ny}) { body { ${ky}: transform; } }`] : [`body { ${ky}: none; ${Ay}: none; }`], Iy = e => e ? [`body { ${jy}: none; }`, `@supports ${My} and (not ${Py}) { body { ${jy}: filter; } }`] : [`body { ${jy}: none; }`], Ly = e => e ? Ey : [], Ry = [`.svgContainer svg { display: block; }`], zy = `--overflow-clip-fallback`, By = (() => [`@supports (not (overflow: clip)) {
        :root { ${zy}: hidden; }
    }`])(), Vy = `--one-if-corner-shape-supported`, Hy = (() => [`@supports (corner-shape: superellipse(2)) { :root { ${Vy}: 1 } }`])(), Uy = e => [...Fy(e), ...Iy(e), ...uy, ...dy, ...ny, ...Rv, ..._y, ...vy, ...yy, ...by, ...Sy, ...xy, ...Cy, ...Ty, ...Ly(e), ...Ry, ...Dy, ...Oy, ...By, ...wy, ...ly, ...Hy], Wy = Uy(!1), Gy = Uy(!0), Ky = `optional`, qy = e => e, Jy = /^(?:children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|download|draggable|encType|enterKeyHint|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|[dkrxyz]|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y1|y2|yChannelSelector|zoomAndPan|for|class|autofocus|(?:[Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*)$/u, Yy = Ga(e => Jy.test(e) || e.charCodeAt(0) === 111 && e.charCodeAt(1) === 110 && e.charCodeAt(2) < 91), Xy = e => () => { Vr(e) }, Zy = () => () => { }, Qy = { imagePlaceholderSvg: `<svg xmlns="http://www.w3.org/2000/svg" width="126" height="126"><path id="a" d="M126 0v21.584L21.584 126H0v-17.585L108.415 0H126Zm0 108.414V126h-17.586L126 108.414Zm0-84v39.171L63.585 126H24.414L126 24.414Zm0 42v39.17L105.584 126h-39.17L126 66.414ZM105.586 0 0 105.586V66.415L66.415 0h39.171Zm-42 0L0 63.586V24.415L24.415 0h39.171Zm-42 0L0 21.586V0h21.586Z" fill="rgb(136, 136, 136, 0.2)" fill-rule="evenodd"/></svg>`, useImageSource(e) { return e.src ?? `` }, useImageElement(e, t, n) { let r = eb.useImageSource(e, t, n); return b(() => { let t = new Image; return t.src = r, e.srcSet && (t.srcset = e.srcSet), t }, [r, e.srcSet]) }, canRenderOptimizedCanvasImage() { return !1 }, isOnPageCanvas: !1 }, $y = !1, eb = new Proxy(Qy, { get(e, t, n) { return Reflect.has(e, t) ? Reflect.get(e, t, n) : [`getLogger`].includes(String(t)) ? Zy() : Xy($y ? `${String(t)} is not available in this version of Framer.` : `${String(t)} is only available inside of Framer. https://www.framer.com/`) } }), tb = { borderRadius: `inherit`, cornerShape: `inherit` }, nb = [1, 2, 2.2], rb = [512, 1024, 2048, 4096], ib = 512, ab = (() => ({ position: `absolute`, ...tb, top: 0, right: 0, bottom: 0, left: 0 }))(), ob = `src`, sb = { isImageObject: function (e) { return !e || typeof e == `string` ? !1 : typeof e == `object` && ob in e } }, cb = ha(), lb = typeof document < `u` ? A : s, ub = p.createContext(!1), db = class { constructor() { M(this, `sharedResizeObserver`), M(this, `callbacks`, new WeakMap), this.sharedResizeObserver = new ResizeObserver(this.updateResizedElements.bind(this)) } updateResizedElements(e) { for (let t of e) { let e = this.callbacks.get(t.target); e && e(t.contentRect) } } observeElementWithCallback(e, t) { this.sharedResizeObserver.observe(e), this.callbacks.set(e, t) } unobserve(e) { this.sharedResizeObserver.unobserve(e), this.callbacks.delete(e) } }, fb = (() => va() ? new db : void 0)(), pb = `data-framer-size-compatibility-wrapper`, mb = `0.000001px`, hb = (() => ` translateZ(${mb})`)(), gb = (() => ya() || ga() || ba())(), _b = (() => { class e extends h { constructor() { super(...arguments), M(this, `layerElement`, null), M(this, `setLayerElement`, e => { this.layerElement = e }) } static applyWillChange(e, t, n) { e.willChangeTransform && (n ? Eo(t) : Do(t)) } shouldComponentUpdate(e, t) { return e._needsMeasure || this.state !== t || !Ct(this.props, e) } componentDidUpdate(e) { qy(this.props).clip && qy(this.props).radius === 0 && qy(e).radius !== 0 && ko(this.layerElement, `overflow`, `hidden`, !1) } } return M(e, `defaultProps`, {}), e })(), vb = e => { let t = 0, n, r; if (e.length === 0) return t; for (n = 0; n < e.length; n++)r = e.charCodeAt(n), t = (t << 5) - t + r, t |= 0; return t }, yb = { hueRotate: (e, t) => q.toHslString(q.hueRotate(q(e), t)), setAlpha: (e, t) => q.toRgbString(q.alpha(q(e), t)), getAlpha: e => { let t = pi(e); return t ? t.a : 1 }, multiplyAlpha: (e, t) => q.toRgbString(q.multiplyAlpha(q(e), t)), toHexValue: e => q.toHex(q(e)).toUpperCase(), toHex: e => q.toHexString(q(e)).toUpperCase(), toRgb: e => q.toRgb(q(e)), toRgbString: e => q.toRgbString(q(e)), toHSV: e => q.toHsv(q(e)), toHSL: e => q.toHsl(q(e)), toHslString: e => q.toHslString(q(e)), toHsvString: e => q.toHsvString(q(e)), hsvToHSLString: e => q.toHslString(q(ti(e.h, e.s, e.v, e.a))), hsvToHexValue: e => q.toHex(q(ti(e.h, e.s, e.v, e.a))).toUpperCase(), hsvToHex: e => q.toHexString(q(ti(e.h, e.s, e.v, e.a))).toUpperCase(), hsvToRgbString: e => q.toRgbString(q(ti(e.h, e.s, e.v, e.a))), hsvToString: e => ti(e.h, e.s, e.v), rgbaToString: e => q.toRgbString(q(e)), rgbToHexValue: e => q.toHex(q(e)), rgbToHexString: e => q.toHexString(q(e)), hslToString: e => q.toHslString(q(e)), hslToRgbString: e => q.toRgbString(q(e)), toColorPickerSquare: e => q.toRgbString(q({ h: e, s: 1, l: .5, a: 1 })), isValid: e => q(e).isValid !== !1, equals: (e, t) => q.isP3String(e) || q.isP3String(t) ? e === t : (typeof e == `string` && (e = q(e)), typeof t == `string` && (t = q(t)), q.equal(e, t)), toHexOrRgbaString: e => { let t = q(e); return t.a === 1 ? q.toHexString(t) : q.toRgbString(t) }, toFormatString: e => q.isP3String(e) ? e : q.toRgbString(q(e)) }, bb = /var\(.+\)/u, xb = new Map, Sb = [`stops`], Cb = [`start`, `end`], wb = [`angle`, `alpha`], Tb = { isLinearGradient: e => z(e) && wb.every(t => t in e) && (Lo(e) || Io(e)), hash: e => e.angle ^ Fo(e, e.alpha), toCSS: (e, t, n) => { let r = Po(e, e.alpha), i = t === void 0 ? e.angle : t; return `linear-gradient(${Math.round(i)}deg, ${r.map(e => `${n?.(e.value) ?? e.value} ${e.position * 100}%`).join(`, `)})` } }, Eb = [`widthFactor`, `heightFactor`, `centerAnchorX`, `centerAnchorY`, `alpha`], Db = { isRadialGradient: e => z(e) && Eb.every(t => t in e) && (Lo(e) || Io(e)), hash: e => e.centerAnchorX ^ e.centerAnchorY ^ e.widthFactor ^ e.heightFactor ^ Fo(e, e.alpha), toCSS: (e, t) => { let { alpha: n, widthFactor: r, heightFactor: i, centerAnchorX: a, centerAnchorY: o } = e, s = Po(e, n), c = s.map((e, n) => { let r = s[n + 1], i = e.position === 1 && r?.position === 1 ? e.position - 1e-4 : e.position; return `${t?.(e.value) ?? e.value} ${i * 100}%` }); return `radial-gradient(${r * 100}% ${i * 100}% at ${a * 100}% ${o * 100}%, ${c.join(`, `)})` } }, Ob = [`onClick`, `onDoubleClick`, `onMouse`, `onMouseDown`, `onMouseUp`, `onTapDown`, `onTap`, `onTapUp`, `onPointer`, `onPointerDown`, `onPointerUp`, `onTouch`, `onTouchDown`, `onTouchUp`], kb = (() => new Set([...Ob, ...Ob.map(e => `${e}Capture`)]))(), Ab = `overflow`, jb = { x: 0, y: 0, width: 200, height: 200 }, Mb = new Set([`width`, `height`, `opacity`, `overflow`, `radius`, `background`, `color`, `x`, `y`, `z`, `rotate`, `rotateX`, `rotateY`, `rotateZ`, `scale`, `scaleX`, `scaleY`, `skew`, `skewX`, `skewY`, `originX`, `originY`, `originZ`]), Nb = v(function (e, n) { let { name: r, center: i, border: a, _border: o, __portal: s } = e, { props: l, children: u } = go(e), d = Jo(l), f = vo(e), p = Uo(e), h = c(null), g = n ?? h, _ = { "data-framer-component-type": e.componentType ?? `Frame`, "data-framer-cursor": p, "data-framer-highlight": p === `pointer` ? !0 : void 0, "data-layoutid": f, "data-framer-offset-parent-id": qy(e)[`data-framer-offset-parent-id`] }; !Yo(e) && r && (qy(_)[`data-framer-name`] = r); let [v, y] = qo(l), b = Ko(l), x = la(b); i && !(y && !x && Zi(b)) ? (d.transformTemplate ||= _o(i), Object.assign(_, mo(i))) : d.transformTemplate ||= void 0, wo(e, g); let C = lo(e), w = Xo(l, b, y, t(ub)), T = sa(S(E, { children: [C ? m(ao, { alt: e.alt ?? ``, image: C, containerSize: y ?? void 0, nodeId: e.id && ho(e.id), layoutId: f }) : null, u, m(so, { ...o, border: a, layoutId: f })] }), w), D = fo(e.as), O = uo(C); return e.fitImageDimension && O && (v[e.fitImageDimension] = `auto`, v.aspectRatio = O.width / O.height), S(D, { ..._, ...d, layoutId: f, style: v, ref: g, children: [T, s] }) }), Pb = Pa(v(function (e, t) { let { visible: n = !0 } = e; return n ? m(Nb, { ...e, ref: t }) : null })), Fb = `__LAYOUT_TREE_ROOT`, Ib = p.createContext({ schedulePromoteTree: () => { }, scheduleProjectionDidUpdate: () => { }, initLead: () => { } }), Lb = class extends h { constructor() { super(...arguments), M(this, `shouldAnimate`, !1), M(this, `transition`), M(this, `lead`), M(this, `follow`), M(this, `scheduledPromotion`, !1), M(this, `scheduledDidUpdate`, !1), M(this, `scheduleProjectionDidUpdate`, () => { this.scheduledDidUpdate = !0 }), M(this, `schedulePromoteTree`, (e, t, n) => { this.follow = this.lead, this.shouldAnimate = n, this.lead = e, this.transition = t, this.scheduledPromotion = !0 }), M(this, `initLead`, (e, t) => { this.follow = this.lead, this.lead = e, this.follow && t && (this.follow.layoutMaybeMutated = !0) }), M(this, `sharedLayoutContext`, { schedulePromoteTree: this.schedulePromoteTree, scheduleProjectionDidUpdate: this.scheduleProjectionDidUpdate, initLead: this.initLead }) } getSnapshotBeforeUpdate() { if (!this.scheduledPromotion || !this.lead || !this.follow) return null; let e = this.lead?.layoutMaybeMutated && !this.shouldAnimate; return this.lead.projectionNodes.forEach(t => { t?.promote({ needsReset: e, transition: this.shouldAnimate ? this.transition : void 0, preserveFollowOpacity: t.options.layoutId === Fb && !this.follow?.isExiting }) }), this.shouldAnimate ? this.follow.layoutMaybeMutated = !0 : this.scheduleProjectionDidUpdate(), this.lead.layoutMaybeMutated = !1, this.transition = void 0, this.scheduledPromotion = !1, null } componentDidUpdate() { if (!this.lead) return null; this.scheduledDidUpdate &&= (this.lead.rootProjectionNode?.root?.didUpdate(), !1) } render() { return m(Ib.Provider, { value: this.sharedLayoutContext, children: this.props.children }) } }, Rb = { width: `100%`, height: `100%`, backgroundColor: `none` }, zb = class { constructor(e) { M(this, `sharedIntersectionObserver`), M(this, `callbacks`, new WeakMap), this.sharedIntersectionObserver = new IntersectionObserver(this.intersectionObserverCallback.bind(this), e) } intersectionObserverCallback(e, t) { for (let n of e) { let e = this.callbacks.get(n.target); e && e(n, t) } } observeElementWithCallback(e, t) { this.sharedIntersectionObserver && (this.sharedIntersectionObserver.observe(e), this.callbacks.set(e, t)) } unobserve(e) { this.sharedIntersectionObserver && (this.sharedIntersectionObserver.unobserve(e), this.callbacks.delete(e)) } get root() { return this.sharedIntersectionObserver?.root } }, Bb = a(new Map), Vb = typeof IntersectionObserver > `u` ? kh : is, Hb = Array(100).fill(void 0).map((e, t) => t * .01), Ub = p.createContext(null), Wb = class extends h { constructor() { super(...arguments), M(this, `layoutMaybeMutated`, !1), M(this, `projectionNodes`, new Map), M(this, `rootProjectionNode`), M(this, `isExiting`), M(this, `shouldPreserveFollowOpacity`, e => e.options.layoutId === Fb && !this.props.isExiting), M(this, `switchLayoutGroupContext`, { register: e => this.addChild(e), deregister: e => this.removeChild(e), transition: this.props.isLead !== void 0 && this.props.animatesLayout ? this.props.transition : void 0, shouldPreserveFollowOpacity: this.shouldPreserveFollowOpacity }) } componentDidMount() { this.props.isLead && this.props.sharedLayoutContext.initLead(this, !!this.props.animatesLayout) } shouldComponentUpdate(e) { let { isLead: t, isExiting: n, isOverlayed: r, animatesLayout: i, transition: a, sharedLayoutContext: o } = e; if (this.isExiting = n, t === void 0) return !0; let s = !this.props.isLead && t, c = this.props.isExiting && !n, l = s || c, u = !!this.props.isLead && !t, d = this.props.isOverlayed !== r; return (l || u) && this.projectionNodes.forEach(e => e?.willUpdate()), l ? o.schedulePromoteTree(this, a, !!i) : d && o.scheduleProjectionDidUpdate(), !!l && !!i } addChild(e) { let t = e.options.layoutId; t && (this.projectionNodes.set(t, e), this.setRootChild(e)) } setRootChild(e) { if (!this.rootProjectionNode) return this.rootProjectionNode = e; this.rootProjectionNode = this.rootProjectionNode.depth < e.depth ? this.rootProjectionNode : e } removeChild(e) { let t = e.options.layoutId; t && this.projectionNodes.delete(t) } render() { return m(Ne.Provider, { value: this.switchLayoutGroupContext, children: this.props.children }) } }, Gb = e => { let t = p.useContext(Ib); return m(Wb, { ...e, sharedLayoutContext: t }) }, Kb = p.createContext(!0), qb = a({ register: () => { }, deregister: () => { } }), Jb = ({ isCurrent: e, isOverlayed: t, children: n }) => { let r = ls(), i = c({ register: o(e => { if (r.has(e)) { console.warn(`NavigationTargetWrapper: already registered`); return } r.set(e, void 0) }, [r]), deregister: o(e => { r.get(e)?.(), r.delete(e) }, [r]) }).current; return s(() => (r.forEach((n, i) => { let a = i(e, t); r.set(i, Ye(a) ? a : void 0) }), () => { r.forEach((e, t) => { e && (e(), r.set(t, void 0)) }) }), [e, t, r]), m(qb.Provider, { value: i, children: n }) }, Yb = p.memo(function ({ isLayeredContainer: e, isCurrent: n, isPrevious: r, isOverlayed: i = !1, visible: a, transitionProps: o, children: l, backdropColor: u, onTapBackdrop: d, backfaceVisible: f, exitBackfaceVisible: p, animation: h, exitAnimation: g, instant: _, initialProps: v, exitProps: y, position: b = { top: 0, right: 0, bottom: 0, left: 0 }, withMagicMotion: x, index: C, areMagicMotionLayersPresent: w, id: T, isInitial: E }) { let D = fe(), O = t(we), { persistLayoutIdCache: k } = t($_), A = c({ wasCurrent: void 0, wasPrevious: !1, wasBeingRemoved: !1, wasReset: !0, origins: fs({}, v, o) }), ee = c(null), j = O !== null && !O.isPresent; n && A.current.wasCurrent === void 0 && k(), s(() => { if (e || !D) return; if (j) { A.current = { ...A.current, wasBeingRemoved: j }; return } let { wasPrevious: t, wasCurrent: i } = A.current, a = n && !i || !j && A.current.wasBeingRemoved && n, s = r && !t, c = fs(A.current.origins, v, o), l = A.current.wasReset; a || s ? (D.stop(), D.start({ zIndex: C, ...c, ...o }), l = !1) : l === !1 && (D.stop(), D.set({ zIndex: C, ...Xb, opacity: 0 }), l = !0), A.current = { wasCurrent: !!n, wasPrevious: !!r, wasBeingRemoved: !1, wasReset: l, origins: c } }, [n, r, j]); let M = _ ? { type: !1 } : `velocity` in h ? { ...h, velocity: 0 } : h, te = _ ? { type: !1 } : g || h, ne = { ...b }; (ne.left === void 0 || ne.right === void 0) && (ne.width = `auto`), (ne.top === void 0 || ne.bottom === void 0) && (ne.height = `auto`); let N = (ps(o) || ps(v)) && (e || n || r) ? 1200 : void 0, re = { ...Xb, ...A.current.origins }, ie = e ? { initial: { ...re, ...v }, animate: { ...re, ...o, transition: M }, exit: { ...re, ...y, transition: h } } : { animate: D, exit: { ...re, ...y, transition: te } }, ae = !(j || w === !1), oe = !!n && ae, se = n && E; return S(Pb, { "data-framer-component-type": `NavigationContainerWrapper`, width: `100%`, height: `100%`, style: { position: `absolute`, transformStyle: `flat`, backgroundColor: `transparent`, overflow: `hidden`, zIndex: e || j || n && x ? C : void 0, pointerEvents: void 0, visibility: a ? `visible` : `hidden`, perspective: N }, children: [e && m(Pb, { width: `100%`, height: `100%`, "data-framer-component-type": `NavigationContainerBackdrop`, transition: h, initial: { opacity: _ && a ? 1 : 0 }, animate: { opacity: 1 }, exit: { opacity: 0 }, backgroundColor: u || `transparent`, onTap: j ? void 0 : d }), m(Pb, { ...ne, ...ie, transition: { default: M, originX: { type: !1 }, originY: { type: !1 }, originZ: { type: !1 } }, backgroundColor: `transparent`, backfaceVisible: j ? p : f, "data-framer-component-type": `NavigationContainer`, "data-framer-is-current-navigation-target": !!n, style: { pointerEvents: void 0, opacity: se || e || n && x ? 1 : 0 }, "data-is-present": ae ? void 0 : !1, ref: ee, children: m(Ub.Provider, { value: ee, children: m(Kb.Provider, { value: oe, children: m(Jb, { isCurrent: oe, isOverlayed: i, children: m(Gb, { isLead: n, animatesLayout: !!x, transition: M, isExiting: !ae, isOverlayed: i, id: T, children: l }) }) }) }) })] }) }, ds), Xb = { x: 0, y: 0, z: 0, rotate: 0, rotateX: 0, rotateY: 0, rotateZ: 0, scale: 1, scaleX: 1, scaleY: 1, scaleZ: 1, skew: 0, skewX: 0, skewY: 0, originX: .5, originY: .5, originZ: 0, opacity: 1 }, Zb = class { constructor() { M(this, `warning`, () => { Vr(`The Navigator API is only available inside of Framer: https://www.framer.com/`) }), M(this, `goBack`, () => this.warning()), M(this, `instant`, () => this.warning()), M(this, `fade`, () => this.warning()), M(this, `push`, () => this.warning()), M(this, `modal`, () => this.warning()), M(this, `overlay`, () => this.warning()), M(this, `flip`, () => this.warning()), M(this, `customTransition`, () => this.warning()), M(this, `magicMotion`, () => this.warning()) } }, Qb = a(new Zb), $b = { Fade: { exit: { opacity: 0 }, enter: { opacity: 0 } }, PushLeft: { exit: { x: `-30%` }, enter: { x: `100%` } }, PushRight: { exit: { x: `30%` }, enter: { x: `-100%` } }, PushUp: { exit: { y: `-30%` }, enter: { y: `100%` } }, PushDown: { exit: { y: `30%` }, enter: { y: `-100%` } }, Instant: { animation: { type: !1 }, enter: { opacity: 0 } }, Modal: { overCurrentContext: !0, goBackOnTapOutside: !0, position: { center: !0 }, enter: { opacity: 0, scale: 1.2 } }, OverlayLeft: { overCurrentContext: !0, goBackOnTapOutside: !0, position: { right: 0, top: 0, bottom: 0 }, enter: { x: `100%` } }, OverlayRight: { overCurrentContext: !0, goBackOnTapOutside: !0, position: { left: 0, top: 0, bottom: 0 }, enter: { x: `-100%` } }, OverlayUp: { overCurrentContext: !0, goBackOnTapOutside: !0, position: { bottom: 0, left: 0, right: 0 }, enter: { y: `100%` } }, OverlayDown: { overCurrentContext: !0, goBackOnTapOutside: !0, position: { top: 0, left: 0, right: 0 }, enter: { y: `-100%` } }, FlipLeft: { backfaceVisible: !1, exit: { rotateY: -180 }, enter: { rotateY: 180 } }, FlipRight: { backfaceVisible: !1, exit: { rotateY: 180 }, enter: { rotateY: -180 } }, FlipUp: { backfaceVisible: !1, exit: { rotateX: 180 }, enter: { rotateX: -180 } }, FlipDown: { backfaceVisible: !1, exit: { rotateX: -180 }, enter: { rotateX: 180 } }, MagicMotion: { withMagicMotion: !0 } }, ex = () => ({ current: -1, previous: -1, currentOverlay: -1, previousOverlay: -1, visualIndex: 0, overlayItemId: 0, historyItemId: 0, history: [], overlayStack: [], containers: {}, containerIndex: {}, containerVisualIndex: {}, containerIsRemoved: {}, transitionForContainer: {}, previousTransition: null }), tx = Lh(Xb), nx = p.createContext(void 0), rx = p.createContext(void 0), ix = (() => { var e, t, n, r, i, a, o; return t = class extends h { constructor(t) { super(t), be(this, n), be(this, e, null), M(this, `state`, ex()), be(this, a, e => { if (!this.props.enabled && this.state.history.length > 0) return; let t = _s(this.state, e); if (!t) return; let { skipLayoutAnimation: n } = this.props, r = t.history[t.current], i = e.type === `add` && e.transition.withMagicMotion || e.type === `forward` && r?.transition.withMagicMotion || e.type === `remove` && !!t.previousTransition, a = () => { this.setState(t), r?.key && this.context?.(r.key) }; n && !i ? n(a) : a() }), M(this, `goBack`, () => { if (!xe(this, n, i).call(this)) return he(this, e, globalThis.event?.timeStamp || null), this.state.currentOverlay === -1 ? F(this, a).call(this, { type: `remove` }) : F(this, a).call(this, { type: `removeOverlay` }) }); let r = this.props.children; if (!r || !Bi(r) || !zi(r)) return; let o = { ...$b.Instant }, s = { type: `add`, key: r.key?.toString() || `stack-${this.state.historyItemId + 1}`, transition: o, component: r }, c = _s(this.state, s); c && (this.state = c) } componentDidMount() { let e = this.state.history[this.state.current]; e && this.context?.(e.key) } UNSAFE_componentWillReceiveProps(e) { let t = e.children; if (!Bi(t) || !zi(t)) return; let r = t.key?.toString(); r && (this.state.history.length === 0 ? xe(this, n, o).call(this, t, $b.Instant) : F(this, a).call(this, { type: `update`, key: r, component: t })) } componentWillUnmount() { this.props.resetProjection?.() } instant(e) { xe(this, n, o).call(this, e, $b.Instant, void 0) } fade(e, t) { xe(this, n, o).call(this, e, $b.Fade, t) } push(e, t) { xe(this, n, o).call(this, e, ms(t), t) } modal(e, t) { xe(this, n, o).call(this, e, $b.Modal, t) } overlay(e, t) { xe(this, n, o).call(this, e, hs(t), t) } flip(e, t) { xe(this, n, o).call(this, e, gs(t), t) } magicMotion(e, t) { xe(this, n, o).call(this, e, $b.MagicMotion, t) } customTransition(e, t) { xe(this, n, o).call(this, e, t) } render() { let e = xe(this, n, r).call(this, { overCurrentContext: !1 }), t = xe(this, n, r).call(this, { overCurrentContext: !0 }), i = Ms(t), a = t.current > -1, o = this.state.history.length === 1, s = []; for (let [t, n] of Object.entries(this.state.containers)) { let r = this.state.containerIndex[t]; B(r !== void 0, `Container's index must be registered`); let i = this.state.containerVisualIndex[t]; B(i !== void 0, `Container's visual index must be registered`); let c = this.state.containerIsRemoved[t], l = this.state.history[r], u = this.state.transitionForContainer[t], d = r === this.state.current, f = r === this.state.previous, p = d ? !1 : c, h = l?.transition?.withMagicMotion || d && !!this.state.previousTransition; s.push(m(Yb, { id: t, index: i, isInitial: o, isCurrent: d, isPrevious: f, isOverlayed: a, visible: d || f, position: l?.transition?.position, instant: Hs(r, e), transitionProps: u, animation: Vs(r, e), backfaceVisible: zs(r, e), exitAnimation: l?.transition?.animation, exitBackfaceVisible: l?.transition?.backfaceVisible, exitProps: l?.transition?.enter, withMagicMotion: h, areMagicMotionLayersPresent: p ? !1 : void 0, children: m(Zo, { children: Ws({ component: n, transition: l?.transition }) }) }, t)) } let c = this.state.overlayStack.map((e, n) => m(Yb, { isLayeredContainer: !0, isCurrent: n === this.state.currentOverlay, position: e.transition.position, initialProps: Rs(n, t), transitionProps: Bs(n, t), instant: Hs(n, t, !0), animation: Vs(n, t), exitProps: e.transition.enter, visible: Us(n, t), backdropColor: Is(e.transition), backfaceVisible: Ls(n, t), onTapBackdrop: Gs(e.transition, this.goBack), index: this.state.current + 1 + n, children: Ws({ component: e.component, transition: e.transition }) }, e.key)); return m(Pb, { "data-framer-component-type": `NavigationRoot`, top: 0, left: 0, width: `100%`, height: `100%`, position: `relative`, style: { overflow: `hidden`, backgroundColor: `unset`, pointerEvents: void 0, ...this.props.style }, children: m(Qb.Provider, { value: this, children: S(rx.Provider, { value: o, children: [m(Yb, { isLayeredContainer: !0, position: void 0, initialProps: {}, instant: !1, transitionProps: Ns(i), animation: Ps(i), backfaceVisible: Fs(i), visible: !0, backdropColor: void 0, onTapBackdrop: void 0, index: 0, children: m(Mi, { children: m(Lb, { children: m(Fe, { presenceAffectsLayout: !1, children: s }) }) }) }), m(Fe, { children: c })] }) }) }) } }, e = new WeakMap, n = new WeakSet, r = function (e) { let { current: t, previous: n, currentOverlay: r, previousOverlay: i } = this.state; return e.overCurrentContext ? { current: r, previous: i, history: this.state.overlayStack } : { current: t, previous: n, history: this.state.history } }, i = function () { return globalThis.event ? F(this, e) === globalThis.event.timeStamp : !1 }, a = new WeakMap, o = function (t, r, o) { if (xe(this, n, i).call(this) || (he(this, e, globalThis.event?.timeStamp || null), !t || !Bi(t) || !zi(t))) return; let s = { ...r, ...o }; if (s.overCurrentContext) return F(this, a).call(this, { type: `addOverlay`, transition: s, component: t }); let c = t.key?.toString() || `stack-${this.state.historyItemId + 1}`; F(this, a).call(this, { type: `add`, key: c, transition: s, component: t }) }, M(t, `defaultProps`, { enabled: !0 }), M(t, `contextType`, nx), t })(), ax = { stiffness: 500, damping: 50, restDelta: 1, type: `spring` }, ox = Pa(Ks), He(Dh(), 1), He(Dh(), 1), He(Dh(), 1), sx = (e, t) => Object.prototype.hasOwnProperty.call(e, t), cx = Symbol(`private`), lx = (() => { function e(e = {}, t = !1, n = !0) { let r = { [cx]: { makeAnimatables: t, observeAnimatables: n, observers: new D_, reset() { for (let t in i) if (sx(i, t)) { let n = sx(e, t) ? qy(e)[t] : void 0; n === void 0 ? delete i[t] : i[t] = n } }, transactions: new Set } }, i = new Proxy(r, dx); return Object.assign(i, e), i } return e.resetObject = e => e[cx].reset(), e.addObserver = (e, t) => e[cx].observers.add(t), e })(), ux = class { constructor() { M(this, `set`, (e, t, n, r) => { if (t === cx) return !1; let i = e[cx], a, o; if (Ur(n) ? (a = n, o = a.get()) : o = n, i.makeAnimatables && typeof n != `function` && typeof n != `object` && !a && (a = O_(n)), i.observeAnimatables && a) { let e = i.transactions; a.onUpdate({ update: (t, n) => { n && e.add(n), i.observers.notify({ value: r }, n) }, finish: t => { e.delete(t) && i.observers.finishTransaction(t) } }) } let s = !1, c = !0, l = qy(e)[t]; if (l !== void 0) { Ur(l) ? (c = l.get() !== o, l.set(o)) : (c = l !== o, qy(e)[t] = o); let n = typeof o == `object` && !!o; (Array.isArray(o) || n) && (c = !0), s = !0 } else a && (n = a), s = Reflect.set(e, t, n); return c && i.observers.notify({ value: r }), s }), M(this, `get`, (e, t, n) => { if (t === cx) return qy(e)[t]; let r = Reflect.get(e, t, n); return typeof r == `function` ? r.bind(n) : r }) } deleteProperty(e, t) { let n = Reflect.deleteProperty(e, t); return e[cx].observers.notify({ value: e }), n } ownKeys(e) { let t = Reflect.ownKeys(e), n = t.indexOf(cx); return n !== -1 && t.splice(n, 1), t } getOwnPropertyDescriptor(e, t) { if (t !== cx) return Reflect.getOwnPropertyDescriptor(e, t) } }, dx = new ux, fx = `opacity`, px = (() => { function e(t = {}) { let n = lx(t, !1, !1); return e.addData(n), n } return e._stores = [], e.addData = t => { e._stores.push(t) }, e.reset = () => { e._stores.forEach(e => lx.resetObject(e)) }, e.addObserver = (e, t) => lx.addObserver(e, t), e })(), mx = { update: 0 }, hx = p.createContext({ update: NaN }), gx = class extends h { constructor() { super(...arguments), M(this, `observers`, []), M(this, `state`, mx), M(this, `taskAdded`, !1), M(this, `frameTask`, () => { this.setState({ update: this.state.update + 1 }), this.taskAdded = !1 }), M(this, `observer`, () => { this.taskAdded || (this.taskAdded = !0, X_.addFrameTask(this.frameTask)) }) } componentWillUnmount() { this.observers.map(e => e()), px.reset() } render() { let { children: e } = this.props; return this.observers.map(e => e()), this.observers = [], px._stores.forEach(e => { let t = px.addObserver(e, this.observer); this.observers.push(t) }), m(hx.Provider, { value: { ...this.state }, children: e }) } }, He(Dh(), 1), _x = `__framer__`, vx = (() => _x.length)(), yx = p.createContext(void 0), bx = p.createContext(void 0), xx = `ssr-variant`, Sx = () => () => { }, Cx = () => !0, wx = () => !1, Tx = p.forwardRef(function (e, t) { let n = oc(t), r = p.useContext(bx), i = p.useSyncExternalStore(Sx, wx, Cx), a = Fi(() => i ? va() ? 1 : 2 : 0), o = p.useContext(yx); return dr(() => { let { breakpoint: t, overrides: i, children: s, ...c } = e; if (!o) return console.warn(`PropertyOverrides is missing GeneratedComponentContext`), n(s, c); let { primaryVariantId: l, variantClassNames: u } = o, d = r?.primaryVariantId === l ? r?.variants : void 0; switch (a) { case 0: return n(s, mc(t, c, i)); case 1: return lc(i, s, c, u, l, d, n, t); case 2: return lc(i, s, c, u, l, d, ac, void 0); default: V(a) } }, [o, r, n, e]) }), Ex = (() => Mv(Tx, `.${xx} { display: contents }`, `PropertyOverrides`))(), Dx = `default`, Ox = new Set([Dx]), Ax = class { constructor() { M(this, `entries`, new Map), be(this, kx, {}) } set(e, t, n, r) { switch (t) { case `transformTemplate`: B(typeof n == `string`, `transformTemplate must be a string, received: ${n}`), this.setHash(e, r, { transformTemplate: n, legacy: !0 }); break; case `initial`: case `animate`: B(typeof n == `object`, `${t} must be a valid object, received: ${n}`), this.setHash(e, r, { [t]: n, legacy: !0 }); break; default: break } } setHash(e, t = Dx, n) { let r = this.entries.get(e) ?? {}, i = r[t] ?? {}; r[t] = n === null ? null : { ...i, ...n }, this.entries.set(e, r) } variantHash(e, t) { if (e === t?.primaryVariantId) return Dx; let n = F(this, kx)[e]; if (n) return n; let r = t?.variantClassNames[e]; return r ? F(this, kx)[e] = uc(r) : Dx } setAll(e, t = Ox, n, r) { if (n === null) { for (let n of t) this.setHash(e, this.variantHash(n, r), null); return } let i = Ye(n.transformTemplate) ? n.transformTemplate?.({}, Mx) : void 0, a = n.__framer__presenceInitial ?? n.initial, o = n.__framer__presenceAnimate ?? n.animate, s = { initial: z(a) ? a : void 0, animate: z(o) ? o : void 0, transformTemplate: L(i) ? i : void 0 }; for (let n of t) this.setHash(e, this.variantHash(n, r), s) } clear() { this.entries.clear() } toObject() { return Object.fromEntries(this.entries) } }, kx = new WeakMap, jx = new Ax, Mx = `__Appear_Animation_Transform__`, Nx = `data-framer-appear-id`, Px = `data-framer-appear-animation`, Fx = e => { if (Ua()) return { animate: gc(e.animate) ? e.animate : void 0, initial: gc(e.initial) ? e.initial : void 0, exit: void 0 } }, Ix = [`opacity`, `x`, `y`, `scale`, `rotate`, `rotateX`, `rotateY`, `skewX`, `skewY`, `transformPerspective`], Lx = e => ({ x: N(e?.x ?? 0), y: N(e?.y ?? 0), opacity: N(e?.opacity ?? 1), scale: N(e?.scale ?? 1), rotate: N(e?.rotate ?? 0), rotateX: N(e?.rotateX ?? 0), rotateY: N(e?.rotateY ?? 0), skewX: N(e?.skewX ?? 0), skewY: N(e?.skewY ?? 0), transformPerspective: N(e?.transformPerspective ?? 0) }), Rx = { x: 0, y: 0, scale: 1, opacity: 1, rotate: 0, rotateX: 0, rotateY: 0, skewX: 0, skewY: 0, transformPerspective: 0 }, zx = { willChange: `transform` }, Object.freeze(zx), Bx = {}, Object.freeze(Bx), Vx = new Set([`loopEffectEnabled`, `loopTransition`, `loop`, `loopRepeatType`, `loopRepeatDelay`, `loopPauseOffscreen`]), Hx = () => { let e = c(); return s(() => () => { clearTimeout(e.current) }, []), async t => new Promise(n => { e.current = setTimeout(() => { n(!0) }, t * 1e3) }) }, Ux = new Set([`speed`, `adjustPosition`, `offset`, `parallaxTransformEnabled`]), Wx = new Set([`presenceInitial`, `presenceAnimate`, `presenceExit`]), Gx = 1, Kx = 4, qx = new Set([`threshold`, `animateOnce`, `opacity`, `targetOpacity`, `x`, `y`, `scale`, `transition`, `rotate`, `rotateX`, `rotateY`, `perspective`, `enter`, `exit`, `animate`, `styleAppearEffectEnabled`, `targets`, `scrollDirection`]), Jx = [`animate`, `animate`], Yx = { inputRange: [], outputRange: [] }, Xx = new Set([`transformViewportThreshold`, `styleTransformEffectEnabled`, `transformTargets`, `spring`, `transformTrigger`]), Zx = (e, t) => { let n = e?.[0]?.target; return t ? { opacity: n?.opacity ?? 1 } : n }, Qx = () => ({ opacity: [], x: [], y: [], scale: [], rotate: [], rotateX: [], rotateY: [], skewX: [], skewY: [], transformPerspective: [] }), $x = [0, 1], eS = { parallax: Ux, styleAppear: qx, styleTransform: Xx, loop: Vx, presence: Wx }, tS = Lh(eS), nS = e => e.reduce((e, t) => e += t, 0), rS = e => e.reduce((e, t) => e *= t, 1), iS = `current`, aS = e => p.forwardRef((t, n) => { if (t.__withFX) return m(e, { ...t, animate: void 0, initial: void 0, exit: void 0, ref: n }); let r = Fx(t); if (r) return m(e, { ...t, ...r, ref: n }); let { parallax: i = {}, styleAppear: a = {}, styleTransform: o = {}, presence: s = {}, loop: c = {}, forwardedProps: l, targetOpacityValue: u, withPerspective: d, inSmartComponent: f = !1 } = zc(t), h = ts(n), { values: g, style: _ } = Tc(s, h, f, t.style, t[Ge]), { values: v, style: y } = xc(i, h, t.style?.visibility), { values: b, style: x } = Lc(o, h), { values: S, style: C } = Nc(a, h), { values: w, style: T } = yc(c, h), E = p.useMemo(() => { let e = new Ve(u ?? 1); return { scale: [S.scale, w.scale, g.scale, b.scale], opacity: [S.opacity, w.opacity, g.opacity, e, b.opacity], x: [S.x, w.x, g.x, b.x], y: [S.y, w.y, v.y, g.y, b.y], rotate: [S.rotate, w.rotate, g.rotate, b.rotate], rotateX: [S.rotateX, w.rotateX, g.rotateX, b.rotateX], rotateY: [S.rotateY, w.rotateY, g.rotateY, b.rotateY], skewX: [S.skewX, w.skewX, g.skewX, b.skewX], skewY: [S.skewY, w.skewY, g.skewY, b.skewY], transformPerspective: [b.transformPerspective, S.transformPerspective] } }, [u, b, v, S, w, g]); Vc(t.style, E); let D = _e(E.scale, rS), O = _e(E.opacity, rS), k = _e(E.x, nS), A = _e(E.y, nS), ee = _e(E.rotate, nS), j = _e(E.rotateX, nS), M = _e(E.rotateY, nS), te = _e(E.skewX, nS), ne = _e(E.skewY, nS), N = _e(E.transformPerspective, nS), { drag: re, dragConstraints: ie } = l; bo(re && Bc(ie) ? ie : void 0); let ae = { opacity: O, scale: D, x: k, y: A, rotate: ee, rotateX: j, rotateY: M, skewX: te, skewY: ne }; $e(d) && (ae.transformPerspective = N); let oe = Hc(t.animate) ? t.animate : void 0, se = Hc(t.initial) ? t.initial : void 0, ce = Hc(t.exit) ? t.exit : void 0, le = f && !s.presenceInitial ? { initial: se, animate: oe, exit: ce } : {}; return m(e, { ...l, ...le, __withFX: !0, style: { ...t.style, ...y, ...x, ...T, ...ae, ...C, ..._ }, values: g, ref: h }) }), oS = a({}), sS = p.createContext({}), cS = p.forwardRef(function ({ width: e, height: t, y: n, children: r, ...i }, a) { let o = p.useMemo(() => ({ width: e, height: t, y: n }), [e, t, n]), s = oc(a); return m(sS.Provider, { value: o, children: s(r, i) }) }), lS = e => p.forwardRef((t, n) => m(e, { layoutId: vo(t), ...t, layoutIdKey: void 0, duplicatedFrom: void 0, ref: n })), uS = !1, dS = class extends h {
        constructor() { super(...arguments), M(this, `state`, { error: void 0 }) } static getDerivedStateFromError(e) { return { error: e } } componentDidCatch(e, t) {
            if (!Kc(e)) return; let n = t?.componentStack; console.error(`Caught an error in SynchronousSuspenseErrorBoundary:

`, e, `

Component stack:
`, n, `

This error indicates a state update wasnt wrapped with \`startTransition\`. Some of the UI might flash as a result. `+ st(`If you are the author of this website, update external components and check recently added custom code or code overrides.`)); let r = e instanceof Error && typeof e.stack == `string` ? e.stack : void 0; Zt(`published_site_load_recoverable_error`, { message: String(e), stack: r, componentStack: r ? void 0 : n })
        } render() { let e = this.state.error; if (e === void 0) return this.props.children; if (!Kc(e)) throw e; return uS = !0, this.props.children }
    }, fS = (() => n === void 0 ? null : new Promise(() => { }))(), pS = m(qc, {}), mS = a(!1), mS.displayName = `DisableSuspenseSuspenseThatPreservesDomContext`, hS = m(Yc, {}), gS = class extends h { constructor() { super(...arguments), M(this, `state`, { hasError: !1 }) } static getDerivedStateFromError() { return { hasError: !0 } } componentDidCatch(e, t) { Zc(this.props.getErrorMessage(), t?.componentStack), Xc(e, t) } render() { let { children: e, fallback: t = hS } = this.props, { hasError: n } = this.state; return n ? t : e } }, _S = class extends h { constructor() { super(...arguments), M(this, `state`, { hasError: !1 }) } componentDidCatch(e, t) { let n = t?.componentStack; console.error(`Error in component (see previous log). This component has been hidden. Please check any custom code or code overrides to fix.`, n), this.setState({ hasError: !0 }), Xc(e, t) } render() { let { children: e } = this.props, { hasError: t } = this.state; return t ? null : e } }, vS = (() => p.createContext(void 0))(), yS = `code-crash:`, bS = lS(p.forwardRef(function ({ children: e, layoutId: t, as: n, scopeId: r, nodeId: i, isAuthoredByUser: a, isModuleExternal: o, inComponentSlot: s, ...c }, l) { let u = Fi(() => t ? `${t}-container` : void 0), d = fo(n), f = dl(p.Children.map(e, e => p.isValidElement(e) ? p.cloneElement(e, { layoutId: t }) : e), r, i, a, o, s); return m(d, { layoutId: u, ...c, ref: l, children: m(ub.Provider, { value: !0, children: m(Wg.Provider, { value: i ?? null, children: m(Pi, { enabled: !1, children: m(Be, { id: t ?? ``, inherit: c.layout ? !0 : `id`, children: f }) }) }) }) }) })), xS = p.forwardRef(function (e, t) { let { as: n, children: r, scopeId: i, nodeId: a, isAuthoredByUser: o, rendersWithMotion: s, isModuleExternal: c, inComponentSlot: l, ...u } = e, d = dl(r, i, a, o, c, l), f = e.as ?? `div`; if (e.rendersWithMotion) { let n = fo(f); return m(Wg.Provider, { value: a ?? null, children: m(n, { ...u, ref: t, style: e.style, children: d }) }) } else { let n = f, { layoutId: r, layoutDependency: i, ...o } = u; return m(Wg.Provider, { value: a ?? null, children: m(n, { ...o, ref: t, style: e.style, children: d }) }) } }), SS = a({ onRegisterCursors: () => () => { }, registerCursors: () => { } }), CS = `framer-cursor-none`, wS = `framer-pointer-events-none`, TS = C(function ({ children: e }) { let t = Fi(() => { let e = new Set, t = {}, n = new Map; return { onRegisterCursors: n => (n(t), e.add(n), () => e.delete(n)), registerCursors: (r, i) => { n.set(i, Object.keys(r)), t = fl(n, t, r); for (let n of e) n(t); return () => { n.delete(i) } } } }), n = Je(); return S(SS.Provider, { value: t, children: [e, !n && m(kS, {})] }) }), ES = (() => Mv(TS, [`.${CS}, .${CS} * { cursor: none !important; }`, `.${wS}, .${wS} * { pointer-events: none !important; }`], `framer-lib-cursors-host`))(), DS = (() => ({ position: `fixed`, top: 0, left: 0, zIndex: 13, pointerEvents: `none` }))(), OS = `data-framer-portal-id`, kS = C(function () { let { onRegisterCursors: e } = t(SS), [n, r] = i(!1), a = ce(0), l = ce(0), u = ce(0), d = c(null), f = c({ cursors: {}, cursorHash: void 0 }), p = yo(); A(() => { let e = K.matchMedia(`(any-hover: none)`); function t(e) { e.matches ? _(() => r(!1)) : r(!0) } return e.addEventListener(`change`, t), e.matches || r(!0), () => { e.removeEventListener(`change`, t) } }, []), s(() => { if (!n) return; let e = 0, t = 0; function r() { a.set(e), l.set(t), De(u, 1, { type: `tween`, duration: .2 }) } let i = () => { if (Qe(f.current.cursors)) return; let n = gl(e, t); n !== f.current.cursorHash && (f.current.cursorHash = n, ke.update(() => p())) }; function o(n) { if (n.pointerType === `touch`) { Pe(i); return } ke.read(i, !0), e = n.clientX, t = n.clientY, ke.update(r) } function s(e) { if (e.target === d.current || !d.current) return; let t = new PointerEvent(e.type, { bubbles: !0, cancelable: e.cancelable, pointerType: e.pointerType, pointerId: e.pointerId, composed: e.composed, isPrimary: e.isPrimary, buttons: e.buttons, button: e.button }); ke.update(() => { d.current?.dispatchEvent(t) }) } return K.addEventListener(`pointermove`, o), document.addEventListener(`pointerdown`, s), document.addEventListener(`pointerup`, s), ke.read(i, !0), () => { K.removeEventListener(`pointermove`, o), document.removeEventListener(`pointerdown`, s), document.removeEventListener(`pointerup`, s), Pe(i) } }, [u, a, l, p, n]), s(() => { if (!n) return; function e() { De(u, 0, { type: `tween`, duration: .2 }) } return document.addEventListener(`mouseleave`, e), K.addEventListener(`blur`, e), () => { document.removeEventListener(`mouseleave`, e), K.removeEventListener(`blur`, e) } }, [u, n]), A(() => { function t(e) { f.current.cursors = e, f.current.cursorHash = Qe(e) ? null : gl(a.get(), l.get()), p() } let n = e(t); return () => { n(), document.body.classList.toggle(CS, !1) } }, [a, l, e, p]); let { cursors: h, cursorHash: g } = f.current, v = g ? h[g] : null, y = pl(v); A(() => { n && document.body.classList.toggle(CS, y) }, [y, n]); let b = v?.component, x = v?.transition ?? { duration: 0 }, S = se(a, x), C = se(l, x), w = _e(() => S.get() + (v?.offset?.x ?? 0)), E = _e(() => C.get() + (v?.offset?.y ?? 0)), D = v?.alignment, O = v?.placement, k = o((e, t) => `translate(${hl(O, D)}) ${t}`, [D, O]); return !n || !v || !b ? null : m(T, { children: m(b, { transformTemplate: k, style: { ...DS, x: w, y: E, opacity: u }, globalTapTarget: !0, variant: v?.variant, ref: d, className: wS }) }) }), AS = `webPageId`, jS = class { constructor() { M(this, `collectedLinks`, new Map), M(this, `nestingInfo`, new Map) } clear() { this.collectedLinks.clear(), this.nestingInfo.clear() } getLinks() { let e = new Map; for (let [t, n] of this.nestingInfo) { let r = this.collectedLinks.get(t); B(r, `Outer link not found: ${t}`); let i = Array.from(n).map(e => { let t = this.collectedLinks.get(e); return B(t, `Inner link not found: ${e}`), t }); e.set(r, i) } return e } collectNestedLink(e, t) { if (Ah && !ba() || !e.nodeId || !t.nodeId) return; this.collectedLinks.set(yl(e), e), this.collectedLinks.set(yl(t), t); let n = this.nestingInfo.get(yl(e)) ?? new Set; n.add(yl(t)), this.nestingInfo.set(yl(e), n) } }, MS = new jS, NS = `element`, PS = `collection`, FS = `collectionItemId`, IS = `pathVariables`, LS = `framer/page-link,`, RS = a(void 0), zS = `--text-selection-color`, BS = `--text-selection-background-color`, VS = (() => Mv(Ll, (e, t) => Il(t?.triggerId), `InjectSelectionStyle`))(), HS = `overlay`, US = `template-overlay`, WS = class extends h { constructor() { super(...arguments), M(this, `state`, { error: void 0 }), M(this, `message`, `Made UI non-interactive due to an error.`), M(this, `messageFatal`, `Fatal error.`) } static getDerivedStateFromError(e) { return { error: e } } componentDidCatch(e) { if (n.__framer_hadFatalError = !0, `cause` in e && (e = e.cause), console.error(st(jh ? this.message : this.messageFatal, e)), Math.random() > .5) return; let t = e instanceof Error && typeof e.stack == `string` ? e.stack : null; Zt(`published_site_load_error`, { message: String(e), stack: t }) } render() { let e = this.state.error; if (!e) return this.props.children; let t = `cause` in e ? e.cause : e, n = /-->/gu, r = jh && document.getElementById(`main`)?.innerHTML || ``; return m(`div`, { style: { display: `contents` }, suppressHydrationWarning: !0, dangerouslySetInnerHTML: { __html: `<!-- DOM replaced by GracefullyDegradingErrorBoundary due to "${t.message.replace(n, `--!>`)}". ${st()}: --><!-- Stack: ${e.stack?.replace(n, `--!>`)} -->` + r } }) } }, GS = /:([a-z]\w*)/gi, KS = a(void 0), qS = 500, JS = .9, YS = 1.7, XS = 4, ZS = 1 / 0, QS = new WeakMap, $S = new Set, eC = new Map, tC = !_g || typeof IntersectionObserver > `u` ? null : Kl(), nC = Bl(v(function ({ children: e, href: t, openInNewTab: n, smoothScroll: r, clickTrackingId: i, relValues: a, preserveParams: o, nodeId: s, scopeId: c, motionChild: l, ...u }, d) { let f = Et(), p = Ot(), m = Wl(), { activeLocale: h, locales: _ } = pr(), v = eu(), y = hn(), x = bl(), S = tu({ nodeId: s, clickTrackingId: i, router: f, href: t, activeLocale: h }), C = b(() => { if (!t) return {}; let e = vl(t) ? t : Dl(t); if (!e) return {}; if (L(e)) return au(e, f, p, { openInNewTab: n, trackLinkClick: S, rel: a?.join(` `), preserveParams: o, smoothScroll: r }, y, h?.id, _, m); let { unresolvedPathSlugs: i, unresolvedHashSlugs: s } = e, c = v(i, s, h); if (at(c)) throw c; let { routeId: l, href: u, elementId: d, pathVariables: g, locale: b } = Vl(f, p, e, h, c, m), x = Jl(n, !0), C = x === `_blank`, w = { pathVariables: g, locale: b }, T = e => ru(f, l, () => y(l, w, !1, !C), d, g, r, e); return { href: u, target: x, onClick: iu(u, S, T), "data-framer-page-link-current": p && Gl(p, e, m) || void 0, navigate: T, preload: () => y(l, w, !0, !C), _routeId: l, _pathVariables: g, _locale: b } }, [t, f, h, m, n, p, r, S, a, _, o, v, y]), w = ts(g(e) && `ref` in e ? e.ref : void 0), { navigate: T, preload: E, _routeId: D, _pathVariables: O, _locale: k, ...A } = C; ns(w, e => { if (!(e === null || !D || !E || x)) return tC?.(e, E, `${D}:${k?.id}:${JSON.stringify(O)}`) }, [E, D, O, k]); let ee = !!T; return Al(oc(d).cloneAsArray(e, e => ou(e, { ...u, ...cu(A, l, ee) }, w)), c, s, t, C, w) })), rC = `framer`, iC = 3, aC = 30, oC = 1e4, sC = `3`, cC = `__framer`, lC = [`website`, `company`, `message`, `subject`, `title`, `description`, `feedback`, `notes`, `details`, `remarks`, `comments`], uC = (() => Date.now())(), dC = { name: 0, value: 1, setAttribute: 2, valueProperty: 3, isInputEventTrusted: 4, inputChangeTimeSinceModuleLoad: 5, wasFilledBeforeHydration: 6 }, fC = { fieldData: 0, fieldCount: 1, fieldFilledCount: 2, hpVersion: 3, siteId: 4, timeToSubmissionSinceModuleLoad: 5 }, pC = () => ((Date.now() - uC) / 1e3).toFixed(2), mC = ({ inputStateRef: e }) => { let { inputRef: t, originalName: n } = e; return p.useLayoutEffect(() => { let n = t.current; if (!n) return; let r = e.methodsUsed; n.value && (r.wasFilledBeforeHydration = !0) }, [t, e]), p.useEffect(() => { let n = t.current; if (!n) return; let r = e.methodsUsed, i = Element.prototype.setAttribute, a = i.bind(n); n.setAttribute = function (e, t) { e === `value` && (r.setAttribute = !0, r.inputChangeTimeSinceModuleLoad = pC()), a(e, t) }; let o = Object.getOwnPropertyDescriptor(HTMLInputElement.prototype, `value`); o && Object.defineProperty(n, `value`, { configurable: !0, enumerable: !0, get: function () { return o.get?.call(this) ?? `` }, set: function (e) { r.valueProperty = !0, r.inputChangeTimeSinceModuleLoad = pC(), o.set?.call(this, e) } }); let s = e => { r.isInputEventTrusted = e.isTrusted, r.inputChangeTimeSinceModuleLoad = pC() }; return n.addEventListener(`input`, s), () => { n.setAttribute = i.bind(n), o && Object.defineProperty(n, `value`, o), n.removeEventListener(`input`, s) } }, [t, e]), m(`input`, { ref: t, type: `text`, name: n, suppressHydrationWarning: !0, tabIndex: -1, autoComplete: `one-time-code`, "aria-hidden": `true`, style: { position: `absolute`, transform: `scale(0)` }, defaultValue: ``, "data-1p-ignore": !0, "data-lpignore": `true`, "data-form-type": `other`, "data-bwignore": !0 }) }, hC = { state: `pending` }, gC = { state: `success` }, _C = { state: `incomplete` }, vC = { state: `complete` }, yC = { state: `error` }, bC = p.createContext(void 0), xC = p.forwardRef(function ({ action: e, children: n, redirectUrl: r, onSuccess: i, onError: a, onLoading: o, submitTrackingId: s, nodeId: c, ...l }, u) { let d = p.useRef(null), f = u ?? d, { states: h, convertHoneypotFieldsForSubmission: g, replaceHoneypotWithMetadata: v } = hu(), y = Et(), b = Ot(), x = Wl(), C = ln(), [w, T] = p.useReducer(yu, _C), { activeLocale: E, locales: D } = pr(), O = t(bC), k = p.useRef({ onSuccess: i, onError: a, onLoading: o }); k.current = { onSuccess: i, onError: a, onLoading: o }; let A = p.useRef(!1); async function ee(e) { if (L(e)) { let t = Hl(y, e, x, D); if (!t) { Su(e, f); return } let { routeId: n, elementId: r, pathVariables: i } = t; y.navigate?.(n, r, i); return } B(vl(e), `Expected link to be either a LinkToWebPage or a string`, e); let { routeId: t, elementId: n, pathVariables: r } = Vl(y, b, e, E, await Ql(e.unresolvedPathSlugs, e.unresolvedHashSlugs, E, C), x); y.navigate?.(t, n, r) } let j = async t => { if (t.preventDefault(), !e || !O || A.current) return; A.current = !0, g(); let n = new FormData(t.currentTarget); await mn({ priority: `user-visible`, continueAfter: `paint` }), v(n), _(() => T({ type: `submit` })), mu(n, K.document); for (let [e, t] of n) t instanceof File && n.delete(e); try { k.current.onLoading?.(), _u({ router: y, nodeId: c, submitTrackingId: s, activeLocale: E }), await wu(e, n, O), _(() => T({ type: `success` })), k.current.onSuccess?.(), r && await ee(r) } catch (e) { _(() => T({ type: `error` })), k.current.onError?.(), console.error(e) } A.current = !1 }, M = e => { let { target: t, currentTarget: n, key: r } = e; t instanceof HTMLTextAreaElement || r === `Enter` && n.checkValidity() && (e.preventDefault(), j(e)) }, te = async e => { let t = e.currentTarget; await mn({ priority: `background`, continueAfter: `paint` }), _(() => T({ type: Cu(t) ? `incomplete` : `complete` })) }; return S(P.form, { ...l, onSubmit: bu(w) ? j : xu, onKeyDown: M, onChange: te, ref: f, children: [n(w), m(gu, { states: h })] }) }), SC = `__framer_force_showing_editorbar_since`, CC = class extends h { constructor() { super(...arguments), M(this, `state`, { error: void 0 }) } static getDerivedStateFromError(e) { return { error: e } } render() { return this.state.error ? null : this.props.children } }, wC = () => { try { return !!localStorage[SC] } catch { return !1 } }, TC = () => !wC(), EC = () => !1, DC = () => () => { }, OC = (() => { let e = a(void 0); return e.displayName = `TriggerStateContext`, e })(), kC = `main`, AC = `framerGeneratedPage`, jC = `<!-- Start of headStart -->`, MC = `<!-- End of headStart -->`, NC = `<!-- Start of headEnd -->`, PC = `<!-- End of headEnd -->`, FC = `<!-- Start of bodyStart -->`, IC = `<!-- End of bodyStart -->`, LC = `<!-- Start of bodyEnd -->`, RC = `<!-- End of bodyEnd -->`, zC = (() => p.createContext(void 0))(), BC = null, VC = null, Nh(Gu), HC = (e, r, i, a, o, l) => { let u = t(bC), d = c(), f = ln(), p = c(!0); return s(() => { function t() { (!BC || !VC) && Gu(); let t = i ? new URL(K.location.origin + i) : K.location, n = { version: ig, abTestId: e?.abTestId, framerSiteId: u ?? null, webPageId: e?.abTestingVariantId ?? r, routePath: e?.path || `/`, collectionItemId: null, framerLocale: o?.code || null, referrer: null, url: t.href, hostname: t.hostname, pathname: t.pathname, search: t.search || null, hash: t.hash || null, timezone: BC, locale: VC }, s = p.current && l !== void 0 ? l : void 0; return e?.collectionId && a ? (async () => { let t = s ?? null; if (s === void 0) { let n = e.collectionId && f?.get(e.collectionId), [r] = Object.values(a); if (n && L(r)) { let e = n.getRecordIdBySlug(r, o || void 0); t = (at(e) ? await e : e) ?? null } } return { ...n, collectionItemId: t } })() : n } (async () => { let e = d.current = t(), n = e instanceof Promise ? await e : e; d.current = n, p.current ? p.current = !1 : Zt(`published_site_pageview`, n, `eager`) })(); let s = async e => { if (e.persisted) { let e = d.current = t(), n = e instanceof Promise ? await e : e; d.current = n, Zt(`published_site_pageview`, n, `eager`) } }; return n.addEventListener(`pageshow`, s), () => { n.removeEventListener(`pageshow`, s) } }, [e, r, i, a, o, u, f, l]), d }, UC = { status: `loading`, data: void 0 }, WC = 5e3, GC = () => { }, QC = class e { constructor() { M(this, `responseValues`, new Map), be(this, KC, new Map), be(this, qC, new Set), be(this, JC, new Map), be(this, YC, new Map), be(this, XC, new Map), be(this, ZC, new Map), M(this, `persistCache`, ec(() => { let t = {}; for (let [e, n] of this.responseValues) { if (!n || n.status !== `success`) continue; let r = F(this, JC).get(e); if (!r || r === 0) continue; let i = F(this, YC).get(e); i && (i && sd(i, r) || (t[e] = [i, r, n.data])) } try { localStorage.setItem(e.cacheKey, JSON.stringify(t)) } catch { } }, 500)) } unmount() { for (let [e, t] of F(this, ZC)) clearInterval(t), F(this, ZC).delete(e) } stopQueryRefetching(e) { let t = rd(e), n = F(this, ZC).get(t); n && (clearInterval(n), F(this, ZC).delete(t)) } startQueryRefetching(e) { let t = rd(e), n = F(this, ZC).get(t), r = F(this, JC).get(t); if (n || !r) return; let i = K.setInterval(() => { if (document.visibilityState === `hidden`) return; let n = F(this, YC).get(t); !r || !n || this.fetchWithCache({ ...e, cacheDuration: r }) }, r); F(this, ZC).set(t, i) } hydrateCache() { try { let t = localStorage.getItem(e.cacheKey); if (!t) return; let n = JSON.parse(t); if (typeof n != `object`) throw Error(`Invalid cache data`); for (let e in n) { let t = n[e]; if (!Array.isArray(t) || t.length !== 3) throw Error(`Invalid cache data`); let [r, i, a] = t; sd(r, i) || (F(this, YC).set(e, r), F(this, JC).set(e, i), this.responseValues.set(e, { status: `success`, data: a })) } } catch { try { localStorage.removeItem(e.cacheKey) } catch { } } } setResponseValue(e, t) { this.responseValues.set(e, t), this.persistCache(); let n = F(this, KC).get(e); if (n) for (let e of n) e() } async prefetch(e) { if (!va() || !Sl(e.url, !1)) return; let t = rd(e); F(this, qC).add(t), await this.fetchWithCache(e); let n = this.getValue(t); if (!n || n.status === `loading`) throw Error(`Unexpected result status for prefetch`); let r = F(this, KC).get(t); for (let e of r ?? []) e(); let i = od(n, e); return e.resultOutputType === `image` && L(i) && await ed(i).catch(GC), i } async fetchWithCache(e) { if (!va()) return; let t = rd(e), n = F(this, XC).get(t); if (n) return n; let r = F(this, YC).get(t), i = r && sd(r, e.cacheDuration); if (this.responseValues.has(t) && !i) return; this.responseValues.get(t) || this.setResponseValue(t, UC); let a = (async () => { try { let n = await fetch(e.url, { method: `GET`, credentials: e.credentials }); if (!n.ok) { this.setResponseValue(t, { status: `error`, error: Error(`Invalid Response Status`), data: void 0 }); return } let r = await n.json(); this.setResponseValue(t, { status: `success`, data: r }), F(this, YC).set(t, Date.now()) } catch (e) { this.setResponseValue(t, { status: `error`, error: e, data: void 0 }) } })(); return F(this, XC).set(t, a), a.finally(() => { F(this, XC).delete(t) }), a } getValue(e, t = !1) { if (!(t && !F(this, qC).has(e))) return this.responseValues.get(e) } subscribe(e, t, n = !1) { let { url: r, cacheDuration: i } = e; if (!Sl(r, !1)) return GC; let a = rd(e), o = F(this, JC).get(a); (!o || i < o) && F(this, JC).set(a, i), n || (this.startQueryRefetching(e), this.fetchWithCache(e)); let s = F(this, KC).get(a) ?? new Set; return s.add(t), F(this, KC).set(a, s), () => { let n = F(this, KC).get(a); n && (n.delete(t), n.size === 0 && F(this, KC).delete(a), F(this, KC).size === 0 && this.stopQueryRefetching(e)) } } }, KC = new WeakMap, qC = new WeakMap, JC = new WeakMap, YC = new WeakMap, XC = new WeakMap, ZC = new WeakMap, M(QC, `cacheKey`, `framer-fetch-client-cache`), $C = QC, ew = a(void 0), tw = a(!0), nw = ({ children: e, client: t }) => { let [n] = i(() => t ?? new $C), [r, a] = i(!0); return s(() => (n.hydrateCache(), _(() => { a(!1) }), () => n.unmount()), [n]), m(tw.Provider, { value: r, children: m(ew.Provider, { value: n, children: e }) }) }, Le.WillChange = Ue, rw = Bl(v(function ({ links: e, children: t, ...n }, r) { let i = Et(), { activeLocale: a } = pr(), o = oc(r), s = eu(), c = [], l = e.map(e => { if (e) return L(e) ? uu(e, i, void 0, void 0, a) : uu(e.href, i, e.implicitPathVariables, e.refKey, a, (e, t) => s(e, t, a, c)) }); if (c.length > 0) throw Promise.allSettled(c); return o(t(l), n) })), iw = { cast(e, t) { switch (t.type) { case `array`: return Sd(e, t); case `boolean`: return wd(e); case `color`: return Dd(e); case `date`: return kd(e); case `enum`: return jd(e); case `file`: return Nd(e); case `link`: return Fd(e); case `number`: return Ld(e); case `object`: return Bd(e, t); case `responsiveimage`: return Hd(e); case `richtext`: return Wd(e); case `string`: return Jd(e); case `vectorsetitem`: return Kd(e); case `unknown`: return e; default: V(t, `Unsupported cast`) } }, parse(e) { return Xe(e) ? { type: `boolean`, value: e } : nt(e) ? { type: `date`, value: e.toISOString() } : R(e) ? { type: `number`, value: e } : L(e) ? { type: `string`, value: e } : Ze(e) ? { type: `array`, value: e.map(iw.parse) } : null }, equal(e, t, n) { return e?.type === t?.type ? Xd(e, t, n) === 0 : !1 }, lessThan(e, t, n) { return e?.type === t?.type ? Xd(e, t, n) < 0 : !1 }, lessThanOrEqual(e, t, n) { return e?.type === t?.type ? Xd(e, t, n) <= 0 : !1 }, greaterThan(e, t, n) { return e?.type === t?.type ? Xd(e, t, n) > 0 : !1 }, greaterThanOrEqual(e, t, n) { return e?.type === t?.type ? Xd(e, t, n) >= 0 : !1 }, in(e, t, n) { return t?.type === `array` ? t.value.some(t => iw.equal(t, e, n)) : !1 }, indexOf(e, t, n) { return e?.type === `array` ? e.value.findIndex(e => iw.equal(e, t, n)) : -1 }, contains(e, t, n) { let r = Yd(e), i = Yd(t); return et(r) || et(i) ? !1 : (n.type === 0 && (r = r.toLowerCase(), i = i.toLowerCase()), r.includes(i)) }, startsWith(e, t, n) { let r = Yd(e), i = Yd(t); return et(r) || et(i) ? !1 : (n.type === 0 && (r = r.toLowerCase(), i = i.toLowerCase()), r.startsWith(i)) }, endsWith(e, t, n) { let r = Yd(e), i = Yd(t); return et(r) || et(i) ? !1 : (n.type === 0 && (r = r.toLowerCase(), i = i.toLowerCase()), r.endsWith(i)) }, length(e) { switch (e?.type) { case `array`: return e.value.length }return 0 }, stringify(e) { if (e === null) return `null`; switch (e.type) { case `array`: return `[${e.value.map(iw.stringify).join(`, `)}]`; case `boolean`: case `number`: return String(e.value); case `string`: return `'${e.value}'`; case `enum`: return `'${e.value}' /* Enum */`; case `color`: return `'${e.value}' /* Color */`; case `date`: return `'${e.value}' /* Date */`; case `richtext`: return `RichText`; case `vectorsetitem`: return `VectorSetItem`; case `responsiveimage`: return `ResponsiveImage`; case `file`: return `File`; case `link`: return L(e.value) ? `'${e.value}' /* Link */` : `Link`; case `object`: return `Object`; default: V(e) } } }, aw = { type: `unknown`, isNullable: !0 }, ow = class { constructor(e, t) { this.collection = e, this.locale = t, M(this, `schema`), M(this, `indexes`, []); let n = Ha(e); B(n, `Collection does not have properties`); let r = { id: { type: `string`, isNullable: !1 } }, i = Object.entries(n); for (let [e, t] of i) { if (!t) continue; let n = t.type; B(n !== `array`, `Array properties are not supported`), B(n !== `object`, `Object properties are not supported`), r[e] = { type: n, isNullable: !0 } } this.schema = r } getDatabaseItem(e, t) { let n = {}, r = Number(t); for (let t in this.schema) { let i = e[t]; if (tt(i)) continue; let a = this.schema[t]; if (!$e(a)) { if (B(a.type !== `unknown`, `Invalid definition type`), a.type === `richtext`) { n[t] = { type: a.type, value: { itemIndex: r, key: t } }; continue } n[t] = { type: a.type, value: i } } } return { pointer: t, data: n } } async resolveRichText(e) { let { itemIndex: t, key: n } = e, r = (await Zd(this.collection, this.locale))[t]?.[n]; return qh.is(r) ? r.readMaybeAsync() : r } async scanItems() { return (await Zd(this.collection, this.locale)).map((e, t) => { let n = String(t); return this.getDatabaseItem(e, n) }) } async resolveItems(e) { let t = await Zd(this.collection, this.locale); return e.map(e => { let n = t[Number(e)]; return B(n, `Can't find collection item`), this.getDatabaseItem(n, e) }) } compareItems(e, t) { return Number(e.pointer) - Number(t.pointer) } }, sw = new Map, cw = new WeakMap, lw = `$r_`, uw = new Map, dw = 1e3, Q = class e { constructor(e) { this.network = e } static estimate(t, n) { let r = nf(), i = rf(); return new e(t * r + n / i) } static max(t, n) { return new e(Math.max(t.network, n.network)) } static compare(e, t) { return e.network < t.network ? -1 : e.network > t.network ? 1 : 0 } add(e) { return this.network += e.network, this } toString() { return `${this.network}ms` } }, fw = class { constructor(e, t) { this.id = e, this.relational = t, M(this, `nodes`, []), M(this, `winners`, new Map) } addNode(e) { this.nodes.push(e), e.setGroup(this) } getWinner(e) { let t = e.getHash(), n = this.winners.get(t); if (n) return n; let r = new pw; return this.winners.set(t, r), r } getOptimized(e) { let t = this.getWinner(e); B(t.node, `Group not optimized`); let n = t.node.getOptimized(e); return n.setGroup(this), n } }, pw = class { constructor() { M(this, `node`), M(this, `cost`, new Q(1 / 0)), M(this, `nodes`, []) } update(e, t) { this.nodes.push(e), Q.compare(t, this.cost) < 0 && (this.node = e, this.cost = t) } }, mw = class { constructor(e) { this.isSynchronous = e } }, hw = class extends mw { constructor() { super(...arguments), M(this, `group`) } getGroup() { return B(this.group, `Node must be in a group`), this.group } setGroup(e) { B(!this.group, `Node is already in a group`), this.group = e } evaluateSync() { return ud(this.evaluate(void 0)) } evaluateAsync() { return dd(this.evaluate(void 0)) } }, gw = class { constructor(e, t) { M(this, `collections`), M(this, `richTextCache`, new WeakMap), M(this, `vectorSetItemCache`, new WeakMap), this.collections = ff(e, t) } *resolveArrayValue(e) { return yield* pd(e.value.map(e => this.resolveValue(e))) } *resolveObjectValue(e) { let t = {}; for (let n in e.value) { let r = e.value[n]; t[n] = this.resolveValue(r) } return yield* W(t) } loadRichTextValue(e) { let t = e.value; B(lf(t), `Rich text pointer must be wrapped`); let n = this.collections.get(t.collectionId); B(n, `Can't find collection for rich text pointer`); let r = this.richTextCache.get(n) ?? new Map; this.richTextCache.set(n, r); let i = r.get(t.pointer); if (i) return i; let a = n.resolveRichText(t.pointer); return r.set(t.pointer, a), a } preloadRichTextValue(e) { this.loadRichTextValue(e) } *resolveRichTextValue(e) { let t = this.loadRichTextValue(e); return it(t) ? yield t : t } loadVectorSetItemValue(e) { let t = e.value; B(df(t), `Vector set item pointer must be wrapped`); let n = this.collections.get(t.collectionId); B(n, `Can't find collection for vector set item pointer`), B(n.resolveVectorSetItem, `Can't resolve vector set item pointer`); let r = this.vectorSetItemCache.get(n) ?? new Map; this.vectorSetItemCache.set(n, r); let i = r.get(t.pointer); if (i) return i; let a = n.resolveVectorSetItem(t.pointer); return r.set(t.pointer, a), a } preloadVectorSetItemValue(e) { this.loadVectorSetItemValue(e) } *resolveVectorSetItemValue(e) { let t = this.loadVectorSetItemValue(e); return it(t) ? yield t : t } *resolveValue(e) { switch (e?.type) { case `array`: return yield* this.resolveArrayValue(e); case `object`: return yield* this.resolveObjectValue(e); case `richtext`: return yield* this.resolveRichTextValue(e); case `vectorsetitem`: return yield* this.resolveVectorSetItemValue(e) }return e?.value ?? null } }, _w = `index`, vw = class extends Set { merge(e) { for (let t of e) this.add(t) } equals(e) { if (this === e) return !0; if (this.size !== e.size) return !1; for (let t of this) if (!e.has(t)) return !1; return !0 } subsetOf(e) { if (this === e) return !0; if (this.size > e.size) return !1; for (let t of this) if (!e.has(t)) return !1; return !0 } getHash() { let e = []; for (let t of this) e.push(t.id); return e.sort((e, t) => e - t), G(this.name, ...e) } }, yw = class { constructor(e, t, n) { this.id = e, this.name = t, this.data = n, M(this, `indexes`, new xw), M(this, `fields`, new $) } }, bw = class { constructor(e, t, n, r, i, a) { for (let o in this.id = e, this.data = t, this.collection = n, this.lookupNodes = r, this.constraint = i, this.ordering = a, M(this, `resolvedFields`, new $), t.schema) for (let e of n.fields) e.name === o && this.resolvedFields.add(e) } }, xw = class extends vw { constructor() { super(...arguments), M(this, `name`, `Indexes`) } }, Sw = class { constructor(e, t, n, r) { this.id = e, this.name = t, this.definition = n, this.collection = r } getValue(e) { B(this.name, `Can only get value of field with a name`); let t = e.data[this.name]; switch (t?.type) { case `richtext`: return B(this.collection, `Rich text field must have a collection`), { type: `richtext`, value: cf(this.collection.data, t.value) }; case `vectorsetitem`: return B(this.collection, `Vector set item field must have a collection`), { type: `vectorsetitem`, value: uf(this.collection.data, t.value) } }return t ?? null } }, $ = class extends vw { constructor() { super(...arguments), M(this, `name`, `Fields`) } }, Cw = class { constructor(e, t = `asc`) { this.field = e, this.direction = t } getHash() { return G(`OrderingField`, this.field.id, this.direction) } }, ww = class { constructor(e) { M(this, `fields`, []), e && this.merge(e) } get length() { return this.fields.length } getHash() { return G(`Ordering`, ...this.fields) } push(e) { this.fields.push(e) } merge(e) { this.fields.push(...e.fields) } equals(e) { return this === e ? !0 : this.length === e.length ? this.getHash() === e.getHash() : !1 } providedByFields(e) { for (let { field: t } of this.fields) if (!e.has(t) && t.name !== _w) return !1; return !0 } }, Tw = class { constructor(e, t) { this.ordering = e, this.resolvedFields = t } getHash() { return G(`RequiredProps`, this.ordering, this.resolvedFields) } get isMinimal() { return this.ordering.length === 0 && this.resolvedFields.size === 0 } canProvide(e) { return this.canProvideOrdering(e) && this.canProvideResolvedFields(e) } canProvideOrdering(e) { return this.ordering.length === 0 ? !0 : e.canProvideOrdering(this.ordering) } canProvideResolvedFields(e) { return this.resolvedFields.size === 0 ? !0 : e.canProvideResolvedFields(this.resolvedFields) } }, Ew = class e { constructor(e) { this.parent = e, M(this, `node`), M(this, `ordering`), M(this, `fields`, []) } takeNode() { let e = this.node; return B(e, `Node is missing`), this.node = void 0, e } setNode(e) { B(!this.node, `Node already set`), this.node = e } setOrdering(e) { this.ordering = e } push() { return new e(this) } replace() { return new e(this.parent) } addField(e) { this.fields.push(e) } addFieldsFromScope(e) { for (let t of e.fields) this.addField(t) } resolveField(e, t) { let n = []; for (let r of this.fields) r.name === e && (t && r.collectionName !== t || n.push(r)); if (n.length === 1) return n[0]; if (n.length > 1) throw Error(`Ambiguous fields`); return this.parent?.resolveField(e, t) } has(e) { return this.fields.includes(e) ? !0 : this.parent?.has(e) ?? !1 } getRequiredOrdering() { return this.ordering ?? new ww } getRequiredResolvedFields() { let e = new $; for (let { field: t } of this.fields) t.collection && e.add(t); return e } getRequiredProps() { return new Tw(this.getRequiredOrdering(), this.getRequiredResolvedFields()) } getNamedFields() { let e = {}; for (let { name: t, field: n } of this.fields) e[t] = n; return e } getSingleField() { B(this.fields.length === 1, `Scope must contain exactly one field`); let e = this.fields[0]; return B(e, `Field must exist`), e.field } }, Dw = class { constructor() { M(this, `pointers`, new Map), M(this, `values`, new Map) } getKey() { let e = []; for (let [t, n] of this.pointers) e.push(`${t.id}-${n}`); return e.sort().join(`-`) } addValue(e, t) { this.values.set(e, t) } getValue(e) { return this.values.get(e) ?? null } mergeValues(e) { for (let [t, n] of e.values) this.addValue(t, n) } addPointer(e, t) { this.pointers.set(e, t) } getPointer(e) { return this.pointers.get(e) } mergePointers(e) { for (let [t, n] of e.pointers) this.addPointer(t, n) } merge(e) { this.mergeValues(e), this.mergePointers(e) } }, Ow = class e { constructor(e, t = []) { this.fields = e, this.tuples = t } push(e) { this.tuples.push(e) } filter(t) { let n = this.tuples.filter(t); return new e(this.fields, n) } map(t, n) { return new e(t, this.tuples.map(n)) } sort(t) { let n = Array.from(this.tuples).sort(t); return new e(this.fields, n) } slice(t, n) { let r = this.tuples.slice(t, n); return new e(this.fields, r) } union(t) { let n = new $; for (let e of this.fields) t.fields.has(e) && n.add(e); let r = new Set, i = new e(n); for (let e of this.tuples) { let t = e.getKey(); r.add(t), i.push(e) } for (let e of t.tuples) { let t = e.getKey(); r.has(t) || i.push(e) } return i } intersection(t) { let n = new $; for (let e of this.fields) t.fields.has(e) && n.add(e); let r = new Set, i = new e(n); for (let e of this.tuples) { let t = e.getKey(); r.add(t) } for (let e of t.tuples) { let t = e.getKey(); r.has(t) && i.push(e) } return i } }, kw = class { constructor(e, t) { this.input = e, this.field = t } getHash() { return G(`ProjectionField`, this.input, this.field.id) } }, Aw = class e extends hw { constructor(e, t, n) { let r = e.isSynchronous; for (let e of t) r &&= e.input.isSynchronous; super(r), this.input = e, this.projections = t, this.passthrough = n, M(this, `inputGroup`), this.inputGroup = e.getGroup() } getHash() { return G(`RelationalProject`, this.inputGroup.id, ...this.projections, this.passthrough) } getOutputFields() { let e = new $; e.merge(this.passthrough); for (let t of this.projections) e.add(t.field); return e } canProvideOrdering(e) { let t = new $; for (let e of this.projections) t.add(e.field); for (let { field: n } of e.fields) if (t.has(n)) return !1; return !0 } canProvideResolvedFields() { return !0 } getInputRequiredProps(e) { let t = new $(e.resolvedFields); for (let e of this.projections) t.merge(e.input.referencedFields), t.delete(e.field); return new Tw(e.ordering, t) } optimize(e, t) { let n = this.getInputRequiredProps(t), r = e.optimizeGroup(this.inputGroup, n), i = new Q(0); for (let t of this.projections) { let n = t.input.optimize(e); i = Q.max(i, n) } return new Q(0).add(Q.max(r, i)) } getOptimized(t) { let n = this.getInputRequiredProps(t); return new e(this.inputGroup.getOptimized(n), this.projections.map(e => new kw(e.input.getOptimized(), e.field)), this.passthrough) } *evaluate(e) { let t = this.getOutputFields(), n = yield* this.input.evaluate(e), r = yield* pd(n.tuples.map(t => pd(this.projections.map(n => W({ field: n.field, value: n.input.evaluate(e, t) }))))); return n.map(t, (e, t) => { let n = new Dw; n.mergePointers(e); for (let t of this.passthrough) { let r = e.getValue(t); n.addValue(t, r) } let i = r[t]; B(i, `Projections must exist`); for (let { field: e, value: t } of i) n.addValue(e, t); return n }) } }, jw = { type: 0 }, Mw = class extends mw { constructor(e, t, n) { super(n), this.referencedFields = e, this.referencedOuterFields = t, this.isSynchronous = n } evaluateSync() { return ud(this.evaluate(void 0, void 0)) } evaluateAsync() { return dd(this.evaluate(void 0, void 0)) } }, Nw = { type: 0 }, Pw = class { constructor(e, t) { this.when = e, this.then = t } getHash() { return G(`CaseCondition`, this.when, this.then) } }, Fw = class e extends Mw { constructor(e, t, n) { let r = new $, i = new $, a = !0; e && (r.merge(e.referencedFields), i.merge(e.referencedOuterFields), a &&= e.isSynchronous); for (let { when: e, then: n } of t) r.merge(e.referencedFields), i.merge(e.referencedOuterFields), a &&= e.isSynchronous, r.merge(n.referencedFields), i.merge(n.referencedOuterFields), a &&= n.isSynchronous; n && (r.merge(n.referencedFields), i.merge(n.referencedOuterFields), a &&= n.isSynchronous), super(r, i, a), this.input = e, this.conditions = t, this.otherwise = n, M(this, `definition`, { type: `unknown`, isNullable: !0 }) } getHash() { return G(`ScalarCase`, this.input, ...this.conditions, this.otherwise) } optimize(e) { this.input?.optimize(e); for (let t of this.conditions) t.when.optimize(e), t.then.optimize(e); return this.otherwise?.optimize(e), new Q(0) } getOptimized() { let t = this.input?.getOptimized(), n = this.conditions.map(e => new Pw(e.when.getOptimized(), e.then.getOptimized())), r = this.otherwise?.getOptimized(); return new e(t, n, r) } *evaluate(e, t) { let { input: n, conditions: r, otherwise: i } = yield* W({ input: this.input?.evaluate(e, t) ?? null, conditions: pd(this.conditions.map(n => W({ when: n.when.evaluate(e, t), then: n.then.evaluate(e, t) }))), otherwise: this.otherwise?.evaluate(e, t) ?? null }); if (this.input) { for (let { when: e, then: t } of r) if (iw.equal(n, e, Nw)) return t } else for (let { when: e, then: t } of r) if (Td(e)) return t; return i } }, Iw = class { constructor(e, t, n) { this.normalizer = e, this.query = t, this.locale = n, M(this, `collectionId`, 0), M(this, `indexId`, 0), M(this, `fieldId`, 0), M(this, `subqueries`, []) } build() { let e = new Ew; return this.buildQuery(e, this.query) } buildQuery(e, t) { let n = { type: `Select`, ...t }; return this.buildSelect(e, n) } buildSelect(e, t) { let n = this.buildFrom(e, t.from), r = n.getRequiredOrdering(); if (t.where) { let e = n.takeNode(), r = this.buildExpression(n, t.where), i = this.normalizer.newRelationalFilter(e, r); n.setNode(i) } let i = [], a = new $, o; if (t.orderBy) { o = new ww; for (let e of t.orderBy) if (e.type === `Identifier`) { let t = n.resolveField(e.name, e.collection); if ($e(t)) continue; a.add(t.field); let r = new Cw(t.field, e.direction); o.push(r) } else { let t = this.buildExpression(n, e), r = new Sw(hf(this.fieldId++), void 0, t.definition, void 0), a = new kw(t, r); i.push(a); let s = new Cw(r, e.direction); o.push(s) } o.merge(r) } else o = r; let s = this.buildSelectList(n, t.select, a, i); if (s.setOrdering(o), t.offset) { let n = s.takeNode(), r = this.buildExpression(e, t.offset), i = this.normalizer.newRelationalOffset(n, r, o); s.setNode(i) } if (t.limit) { let n = s.takeNode(), r = this.buildExpression(e, t.limit), i = this.normalizer.newRelationalLimit(n, r, o); s.setNode(i) } return s } buildSelectList(e, t, n, r) { let i = e.push(), a = new $(n), o = [...r]; for (let n of t) if (n.type === `Identifier`) { let t = e.resolveField(n.name, n.collection); if ($e(t)) continue; a.add(t.field), i.addField({ ...t, name: n.alias ?? t.name }) } else { let t = this.buildExpression(e, n); B(n.alias, `Subqueries should have an alias`); let r = hf(this.fieldId++), a = n.alias, s = new Sw(r, a, t.definition, void 0), c = new kw(t, s); o.push(c), i.addField({ field: s, name: a }) } let s = e.takeNode(), c = this.normalizer.newRelationalProject(s, o, a); return i.setNode(c), i } buildFrom(e, t) { switch (t.type) { case `Collection`: return this.buildCollection(e, t); case `LeftJoin`: return this.buildJoin(e, t); default: V(t, `Unsupported from type`) } } buildCollection(e, t) { let n = e.push(), r = tf(t.data, this.locale), i = t.alias, a = new yw(pf(this.collectionId++), i, r); for (let [e, t] of Object.entries(r.schema)) { let r = new Sw(hf(this.fieldId++), e, t, a); n.addField({ field: r, name: e, collectionName: i }), a.fields.add(r) } { let e = new Sw(hf(this.fieldId++), _w, { type: `number`, isNullable: !1 }, a); n.addField({ field: e, name: _w, collectionName: i }); let t = new ww, r = new Cw(e); t.push(r), n.setOrdering(t) } for (let e of r.indexes) { let t = []; for (let r of e.fields) { let e = this.buildExpression(n, r); t.push(e) } let r; e.where && (r = this.buildExpression(n, e.where)); let i = new ww, o = new bw(mf(this.indexId++), e, a, t, r, i); a.indexes.add(o) } let o = this.normalizer.newRelationalScan(a); return n.setNode(o), n } buildJoin(e, t) { let n = this.buildFrom(e, t.left), r = this.buildFrom(e, t.right), i = new ww, a = n.getRequiredOrdering(); i.merge(a); let o = r.getRequiredOrdering(); i.merge(o); let s = e.push(); s.addFieldsFromScope(n), s.addFieldsFromScope(r), s.setOrdering(i); let c = this.buildExpression(s, t.constraint), l = n.takeNode(), u = r.takeNode(), d; switch (t.type) { case `LeftJoin`: d = this.normalizer.newRelationalLeftJoin(l, u, c); break; default: V(t.type, `Unsupported join type`) }return s.setNode(d), s } buildExpression(e, t) { switch (t.type) { case `Identifier`: return this.buildIdentifier(e, t); case `LiteralValue`: return this.buildLiteralValue(t); case `FunctionCall`: return this.buildFunctionCall(e, t); case `Case`: return this.buildCase(e, t); case `UnaryOperation`: return this.buildUnaryOperation(e, t); case `BinaryOperation`: return this.buildBinaryOperation(e, t); case `TypeCast`: return this.buildTypeCast(e, t); case `Select`: throw Error(`Subqueries are only supported inside subquery function calls`); default: V(t, `Unsupported expression`) } } buildIdentifier(e, t) { let n = e.resolveField(t.name, t.collection); if (n) { let e = !1; for (let t of this.subqueries) e ? t.referencedOuterFields.add(n.field) : (e = t.inScope.has(n), e && t.referencedFields.add(n.field)); return this.normalizer.newScalarVariable(n.field, e) } return this.normalizer.newScalarConstant(aw, null) } buildLiteralValue(e) { let t = iw.parse(e.value); return this.normalizer.newScalarConstant(aw, t) } buildFunctionCall(e, t) { let n = n => { let r = t.arguments[n]; return B(r, `Missing argument`), this.buildExpression(e, r) }, r = t.functionName; switch (r) { case `CONTAINS`: { let e = n(0), t = n(1); return this.normalizer.newScalarContains(e, t) } case `STARTS_WITH`: { let e = n(0), t = n(1); return this.normalizer.newScalarStartsWith(e, t) } case `ENDS_WITH`: { let e = n(0), t = n(1); return this.normalizer.newScalarEndsWith(e, t) } case `LENGTH`: { let e = n(0); return this.normalizer.newScalarLength(e) } case `INDEX_OF`: { let e = n(0), t = n(1); return this.normalizer.newScalarIndexOf(e, t) } case `ARRAY`: { let n = t.arguments[0]; return B(n, `Missing argument`), B(n.type === `Select`, `Subqueries require a select expression`), this.buildSubqueryArray(e, n) } case `FLAT_ARRAY`: { let n = t.arguments[0]; return B(n, `Missing argument`), B(n.type === `Select`, `Subqueries require a select expression`), this.buildSubqueryFlatArray(e, n) } case `INTERSECT`: { let e = n(0), t = n(1); return this.normalizer.newScalarIntersection(e, t) } default: V(r, `Unsupported function name`) } } buildSubqueryArray(e, t) { try { let n = new Lw(e); this.subqueries.push(n); let r = this.buildSelect(e, t), i = r.takeNode(), a = r.getNamedFields(), o = r.getRequiredOrdering(), s = n.referencedFields, c = n.referencedOuterFields; return this.normalizer.newScalarArray(i, a, o, s, c) } finally { this.subqueries.pop() } } buildSubqueryFlatArray(e, t) { try { let n = new Lw(e); this.subqueries.push(n); let r = this.buildSelect(e, t), i = r.takeNode(), a = r.getSingleField(), o = r.getRequiredOrdering(), s = n.referencedFields, c = n.referencedOuterFields; return this.normalizer.newScalarFlatArray(i, a, o, s, c) } finally { this.subqueries.pop() } } buildCase(e, t) { let n; t.value && (n = this.buildExpression(e, t.value)); let r = t.conditions.map(t => new Pw(this.buildExpression(e, t.when), this.buildExpression(e, t.then))), i; return t.else && (i = this.buildExpression(e, t.else)), this.normalizer.newScalarCase(n, r, i) } buildUnaryOperation(e, t) { let n = this.buildExpression(e, t.value); switch (t.operator) { case `not`: return this.normalizer.newScalarNot(n); default: V(t.operator, `Unsupported unary operator`) } } buildBinaryOperation(e, t) { let n = this.buildExpression(e, t.left), r = this.buildExpression(e, t.right); switch (t.operator) { case `and`: return this.normalizer.newScalarAnd(n, r); case `or`: return this.normalizer.newScalarOr(n, r); case `==`: return this.normalizer.newScalarEquals(n, r); case `!=`: return this.normalizer.newScalarNotEquals(n, r); case `<`: return this.normalizer.newScalarLessThan(n, r); case `<=`: return this.normalizer.newScalarLessThanOrEqual(n, r); case `>`: return this.normalizer.newScalarGreaterThan(n, r); case `>=`: return this.normalizer.newScalarGreaterThanOrEqual(n, r); case `in`: return this.normalizer.newScalarIn(n, r); default: V(t.operator, `Unsupported binary operator`) } } buildTypeCast(e, t) { let n = this.buildExpression(e, t.value); switch (t.dataType) { case `BOOLEAN`: return this.normalizer.newScalarCast(n, { type: `boolean`, isNullable: !0 }); case `DATE`: return this.normalizer.newScalarCast(n, { type: `date`, isNullable: !0 }); case `NUMBER`: return this.normalizer.newScalarCast(n, { type: `number`, isNullable: !0 }); case `STRING`: return this.normalizer.newScalarCast(n, { type: `string`, isNullable: !0 }); default: throw Error(`Unsupported data type`) } } }, Lw = class { constructor(e) { this.inScope = e, M(this, `referencedFields`, new $), M(this, `referencedOuterFields`, new $) } }, Rw = class e extends hw { constructor(e, t) { super(e.isSynchronous && t.isSynchronous), this.input = e, this.predicate = t, M(this, `inputGroup`), this.inputGroup = e.getGroup() } getHash() { return G(`RelationalFilter`, this.inputGroup.id, this.predicate) } getOutputFields() { return this.inputGroup.relational.outputFields } canProvideOrdering() { return !0 } canProvideResolvedFields() { return !0 } getInputRequiredProps(e) { let t = new $(e.resolvedFields); return t.merge(this.predicate.referencedFields), new Tw(e.ordering, t) } optimize(e, t) { let n = this.getInputRequiredProps(t), r = e.optimizeGroup(this.inputGroup, n), i = this.predicate.optimize(e); return new Q(0).add(Q.max(r, i)) } getOptimized(t) { let n = this.getInputRequiredProps(t); return new e(this.inputGroup.getOptimized(n), this.predicate.getOptimized()) } *evaluate(e) { let t = yield* this.input.evaluate(e), n = yield* pd(t.tuples.map(t => this.predicate.evaluate(e, t))); return t.filter((e, t) => Td(n[t] ?? null)) } }, zw = class e extends hw { constructor(e, t) { super(!1), this.index = e, this.query = t } getHash() { return G(`RelationalIndexLookup`, this.index.id, ...this.query) } getOutputFields() { return this.index.collection.fields } canProvideOrdering(e) { return e.equals(this.index.ordering) } canProvideResolvedFields(e) { return e.subsetOf(this.index.resolvedFields) } optimize() { let e = this.query.every(e => e.type === `All`); return Q.estimate(1, e ? 100 * dw : 50 * dw) } getOptimized() { return new e(this.index, this.query) } *evaluate() { let e = this.index, t = e.collection; return new Ow(this.getOutputFields(), (yield e.data.lookupItems(this.query)).map(n => { let r = new Dw; for (let i of e.resolvedFields) { let e = i.getValue(n); r.addPointer(t, n.pointer), r.addValue(i, e) } return r })) } }, Bw = class e extends hw { constructor(e, t) { super(e.isSynchronous && t.isSynchronous), this.left = e, this.right = t, M(this, `leftGroup`), M(this, `rightGroup`), this.leftGroup = e.getGroup(), this.rightGroup = t.getGroup() } getHash() { return G(`RelationalIntersection`, this.leftGroup.id, this.rightGroup.id) } getOutputFields() { let e = new $, t = this.leftGroup.relational.outputFields, n = this.rightGroup.relational.outputFields; for (let r of t) n.has(r) && e.add(r); return e } canProvideOrdering() { return !1 } canProvideResolvedFields() { return !0 } getChildRequiredProps(e) { return new Tw(new ww, e.resolvedFields) } optimize(e, t) { let n = this.getChildRequiredProps(t), r = e.optimizeGroup(this.leftGroup, n), i = this.getChildRequiredProps(t), a = e.optimizeGroup(this.rightGroup, i); return Q.max(r, a) } getOptimized(t) { let n = this.getChildRequiredProps(t), r = this.leftGroup.getOptimized(n), i = this.getChildRequiredProps(t); return new e(r, this.rightGroup.getOptimized(i)) } *evaluate(e) { let { left: t, right: n } = yield* W({ left: this.left.evaluate(e), right: this.right.evaluate(e) }); return t.intersection(n) } }, Vw = class e extends hw { constructor(e) { super(!1), this.collection = e } getHash() { return G(`RelationalScan`, this.collection.id) } getOutputFields() { return this.collection.fields } canProvideOrdering() { return !1 } canProvideResolvedFields(e) { return e.subsetOf(this.collection.fields) } optimize() { return Q.estimate(1, 200 * dw) } getOptimized() { return new e(this.collection) } *evaluate() { let e = this.collection, t = this.getOutputFields(); return new Ow(t, (yield e.data.scanItems()).map(n => { let r = new Dw; for (let i of t) { let t = i.getValue(n); r.addPointer(e, n.pointer), r.addValue(i, t) } return r })) } }, Hw = class e extends hw { constructor(e, t) { super(e.isSynchronous && t.isSynchronous), this.left = e, this.right = t, M(this, `leftGroup`), M(this, `rightGroup`), this.leftGroup = e.getGroup(), this.rightGroup = t.getGroup() } getHash() { return G(`RelationalUnion`, this.leftGroup.id, this.rightGroup.id) } getOutputFields() { let e = new $, t = this.leftGroup.relational.outputFields, n = this.rightGroup.relational.outputFields; for (let r of t) n.has(r) && e.add(r); return e } canProvideOrdering() { return !1 } canProvideResolvedFields() { return !0 } getChildRequiredProps(e) { return new Tw(new ww, e.resolvedFields) } optimize(e, t) { let n = this.getChildRequiredProps(t), r = e.optimizeGroup(this.leftGroup, n), i = this.getChildRequiredProps(t), a = e.optimizeGroup(this.rightGroup, i); return Q.max(r, a) } getOptimized(t) { let n = this.getChildRequiredProps(t), r = this.leftGroup.getOptimized(n), i = this.getChildRequiredProps(t); return new e(r, this.rightGroup.getOptimized(i)) } *evaluate(e) { let { left: t, right: n } = yield* W({ left: this.left.evaluate(e), right: this.right.evaluate(e) }); return t.union(n) } }, Uw = class e extends Mw { constructor(e, t) { let n = new $; n.merge(e.referencedFields), n.merge(t.referencedFields); let r = new $; r.merge(e.referencedOuterFields), r.merge(t.referencedOuterFields); let i = e.isSynchronous && t.isSynchronous; super(n, r, i), this.left = e, this.right = t, M(this, `definition`, { type: `boolean`, isNullable: !1 }) } getHash() { return G(`ScalarAnd`, this.left, this.right) } optimize(e) { let t = this.left.optimize(e), n = this.right.optimize(e); return Q.max(t, n) } getOptimized() { return new e(this.left.getOptimized(), this.right.getOptimized()) } *evaluate(e, t) { let { left: n, right: r } = yield* W({ left: this.left.evaluate(e, t), right: this.right.evaluate(e, t) }); return { type: `boolean`, value: Td(n) && Td(r) } } }, Ww = class extends Mw { constructor(e, t) { let n = new $, r = new $; super(n, r, !0), this.definition = e, this.value = t } getHash() { return G(`ScalarConstant`, this.definition, this.value) } optimize() { return new Q(0) } getOptimized() { return this } *evaluate() { return this.value } }, Gw = { type: 0 }, Kw = class e extends Mw { constructor(e, t) { let n = new $; n.merge(e.referencedFields), n.merge(t.referencedFields); let r = new $; r.merge(e.referencedOuterFields), r.merge(t.referencedOuterFields); let i = e.isSynchronous && t.isSynchronous; super(n, r, i), this.source = e, this.target = t, M(this, `definition`, { type: `boolean`, isNullable: !1 }) } getHash() { return G(`ScalarContains`, this.source, this.target) } optimize(e) { let t = this.source.optimize(e), n = this.target.optimize(e); return Q.max(t, n) } getOptimized() { return new e(this.source.getOptimized(), this.target.getOptimized()) } *evaluate(e, t) { let { source: n, target: r } = yield* W({ source: this.source.evaluate(e, t), target: this.target.evaluate(e, t) }); return { type: `boolean`, value: iw.contains(n, r, Gw) } } }, qw = { type: 0 }, Jw = class e extends Mw { constructor(e, t) { let n = new $; n.merge(e.referencedFields), n.merge(t.referencedFields); let r = new $; r.merge(e.referencedOuterFields), r.merge(t.referencedOuterFields); let i = e.isSynchronous && t.isSynchronous; super(n, r, i), this.source = e, this.target = t, M(this, `definition`, { type: `boolean`, isNullable: !1 }) } getHash() { return G(`ScalarEndsWith`, this.source, this.target) } optimize(e) { let t = this.source.optimize(e), n = this.target.optimize(e); return Q.max(t, n) } getOptimized() { return new e(this.source.getOptimized(), this.target.getOptimized()) } *evaluate(e, t) { let { source: n, target: r } = yield* W({ source: this.source.evaluate(e, t), target: this.target.evaluate(e, t) }); return { type: `boolean`, value: iw.endsWith(n, r, qw) } } }, Yw = class e extends Mw { constructor(e, t) { let n = new $; n.merge(e.referencedFields), n.merge(t.referencedFields); let r = new $; r.merge(e.referencedOuterFields), r.merge(t.referencedOuterFields); let i = e.isSynchronous && t.isSynchronous; super(n, r, i), this.left = e, this.right = t, M(this, `definition`, { type: `boolean`, isNullable: !1 }) } getHash() { return G(`ScalarEquals`, this.left, this.right) } optimize(e) { let t = this.left.optimize(e), n = this.right.optimize(e); return Q.max(t, n) } getOptimized() { return new e(this.left.getOptimized(), this.right.getOptimized()) } *evaluate(e, t) { let { left: n, right: r } = yield* W({ left: this.left.evaluate(e, t), right: this.right.evaluate(e, t) }); return { type: `boolean`, value: iw.equal(n, r, jw) } } }, Xw = class e extends Mw { constructor(e, t) { let n = new $; n.merge(e.referencedFields), n.merge(t.referencedFields); let r = new $; r.merge(e.referencedOuterFields), r.merge(t.referencedOuterFields); let i = e.isSynchronous && t.isSynchronous; super(n, r, i), this.left = e, this.right = t, M(this, `definition`, { type: `boolean`, isNullable: !1 }) } getHash() { return G(`ScalarGreaterThan`, this.left, this.right) } optimize(e) { let t = this.left.optimize(e), n = this.right.optimize(e); return Q.max(t, n) } getOptimized() { return new e(this.left.getOptimized(), this.right.getOptimized()) } *evaluate(e, t) { let { left: n, right: r } = yield* W({ left: this.left.evaluate(e, t), right: this.right.evaluate(e, t) }); return { type: `boolean`, value: iw.greaterThan(n, r, jw) } } }, Zw = class e extends Mw { constructor(e, t) { let n = new $; n.merge(e.referencedFields), n.merge(t.referencedFields); let r = new $; r.merge(e.referencedOuterFields), r.merge(t.referencedOuterFields); let i = e.isSynchronous && t.isSynchronous; super(n, r, i), this.left = e, this.right = t, M(this, `definition`, { type: `boolean`, isNullable: !1 }) } getHash() { return G(`ScalarGreaterThanOrEqual`, this.left, this.right) } optimize(e) { let t = this.left.optimize(e), n = this.right.optimize(e); return Q.max(t, n) } getOptimized() { return new e(this.left.getOptimized(), this.right.getOptimized()) } *evaluate(e, t) { let { left: n, right: r } = yield* W({ left: this.left.evaluate(e, t), right: this.right.evaluate(e, t) }); return { type: `boolean`, value: iw.greaterThanOrEqual(n, r, jw) } } }, Qw = class e extends Mw { constructor(e, t) { let n = new $; n.merge(e.referencedFields), n.merge(t.referencedFields); let r = new $; r.merge(e.referencedOuterFields), r.merge(t.referencedOuterFields); let i = e.isSynchronous && t.isSynchronous; super(n, r, i), this.left = e, this.right = t, M(this, `definition`, { type: `boolean`, isNullable: !1 }) } getHash() { return G(`ScalarLessThan`, this.left, this.right) } optimize(e) { let t = this.left.optimize(e), n = this.right.optimize(e); return Q.max(t, n) } getOptimized() { return new e(this.left.getOptimized(), this.right.getOptimized()) } *evaluate(e, t) { let { left: n, right: r } = yield* W({ left: this.left.evaluate(e, t), right: this.right.evaluate(e, t) }); return { type: `boolean`, value: iw.lessThan(n, r, jw) } } }, $w = class e extends Mw { constructor(e, t) { let n = new $; n.merge(e.referencedFields), n.merge(t.referencedFields); let r = new $; r.merge(e.referencedOuterFields), r.merge(t.referencedOuterFields); let i = e.isSynchronous && t.isSynchronous; super(n, r, i), this.left = e, this.right = t, M(this, `definition`, { type: `boolean`, isNullable: !1 }) } getHash() { return G(`ScalarLessThanOrEqual`, this.left, this.right) } optimize(e) { let t = this.left.optimize(e), n = this.right.optimize(e); return Q.max(t, n) } getOptimized() { return new e(this.left.getOptimized(), this.right.getOptimized()) } *evaluate(e, t) { let { left: n, right: r } = yield* W({ left: this.left.evaluate(e, t), right: this.right.evaluate(e, t) }); return { type: `boolean`, value: iw.lessThanOrEqual(n, r, jw) } } }, eT = class e extends Mw { constructor(e, t) { let n = new $; n.merge(e.referencedFields), n.merge(t.referencedFields); let r = new $; r.merge(e.referencedOuterFields), r.merge(t.referencedOuterFields); let i = e.isSynchronous && t.isSynchronous; super(n, r, i), this.left = e, this.right = t, M(this, `definition`, { type: `boolean`, isNullable: !1 }) } getHash() { return G(`ScalarNotEquals`, this.left, this.right) } optimize(e) { let t = this.left.optimize(e), n = this.right.optimize(e); return Q.max(t, n) } getOptimized() { return new e(this.left.getOptimized(), this.right.getOptimized()) } *evaluate(e, t) { let { left: n, right: r } = yield* W({ left: this.left.evaluate(e, t), right: this.right.evaluate(e, t) }); return { type: `boolean`, value: !iw.equal(n, r, jw) } } }, tT = class e extends Mw { constructor(e, t) { let n = new $; n.merge(e.referencedFields), n.merge(t.referencedFields); let r = new $; r.merge(e.referencedOuterFields), r.merge(t.referencedOuterFields); let i = e.isSynchronous && t.isSynchronous; super(n, r, i), this.left = e, this.right = t, M(this, `definition`, { type: `boolean`, isNullable: !1 }) } getHash() { return G(`ScalarOr`, this.left, this.right) } optimize(e) { let t = this.left.optimize(e), n = this.right.optimize(e); return Q.max(t, n) } getOptimized() { return new e(this.left.getOptimized(), this.right.getOptimized()) } *evaluate(e, t) { let { left: n, right: r } = yield* W({ left: this.left.evaluate(e, t), right: this.right.evaluate(e, t) }); return { type: `boolean`, value: Td(n) || Td(r) } } }, nT = { type: 0 }, rT = class e extends Mw { constructor(e, t) { let n = new $; n.merge(e.referencedFields), n.merge(t.referencedFields); let r = new $; r.merge(e.referencedOuterFields), r.merge(t.referencedOuterFields); let i = e.isSynchronous && t.isSynchronous; super(n, r, i), this.source = e, this.target = t, M(this, `definition`, { type: `boolean`, isNullable: !1 }) } getHash() { return G(`ScalarStartsWith`, this.source, this.target) } optimize(e) { let t = this.source.optimize(e), n = this.target.optimize(e); return Q.max(t, n) } getOptimized() { return new e(this.source.getOptimized(), this.target.getOptimized()) } *evaluate(e, t) { let { source: n, target: r } = yield* W({ source: this.source.evaluate(e, t), target: this.target.evaluate(e, t) }); return { type: `boolean`, value: iw.startsWith(n, r, nT) } } }, iT = class { constructor(e) { this.normalizer = e, M(this, `memo`), this.memo = e.memo } explore(e) { let t = e.getGroup(); if (e instanceof Rw) { if (e.predicate instanceof Uw) { let n = new Bw(this.normalizer.newRelationalFilter(e.input, e.predicate.left), this.normalizer.newRelationalFilter(e.input, e.predicate.right)); this.memo.addRelational(n, t) } if (e.predicate instanceof tT) { let n = new Hw(this.normalizer.newRelationalFilter(e.input, e.predicate.left), this.normalizer.newRelationalFilter(e.input, e.predicate.right)); this.memo.addRelational(n, t) } } if (e instanceof Vw) for (let n of e.collection.indexes) { if (n.constraint) continue; let e = new zw(n, gf(n.lookupNodes.length)); this.memo.addRelational(e, t) } if (e instanceof Rw) { for (let n of e.inputGroup.nodes) if (n instanceof Vw) for (let r of n.collection.indexes) { if (e.predicate instanceof Yw && e.predicate.left === r.lookupNodes[0] && e.predicate.right instanceof Ww && r.data.supportedLookupTypes.includes(`Equals`)) { let n = gf(r.lookupNodes.length); n[0] = { type: `Equals`, value: e.predicate.right.value }; let i = new zw(r, n); this.memo.addRelational(i, t) } if (e.predicate instanceof eT && e.predicate.left === r.lookupNodes[0] && e.predicate.right instanceof Ww && r.data.supportedLookupTypes.includes(`NotEquals`)) { let n = gf(r.lookupNodes.length); n[0] = { type: `NotEquals`, value: e.predicate.right.value }; let i = new zw(r, n); this.memo.addRelational(i, t) } if (e.predicate instanceof Qw && e.predicate.left === r.lookupNodes[0] && e.predicate.right instanceof Ww && r.data.supportedLookupTypes.includes(`LessThan`)) { let n = gf(r.lookupNodes.length); n[0] = { type: `LessThan`, value: e.predicate.right.value, inclusive: !1 }; let i = new zw(r, n); this.memo.addRelational(i, t) } if (e.predicate instanceof $w && e.predicate.left === r.lookupNodes[0] && e.predicate.right instanceof Ww && r.data.supportedLookupTypes.includes(`LessThan`)) { let n = gf(r.lookupNodes.length); n[0] = { type: `LessThan`, value: e.predicate.right.value, inclusive: !0 }; let i = new zw(r, n); this.memo.addRelational(i, t) } if (e.predicate instanceof Xw && e.predicate.left === r.lookupNodes[0] && e.predicate.right instanceof Ww && r.data.supportedLookupTypes.includes(`GreaterThan`)) { let n = gf(r.lookupNodes.length); n[0] = { type: `GreaterThan`, value: e.predicate.right.value, inclusive: !1 }; let i = new zw(r, n); this.memo.addRelational(i, t) } if (e.predicate instanceof Zw && e.predicate.left === r.lookupNodes[0] && e.predicate.right instanceof Ww && r.data.supportedLookupTypes.includes(`GreaterThan`)) { let n = gf(r.lookupNodes.length); n[0] = { type: `GreaterThan`, value: e.predicate.right.value, inclusive: !0 }; let i = new zw(r, n); this.memo.addRelational(i, t) } if (e.predicate instanceof Kw && e.predicate.source === r.lookupNodes[0] && e.predicate.target instanceof Ww && r.data.supportedLookupTypes.includes(`Contains`)) { let n = gf(r.lookupNodes.length); n[0] = { type: `Contains`, value: e.predicate.target.value }; let i = new zw(r, n); this.memo.addRelational(i, t) } if (e.predicate instanceof rT && e.predicate.source === r.lookupNodes[0] && e.predicate.target instanceof Ww && r.data.supportedLookupTypes.includes(`StartsWith`)) { let n = gf(r.lookupNodes.length); n[0] = { type: `StartsWith`, value: e.predicate.target.value }; let i = new zw(r, n); this.memo.addRelational(i, t) } if (e.predicate instanceof Jw && e.predicate.source === r.lookupNodes[0] && e.predicate.target instanceof Ww && r.data.supportedLookupTypes.includes(`EndsWith`)) { let n = gf(r.lookupNodes.length); n[0] = { type: `EndsWith`, value: e.predicate.target.value }; let i = new zw(r, n); this.memo.addRelational(i, t) } } } } }, aT = class { constructor(e) { this.outputFields = e } isCompatible(e) { return this.outputFields.equals(e.outputFields) } }, oT = class { constructor() { M(this, `nodes`, new Map), M(this, `groups`, []) } addGroup(e) { let t = new fw(af(this.groups.length), e); return this.groups.push(t), t } addRelational(e, t) { let n = e.getHash(), r = this.nodes.get(n); if (r) return r; this.nodes.set(n, e); let i = new aT(e.getOutputFields()); return t ??= this.addGroup(i), t.addNode(e), B(i.isCompatible(t.relational), `Group has inconsistent relational props`), e } addScalar(e) { let t = e.getHash(); return this.nodes.get(t) || (this.nodes.set(t, e), e) } }, sT = class e extends hw { constructor(e, t, n) { super(e.isSynchronous && t.isSynchronous && n.isSynchronous), this.left = e, this.right = t, this.constraint = n, M(this, `leftGroup`), M(this, `rightGroup`), this.leftGroup = e.getGroup(), this.rightGroup = t.getGroup() } getHash() { return G(`RelationalLeftJoin`, this.leftGroup.id, this.rightGroup.id, this.constraint) } getOutputFields() { let e = new $; return e.merge(this.leftGroup.relational.outputFields), e.merge(this.rightGroup.relational.outputFields), e } canProvideOrdering() { return !1 } canProvideResolvedFields() { return !0 } getChildRequiredProps(e, t) { let n = new $, r = e.relational.outputFields; for (let e of t.resolvedFields) r.has(e) && n.add(e); for (let e of this.constraint.referencedFields) r.has(e) && n.add(e); return new Tw(new ww, n) } optimize(e, t) { let n = this.getChildRequiredProps(this.leftGroup, t), r = e.optimizeGroup(this.leftGroup, n), i = this.getChildRequiredProps(this.rightGroup, t), a = e.optimizeGroup(this.rightGroup, i), o = this.constraint.optimize(e); return Q.max(Q.max(r, a), o) } getOptimized(t) { let n = this.getChildRequiredProps(this.leftGroup, t), r = this.leftGroup.getOptimized(n), i = this.getChildRequiredProps(this.rightGroup, t); return new e(r, this.rightGroup.getOptimized(i), this.constraint.getOptimized()) } *evaluateScalarEquals(e, t, n, r, i) { let a = new Map; for (let e of t.tuples) { let t = yield* r.evaluate(i, e), n = JSON.stringify(t?.value ?? null), o = a.get(n) ?? []; o.push(e), a.set(n, o) } let o = new Ow(this.getOutputFields()); for (let t of e.tuples) { let e = yield* n.evaluate(i, t), r = JSON.stringify(e?.value ?? null), s = a.get(r) ?? []; if (s.length === 0) o.push(t); else for (let e of s) { let n = new Dw; n.merge(t), n.merge(e), o.push(n) } } return o } *evaluate(e) { let { left: t, right: n } = yield* W({ left: this.left.evaluate(e), right: this.right.evaluate(e) }); if (this.constraint instanceof Yw) { if (this.constraint.left.referencedFields.subsetOf(this.leftGroup.relational.outputFields) && this.constraint.right.referencedFields.subsetOf(this.rightGroup.relational.outputFields)) return yield* this.evaluateScalarEquals(t, n, this.constraint.left, this.constraint.right, e); if (this.constraint.right.referencedFields.subsetOf(this.leftGroup.relational.outputFields) && this.constraint.left.referencedFields.subsetOf(this.rightGroup.relational.outputFields)) return yield* this.evaluateScalarEquals(t, n, this.constraint.right, this.constraint.left, e) } let r = new Ow(this.getOutputFields()); for (let i of t.tuples) { let t = !1; for (let a of n.tuples) { let n = new Dw; n.merge(i), n.merge(a), Td(yield* this.constraint.evaluate(e, n)) && (r.push(n), t = !0) } t || r.push(i) } return r } }, cT = class e extends hw { constructor(e, t, n) { super(e.isSynchronous && t.isSynchronous), this.input = e, this.limit = t, this.ordering = n, M(this, `inputGroup`), this.inputGroup = e.getGroup() } getHash() { return G(`RelationalLimit`, this.inputGroup.id, this.limit) } getOutputFields() { return this.inputGroup.relational.outputFields } canProvideOrdering(e) { return e.equals(this.ordering) } canProvideResolvedFields() { return !0 } getInputRequiredProps(e) { let t = new $(e.resolvedFields); return t.merge(this.limit.referencedFields), new Tw(this.ordering, t) } optimize(e, t) { let n = this.getInputRequiredProps(t), r = e.optimizeGroup(this.inputGroup, n), i = this.limit.optimize(e); return new Q(0).add(Q.max(r, i)) } getOptimized(t) { let n = this.getInputRequiredProps(t); return new e(this.inputGroup.getOptimized(n), this.limit.getOptimized(), this.ordering) } *evaluate(e) { let { input: t, limit: n } = yield* W({ input: this.input.evaluate(e), limit: this.limit.evaluate(e, void 0) }), r = Rd(n) ?? 1 / 0; return r === 1 / 0 ? t : t.slice(0, r) } }, lT = class e extends hw { constructor(e, t, n) { super(e.isSynchronous && t.isSynchronous), this.input = e, this.offset = t, this.ordering = n, M(this, `inputGroup`), this.inputGroup = e.getGroup() } getHash() { return G(`RelationalOffset`, this.inputGroup.id, this.offset) } getOutputFields() { return this.inputGroup.relational.outputFields } canProvideOrdering(e) { return e.equals(this.ordering) } canProvideResolvedFields() { return !0 } getInputRequiredProps(e) { let t = new $(e.resolvedFields); return t.merge(this.offset.referencedFields), new Tw(this.ordering, t) } optimize(e, t) { let n = this.getInputRequiredProps(t), r = e.optimizeGroup(this.inputGroup, n), i = this.offset.optimize(e); return new Q(0).add(Q.max(r, i)) } getOptimized(t) { let n = this.getInputRequiredProps(t); return new e(this.inputGroup.getOptimized(n), this.offset.getOptimized(), this.ordering) } *evaluate(e) { let { input: t, offset: n } = yield* W({ input: this.input.evaluate(e), offset: this.offset.evaluate(e, void 0) }), r = Rd(n) ?? 0; return r === 0 ? t : t.slice(r) } }, uT = class e extends Mw { constructor(e, t, n, r, i) { super(r, i, e.isSynchronous), this.input = e, this.namedFields = t, this.ordering = n, this.referencedFields = r, this.referencedOuterFields = i, M(this, `inputGroup`), M(this, `definition`), this.inputGroup = e.getGroup(); let a = {}, o = Object.entries(t); for (let [e, t] of o) a[e] = t.definition; this.definition = { type: `array`, isNullable: !1, definition: { type: `object`, isNullable: !1, definitions: a } } } getHash() { let e = {}, t = Object.entries(this.namedFields); for (let [n, r] of t) e[n] = r.id; return G(`ScalarArray`, this.inputGroup.id, e, this.ordering, this.referencedFields, this.referencedOuterFields) } getInputRequiredProps() { let e = new $, t = Object.values(this.namedFields); for (let n of t) $e(n.collection) || e.add(n); return new Tw(this.ordering, e) } optimize(e) { let t = this.getInputRequiredProps(), n = e.optimizeGroup(this.inputGroup, t); return new Q(0).add(n) } getOptimized() { let t = this.getInputRequiredProps(); return new e(this.inputGroup.getOptimized(t), this.namedFields, this.ordering, this.referencedFields, this.referencedOuterFields) } *evaluate(e, t) { let n = new Dw; e && n.merge(e), t && n.merge(t); let r = yield* this.input.evaluate(n), i = Object.entries(this.namedFields); return { type: `array`, value: r.tuples.map(e => { let t = {}; for (let [n, r] of i) t[n] = e.getValue(r); return { type: `object`, value: t } }) } } }, dT = class e extends Mw { constructor(e, t) { super(e.referencedFields, e.referencedOuterFields, e.isSynchronous), this.input = e, this.definition = t, B(t.isNullable, `Unsupported non-nullable cast`) } getHash() { return G(`ScalarCast`, this.input, this.definition) } optimize(e) { return this.input.optimize(e) } getOptimized() { return new e(this.input.getOptimized(), this.definition) } *evaluate(e, t) { let n = yield* this.input.evaluate(e, t); return iw.cast(n, this.definition) } }, fT = class e extends Mw { constructor(e, t, n, r, i) { super(r, i, e.isSynchronous), this.input = e, this.field = t, this.ordering = n, this.referencedFields = r, this.referencedOuterFields = i, M(this, `inputGroup`), M(this, `definition`), this.inputGroup = e.getGroup(), this.definition = { type: `array`, isNullable: !1, definition: t.definition } } getHash() { return G(`ScalarFlatArray`, this.inputGroup.id, this.field.id, this.ordering, this.referencedFields, this.referencedOuterFields) } getInputRequiredProps() { let e = new $; return $e(this.field.collection) || e.add(this.field), new Tw(this.ordering, e) } optimize(e) { let t = this.getInputRequiredProps(), n = e.optimizeGroup(this.inputGroup, t); return new Q(0).add(n) } getOptimized() { let t = this.getInputRequiredProps(); return new e(this.inputGroup.getOptimized(t), this.field, this.ordering, this.referencedFields, this.referencedOuterFields) } *evaluate(e, t) { let n = new Dw; return e && n.merge(e), t && n.merge(t), { type: `array`, value: (yield* this.input.evaluate(n)).tuples.map(e => e.getValue(this.field)) } } }, pT = { type: 0 }, mT = class e extends Mw { constructor(e, t) { let n = new $; n.merge(e.referencedFields), n.merge(t.referencedFields); let r = new $; r.merge(e.referencedOuterFields), r.merge(t.referencedOuterFields); let i = e.isSynchronous && t.isSynchronous; super(n, r, i), this.left = e, this.right = t, M(this, `definition`, { type: `boolean`, isNullable: !1 }) } getHash() { return G(`ScalarIn`, this.left, this.right) } optimize(e) { let t = this.left.optimize(e), n = this.right.optimize(e); return Q.max(t, n) } getOptimized() { return new e(this.left.getOptimized(), this.right.getOptimized()) } *evaluate(e, t) { let { left: n, right: r } = yield* W({ left: this.left.evaluate(e, t), right: this.right.evaluate(e, t) }); return { type: `boolean`, value: iw.in(n, r, pT) } } }, hT = { type: 1 }, gT = class e extends Mw { constructor(e, t) { let n = new $; n.merge(e.referencedFields), n.merge(t.referencedFields); let r = new $; r.merge(e.referencedOuterFields), r.merge(t.referencedOuterFields); let i = e.isSynchronous && t.isSynchronous; super(n, r, i), this.source = e, this.target = t, M(this, `definition`, { type: `number`, isNullable: !1 }) } getHash() { return G(`ScalarIndexOf`, this.source, this.target) } optimize(e) { let t = this.source.optimize(e), n = this.target.optimize(e); return Q.max(t, n) } getOptimized() { return new e(this.source.getOptimized(), this.target.getOptimized()) } *evaluate(e, t) { let { source: n, target: r } = yield* W({ source: this.source.evaluate(e, t), target: this.target.evaluate(e, t) }); return { type: `number`, value: iw.indexOf(n, r, hT) } } }, _T = class e extends Mw { constructor(e, t) { let n = new $; n.merge(e.referencedFields), n.merge(t.referencedFields); let r = new $; r.merge(e.referencedOuterFields), r.merge(t.referencedOuterFields); let i = e.isSynchronous && t.isSynchronous; super(n, r, i), this.left = e, this.right = t, M(this, `definition`, { type: `array`, definition: { type: `string`, isNullable: !1 }, isNullable: !1 }) } getHash() { return G(`ScalarIntersection`, this.left, this.right) } optimize(e) { let t = this.left.optimize(e), n = this.right.optimize(e); return Q.max(t, n) } getOptimized() { return new e(this.left.getOptimized(), this.right.getOptimized()) } *evaluate(e, t) { let { left: n, right: r } = yield* W({ left: this.left.evaluate(e, t), right: this.right.evaluate(e, t) }), i = vf(n), a = vf(r), o = [], s = i.size < a.size ? i : a, c = s === i ? a : i; for (let e of s) c.has(e) && o.push({ type: `string`, value: e }); return { type: `array`, value: o } } }, vT = class e extends Mw { constructor(e) { super(e.referencedFields, e.referencedOuterFields, e.isSynchronous), this.input = e, M(this, `definition`, { type: `number`, isNullable: !1 }) } getHash() { return G(`ScalarLength`, this.input) } optimize(e) { return this.input.optimize(e) } getOptimized() { return new e(this.input.getOptimized()) } *evaluate(e, t) { let n = yield* this.input.evaluate(e, t); return { type: `number`, value: iw.length(n) } } }, yT = class e extends Mw { constructor(e) { super(e.referencedFields, e.referencedOuterFields, e.isSynchronous), this.input = e, M(this, `definition`, { type: `boolean`, isNullable: !1 }) } getHash() { return G(`ScalarNot`, this.input) } optimize(e) { return this.input.optimize(e) } getOptimized() { return new e(this.input.getOptimized()) } *evaluate(e, t) { return { type: `boolean`, value: !Td(yield* this.input.evaluate(e, t)) } } }, bT = { type: 0 }, xT = class e extends Mw { constructor(e, t) { let n = new $; n.merge(e.referencedFields), n.merge(t.referencedFields); let r = new $; r.merge(e.referencedOuterFields), r.merge(t.referencedOuterFields); let i = e.isSynchronous && t.isSynchronous; super(n, r, i), this.left = e, this.right = t, M(this, `definition`, { type: `boolean`, isNullable: !1 }) } getHash() { return G(`ScalarNotIn`, this.left, this.right) } optimize(e) { let t = this.left.optimize(e), n = this.right.optimize(e); return Q.max(t, n) } getOptimized() { return new e(this.left.getOptimized(), this.right.getOptimized()) } *evaluate(e, t) { let { left: n, right: r } = yield* W({ left: this.left.evaluate(e, t), right: this.right.evaluate(e, t) }); return { type: `boolean`, value: !iw.in(n, r, bT) } } }, ST = class extends Mw { constructor(e, t) { B(e.name !== _w, `Invalid field name`); let n = new $, r = new $; t ? r.add(e) : n.add(e), super(n, r, !0), this.field = e, this.isOuterField = t, M(this, `definition`), this.definition = e.definition } getHash() { return G(`ScalarVariable`, this.field.id, this.isOuterField) } optimize() { return new Q(0) } getOptimized() { return this } *evaluate(e, t) { return this.isOuterField ? (B(e, `Context must exist`), e.getValue(this.field)) : (B(t, `Tuple must exist`), t.getValue(this.field)) } }, CT = class { constructor(e) { this.memo = e } finishRelational(e) { return this.memo.addRelational(e) } newRelationalScan(e) { let t = new Vw(e); return this.finishRelational(t) } newRelationalIndexLookup(e, t) { let n = new zw(e, t); return this.finishRelational(n) } newRelationalLeftJoin(e, t, n) { let r = new sT(e, t, n); return this.finishRelational(r) } newRelationalRightJoin(e, t, n) { return this.newRelationalLeftJoin(t, e, n) } newRelationalFilter(e, t) { if (t instanceof Ww && t.value?.type === `boolean` && t.value.value === !0) return e; if (e instanceof sT && t.referencedFields.subsetOf(e.leftGroup.relational.outputFields)) { let n = this.newRelationalFilter(e.left, t); return this.newRelationalLeftJoin(n, e.right, e.constraint) } let n = new Rw(e, t); return this.finishRelational(n) } newRelationalProject(e, t, n) { let r = new Aw(e, t, n); return this.finishRelational(r) } newRelationalLimit(e, t, n) { if (e instanceof Aw && t.referencedFields.subsetOf(e.inputGroup.relational.outputFields) && n.providedByFields(e.inputGroup.relational.outputFields)) { let r = this.newRelationalLimit(e.input, t, n); return this.newRelationalProject(r, e.projections, e.passthrough) } let r = new cT(e, t, n); return this.finishRelational(r) } newRelationalOffset(e, t, n) { let r = new lT(e, t, n); return this.finishRelational(r) } finishScalar(e) { if (!(e instanceof Ww) && e.isSynchronous && e.referencedFields.size === 0 && e.referencedOuterFields.size === 0) { let t = e.evaluateSync(); return this.newScalarConstant(e.definition, t) } return this.memo.addScalar(e) } removeUnknown(e, t) { if (e.definition.type !== `unknown` || t.type === `unknown`) return e; let n = { ...t, isNullable: !0 }; return this.newScalarCast(e, n) } newScalarVariable(e, t) { let n = new ST(e, t); return this.finishScalar(n) } newScalarConstant(e, t) { let n = new Ww(e, t); return this.finishScalar(n) } newScalarNot(e) { if (e instanceof yT) return e.input.definition.type === `boolean` ? e.input : this.newScalarCast(e.input, { type: `boolean`, isNullable: !0 }); if (e instanceof Yw) return this.newScalarNotEquals(e.left, e.right); if (e instanceof eT) return this.newScalarEquals(e.left, e.right); if (e instanceof Qw) return this.newScalarGreaterThanOrEqual(e.left, e.right); if (e instanceof $w) return this.newScalarGreaterThan(e.left, e.right); if (e instanceof Xw) return this.newScalarLessThanOrEqual(e.left, e.right); if (e instanceof Zw) return this.newScalarLessThan(e.left, e.right); if (e instanceof Uw) { let t = this.newScalarNot(e.left), n = this.newScalarNot(e.right); return this.newScalarOr(t, n) } if (e instanceof tT) { let t = this.newScalarNot(e.left), n = this.newScalarNot(e.right); return this.newScalarAnd(t, n) } let t = new yT(e); return this.finishScalar(t) } newScalarAnd(e, t) { if (t instanceof Ww && t.value?.type === `boolean` && t.value.value === !0) return e; if (e instanceof Ww && e.value?.type === `boolean` && e.value.value === !0 || t instanceof Ww && t.value?.type === `boolean` && t.value.value === !1) return t; if (e instanceof Ww && e.value?.type === `boolean` && e.value.value === !1) return e; let n = new Uw(e, t); return this.finishScalar(n) } newScalarOr(e, t) { if (t instanceof Ww && t.value?.type === `boolean` && t.value.value === !0) return t; if (e instanceof Ww && e.value?.type === `boolean` && e.value.value === !0 || t instanceof Ww && t.value?.type === `boolean` && t.value.value === !1) return e; if (e instanceof Ww && e.value?.type === `boolean` && e.value.value === !1) return t; let n = new tT(e, t); return this.finishScalar(n) } newScalarEquals(e, t) { let n = e instanceof ST; if (t instanceof ST && !n) return this.newScalarEquals(t, e); e = this.removeUnknown(e, t.definition), t = this.removeUnknown(t, e.definition); let r = new Yw(e, t); return this.finishScalar(r) } newScalarNotEquals(e, t) { let n = e instanceof ST; if (t instanceof ST && !n) return this.newScalarNotEquals(t, e); e = this.removeUnknown(e, t.definition), t = this.removeUnknown(t, e.definition); let r = new eT(e, t); return this.finishScalar(r) } newScalarLessThan(e, t) { let n = e instanceof ST; if (t instanceof ST && !n) return this.newScalarGreaterThan(t, e); e = this.removeUnknown(e, t.definition), t = this.removeUnknown(t, e.definition); let r = new Qw(e, t); return this.finishScalar(r) } newScalarLessThanOrEqual(e, t) { let n = e instanceof ST; if (t instanceof ST && !n) return this.newScalarGreaterThanOrEqual(t, e); e = this.removeUnknown(e, t.definition), t = this.removeUnknown(t, e.definition); let r = new $w(e, t); return this.finishScalar(r) } newScalarGreaterThan(e, t) { let n = e instanceof ST; if (t instanceof ST && !n) return this.newScalarLessThan(t, e); e = this.removeUnknown(e, t.definition), t = this.removeUnknown(t, e.definition); let r = new Xw(e, t); return this.finishScalar(r) } newScalarGreaterThanOrEqual(e, t) { let n = e instanceof ST; if (t instanceof ST && !n) return this.newScalarLessThanOrEqual(t, e); e = this.removeUnknown(e, t.definition), t = this.removeUnknown(t, e.definition); let r = new Zw(e, t); return this.finishScalar(r) } newScalarIn(e, t) { t.definition.type === `array` && (e = this.removeUnknown(e, t.definition.definition)); let n = { type: `array`, isNullable: !0, definition: e.definition }; t = this.removeUnknown(t, n); let r = new mT(e, t); return this.finishScalar(r) } newScalarNotIn(e, t) { t.definition.type === `array` && (e = this.removeUnknown(e, t.definition.definition)); let n = { type: `array`, isNullable: !0, definition: e.definition }; t = this.removeUnknown(t, n); let r = new xT(e, t); return this.finishScalar(r) } newScalarCase(e, t, n) { if (e) { let n = []; for (let { when: r, then: i } of t) { let t = new Pw(this.removeUnknown(r, e.definition), i); n.push(t) } t = n } let r = new Fw(e, t, n); return this.finishScalar(r) } newScalarContains(e, t) { let n = new Kw(e, t); return this.finishScalar(n) } newScalarStartsWith(e, t) { let n = new rT(e, t); return this.finishScalar(n) } newScalarEndsWith(e, t) { let n = new Jw(e, t); return this.finishScalar(n) } newScalarLength(e) { let t = new vT(e); return this.finishScalar(t) } newScalarIndexOf(e, t) { let n = new gT(e, t); return this.finishScalar(n) } newScalarArray(e, t, n, r, i) { let a = new uT(e, t, n, r, i); return this.finishScalar(a) } newScalarFlatArray(e, t, n, r, i) { let a = new fT(e, t, n, r, i); return this.finishScalar(a) } newScalarIntersection(e, t) { let n = new _T(e, t); return this.finishScalar(n) } newScalarCast(e, t) { if (e.definition.type === t.type) return e; let n = new dT(e, t); return this.finishScalar(n) } }, wT = class extends hw { }, TT = class e extends wT { constructor(e, t, n) { super(!1), this.input = e, this.fields = t, this.resolver = n, M(this, `inputGroup`), this.inputGroup = e.getGroup() } getHash() { return G(`EnforcerResolve`, this.inputGroup.id, this.fields) } getOutputFields() { return this.inputGroup.relational.outputFields } canProvideOrdering() { return !0 } canProvideResolvedFields(e) { return e.subsetOf(this.fields) } getInputRequiredProps(e) { let t = new $; return new Tw(e.ordering, t) } optimize(e, t) { let n = this.getInputRequiredProps(t), r = e.optimizeGroup(this.inputGroup, n); return Q.estimate(0, 100 * dw).add(r) } getOptimized(t) { let n = this.getInputRequiredProps(t); return new e(this.inputGroup.getOptimized(n), this.fields, this.resolver) } *evaluate(e) { let t = yield* this.input.evaluate(e); B(this.fields.subsetOf(t.fields), `Fields can't be resolved`); let n = new Set; for (let e of this.fields) B(e.collection, `Collection required to resolve field`), n.add(e.collection); for (let e of t.tuples) for (let t of this.fields) { let n = e.getValue(t); n?.type === `richtext` ? this.resolver.preloadRichTextValue(n) : n?.type === `vectorsetitem` && this.resolver.preloadVectorSetItemValue(n) } let r = yield Promise.all(Array.from(n).map(async e => { let n = []; for (let r of t.tuples) { let t = r.getPointer(e); t && n.push(t) } let r = await e.data.resolveItems(n); return B(r.length === n.length, `Invalid number of items`), [e, r] })); return t.map(t.fields, e => { let t = new Dw; t.merge(e); for (let [n, i] of r) { let r = e.getPointer(n); if (!r) continue; let a = i.shift(); B(a, `Item not found`), B(a.pointer === r, `Pointer mismatch`); for (let e of n.fields) { let n = e.getValue(a); t.addValue(e, n) } } return t }) } }, ET = { type: 0 }, DT = class e extends wT { constructor(e, t) { super(e.isSynchronous), this.input = e, this.ordering = t, M(this, `inputGroup`), this.inputGroup = e.getGroup() } getHash() { return G(`EnforcerSort`, this.inputGroup.id, this.ordering) } getOutputFields() { return this.inputGroup.relational.outputFields } canProvideOrdering(e) { return e.equals(this.ordering) } canProvideResolvedFields() { return !0 } getInputRequiredProps(e) { let t = new $(e.resolvedFields); for (let { field: e } of this.ordering.fields) e.name !== _w && ($e(e.collection) || t.add(e)); return new Tw(new ww, t) } optimize(e, t) { let n = this.getInputRequiredProps(t), r = e.optimizeGroup(this.inputGroup, n); return new Q(0).add(r) } getOptimized(t) { let n = this.getInputRequiredProps(t); return new e(this.inputGroup.getOptimized(n), this.ordering) } *evaluate(e) { return (yield* this.input.evaluate(e)).sort((e, t) => { for (let { field: n, direction: r } of this.ordering.fields) { let i = r === `asc`; if (n.name === _w) { let r = n.collection; B(r, `Collection required for sorting`); let a = e.getPointer(r); B(a, `Pointer required for sorting`); let o = { pointer: a, data: {} }, s = t.getPointer(r); B(s, `Pointer required for sorting`); let c = { pointer: s, data: {} }, l = r.data.compareItems(o, c); return i ? l : -l } let a = e.getValue(n), o = t.getValue(n); if (!iw.equal(a, o, ET)) { if (et(a) || iw.lessThan(a, o, ET)) return i ? -1 : 1; if (et(o) || iw.greaterThan(a, o, ET)) return i ? 1 : -1; throw Error(`Invalid comparison`) } } return 0 }) } }, OT = class { constructor(e, t, n) { this.query = e, this.locale = t, this.resolver = n, M(this, `memo`, new oT), M(this, `normalizer`, new CT(this.memo)), M(this, `explorer`, new iT(this.normalizer)) } optimize() { let e = new Iw(this.normalizer, this.query, this.locale).build(), t = e.takeNode().getGroup(), n = e.getRequiredProps(); return this.optimizeGroup(t, n), [t.getOptimized(n), e.getNamedFields()] } optimizeGroup(e, t) { let n = e.getWinner(t); if (n.node) return n.cost; let r = e.nodes[0]; B(r, `Normalized node not found`), this.createEnforcer(n, r, t); for (let r of e.nodes) { if (t.canProvide(r)) { let e = r.optimize(this, t); n.update(r, e) } t.isMinimal && this.explorer.explore(r) } return n.cost } createEnforcer(e, t, n) { if (n.resolvedFields.size > 0) { let r = new TT(t, n.resolvedFields, this.resolver), i = r.optimize(this, n); e.update(r, i) } if (n.ordering.length > 0) { let r = new DT(t, n.ordering), i = r.optimize(this, n); e.update(r, i) } } }, kT = ld(`query-engine`), AT = class {
        async evalQuery(e, t, n) {
            kT.enabled && kT.debug(`Query:
${jf(e)}`); let r = new gw(e, t), [i, a] = new OT(e, t, r).optimize(), o = await i.evaluateAsync(), s = Object.entries(a), c = [], l = fd(pd(o.tuples.map(e => { let t = {}, i = {}; for (let [a, o] of s) { let s = e.getValue(o); t[a] = r.resolveValue(s), n && (i[a] = s) } return n && c.push(i), W(t) }))); return n ? [at(l) ? await l : l, c] : l
        } async serializeableQuery(e, t) { return this.evalQuery(e, t, !0) } async query(e, t) { return this.evalQuery(e, t, !1) } resolveSerializableQueryResult(e, t, n) { let r = new gw(t, n); return fd(pd(e.map(e => { let t = {}, n; for (n in e) { let i = e[n]; t[n] = r.resolveValue(i) } return W(t) }))) }
    }, jT = (() => og.QueryCache)(), MT = class { constructor(e, t = 1 / 0) { this.queryEngine = e, this.maxSize = t, M(this, `cache`, new Map), M(this, `serializedCache`, lg === void 0 ? void 0 : new Map) } prune() { if (!(this.cache.size <= this.maxSize)) for (let [e, t] of this.cache) { if (this.cache.size <= this.maxSize) break; t.state !== `pending` && (this.cache.delete(e), this.serializedCache?.delete(e)) } } get(e, t) { let n = Pf(e, t), r = this.cache.get(n); if (r) { if (this.cache.delete(n), this.cache.set(n, r), lg !== void 0 && this.serializedCache !== void 0 && !Qd(n) && r.state === `fulfilled`) { let e = this.serializedCache.get(n); e !== void 0 && lg.set(jT, n, e) } return r } let i = new qh(() => { let r = Qd(n), i = r ? void 0 : rn(jT, n); if (i) try { return this.queryEngine.resolveSerializableQueryResult(i, e, t) } catch (e) { tn(e, n) } return lg !== void 0 && !r ? this.queryEngine.serializeableQuery(e, t).then(([e, t]) => (this.serializedCache?.set(n, t), lg.set(jT, n, t), e)) : this.queryEngine.query(e, t) }); return this.cache.set(n, i), this.prune(), i } }, NT = new MT(new AT), PT = `style[data-framer-breakpoint-css]`, FT = `page`, IT = Symbol(`cycle`), zT = (() => { let e = a(void 0); return e.displayName = `TickerContext`, e })(), BT = new Set([`visibleVariantId`, `obscuredVariantId`, `threshold`, `animateOnce`, `variantAppearEffectEnabled`, `targets`, `exitTarget`, `scrollDirection`]), VT = { inputRange: [], outputRange: [] }, HT = e => p.forwardRef((t, n) => { if (J.current() === J.canvas) return m(e, { ...t, ref: n }); let [r, i] = rc(t, BT), { visibleVariantId: a, obscuredVariantId: o, animateOnce: s, threshold: c, variantAppearEffectEnabled: l, targets: u, exitTarget: d, scrollDirection: f } = r, [h, g] = p.useState(o), v = p.useRef(!1), y = ts(n); return as(y, e => { r.targets || r.scrollDirection || s && v.current === !0 || v.current !== e && (v.current = e, p.startTransition(() => { g(e ? a : o) })) }, { enabled: l, animateOnce: s, threshold: { y: c } }), p.useEffect(() => { if (f || !u) return; let e = {}, t; return ie((n, { y: r }) => { if (!u[0] || u[0].ref && !u[0].ref.current) return; let { inputRange: i, outputRange: a } = vp(u, (c ?? 0) * r.containerLength, d); if (i.length === 0 || i.length !== a.length) return; let o = Math.floor(Me(r.current, i, a)); if (s && e[o]) return; e[o] = !0; let l = u[o]?.target ?? void 0; l !== t && (t = l, p.startTransition(() => { g(l) })) }) }, [s, c, u, t.variant, f, d]), kc(f, e => p.startTransition(() => g(e)), { enabled: l, repeat: !s }), At(() => { if (!l) return; let e = !r.targets && !r.scrollDirection ? r.obscuredVariantId : void 0; _(() => g(e)) }), !(`variantAppearEffectEnabled` in r) || l === !0 ? m(e, { ...i, variant: h ?? t.variant, ref: y }) : m(e, { ...i }) }), UT = p.createContext(void 0), WT = () => p.useContext(UT), GT = { Arial: { Regular: { selector: `Arial`, weight: void 0 }, Black: { selector: `Arial-Black`, weight: void 0 }, Narrow: { selector: `Arial Narrow`, weight: void 0 }, "Rounded Bold": { selector: `Arial Rounded MT Bold`, weight: void 0 } }, Avenir: { Book: { selector: `Avenir`, weight: void 0 }, Light: { selector: `Avenir-Light`, weight: void 0 }, Medium: { selector: `Avenir-Medium`, weight: void 0 }, Heavy: { selector: `Avenir-Heavy`, weight: void 0 }, Black: { selector: `Avenir-Black`, weight: void 0 } }, "Avenir Next": { Regular: { selector: `Avenir Next`, weight: void 0 }, "Ultra Light": { selector: `AvenirNext-UltraLight`, weight: void 0 }, Medium: { selector: `AvenirNext-Medium`, weight: void 0 }, "Demi Bold": { selector: `AvenirNext-DemiBold`, weight: void 0 }, Heavy: { selector: `AvenirNext-Heavy`, weight: void 0 } }, "Avenir Next Condensed": { Regular: { selector: `Avenir Next Condensed`, weight: void 0 }, "Ultra Light": { selector: `AvenirNextCondensed-UltraLight`, weight: void 0 }, Medium: { selector: `AvenirNextCondensed-Medium`, weight: void 0 }, "Demi Bold": { selector: `AvenirNextCondensed-DemiBold`, weight: void 0 }, Heavy: { selector: `AvenirNextCondensed-Heavy`, weight: void 0 } }, Baskerville: { Regular: { selector: `Baskerville`, weight: void 0 }, "Semi Bold": { selector: `Baskerville-SemiBold`, weight: void 0 } }, "Bodoni 72": { Book: { selector: `Bodoni 72`, weight: void 0 }, Oldstyle: { selector: `Bodoni 72 Oldstyle`, weight: void 0 }, Smallcaps: { selector: `Bodoni 72 Smallcaps`, weight: void 0 } }, Courier: { Regular: { selector: `Courier`, weight: void 0 } }, "Courier New": { Regular: { selector: `Courier New`, weight: void 0 } }, Futura: { Medium: { selector: `Futura`, weight: void 0 }, Condensed: { selector: `Futura-CondensedMedium`, weight: void 0 }, "Condensed ExtraBold": { selector: `Futura-CondensedExtraBold`, weight: void 0 } }, Georgia: { Regular: { selector: `Georgia`, weight: void 0 } }, "Gill Sans": { Regular: { selector: `Gill Sans`, weight: void 0 }, Light: { selector: `GillSans-Light`, weight: void 0 }, SemiBold: { selector: `GillSans-SemiBold`, weight: void 0 }, UltraBold: { selector: `GillSans-UltraBold`, weight: void 0 } }, Helvetica: { Regular: { selector: `Helvetica`, weight: void 0 }, Light: { selector: `Helvetica-Light`, weight: void 0 }, Bold: { selector: `Helvetica-Bold`, weight: void 0 }, Oblique: { selector: `Helvetica-Oblique`, weight: void 0 }, "Light Oblique": { selector: `Helvetica-LightOblique`, weight: void 0 }, "Bold Oblique": { selector: `Helvetica-BoldOblique`, weight: void 0 } }, "Helvetica Neue": { Regular: { selector: `Helvetica Neue`, weight: void 0 }, UltraLight: { selector: `HelveticaNeue-UltraLight`, weight: void 0 }, Thin: { selector: `HelveticaNeue-Thin`, weight: void 0 }, Light: { selector: `HelveticaNeue-Light`, weight: void 0 }, Medium: { selector: `HelveticaNeue-Medium`, weight: void 0 }, Bold: { selector: `HelveticaNeue-Bold`, weight: void 0 }, Italic: { selector: `HelveticaNeue-Italic`, weight: void 0 }, "UltraLight Italic": { selector: `HelveticaNeue-UltraLightItalic`, weight: void 0 }, "Thin Italic": { selector: `HelveticaNeue-ThinItalic`, weight: void 0 }, "Light Italic": { selector: `HelveticaNeue-LightItalic`, weight: void 0 }, "Medium Italic": { selector: `HelveticaNeue-MediumItalic`, weight: void 0 }, "Bold Italic": { selector: `HelveticaNeue-BoldItalic`, weight: void 0 }, "Condensed Bold": { selector: `HelveticaNeue-CondensedBold`, weight: void 0 }, "Condensed Black": { selector: `HelveticaNeue-CondensedBlack`, weight: void 0 } }, "Hoefler Text": { Regular: { selector: `Hoefler Text`, weight: void 0 } }, Impact: { Regular: { selector: `Impact`, weight: void 0 } }, "Lucida Grande": { Regular: { selector: `Lucida Grande`, weight: void 0 } }, Menlo: { Regular: { selector: `Menlo`, weight: void 0 } }, Monaco: { Regular: { selector: `Monaco`, weight: void 0 } }, Optima: { Regular: { selector: `Optima`, weight: void 0 }, ExtraBlack: { selector: `Optima-ExtraBlack`, weight: void 0 } }, Palatino: { Regular: { selector: `Palatino`, weight: void 0 } }, "SF Pro Display": { Regular: { selector: `__SF-UI-Display-Regular__`, weight: 400 }, Ultralight: { selector: `__SF-UI-Display-Ultralight__`, weight: 100 }, Thin: { selector: `__SF-UI-Display-Thin__`, weight: 200 }, Light: { selector: `__SF-UI-Display-Light__`, weight: 300 }, Medium: { selector: `__SF-UI-Display-Medium__`, weight: 500 }, Semibold: { selector: `__SF-UI-Display-Semibold__`, weight: 600 }, Bold: { selector: `__SF-UI-Display-Bold__`, weight: 700 }, Heavy: { selector: `__SF-UI-Display-Heavy__`, weight: 800 }, Black: { selector: `__SF-UI-Display-Black__`, weight: 900 }, Italic: { selector: `__SF-UI-Display-Italic__`, weight: 400 }, "Ultralight Italic": { selector: `__SF-UI-Display-Ultralight-Italic__`, weight: 100 }, "Thin Italic": { selector: `__SF-UI-Display-Thin-Italic__`, weight: 200 }, "Light Italic": { selector: `__SF-UI-Display-Light-Italic__`, weight: 300 }, "Medium Italic": { selector: `__SF-UI-Display-Medium-Italic__`, weight: 500 }, "Semibold Italic": { selector: `__SF-UI-Display-Semibold-Italic__`, weight: 600 }, "Bold Italic": { selector: `__SF-UI-Display-Bold-Italic__`, weight: 700 }, "Heavy Italic": { selector: `__SF-UI-Display-Heavy-Italic__`, weight: 800 }, "Black Italic": { selector: `__SF-UI-Display-Black-Italic__`, weight: 900 } }, "SF Pro Display Condensed": { Regular: { selector: `__SF-UI-Display-Condensed-Regular__`, weight: 400 }, Ultralight: { selector: `__SF-UI-Display-Condensed-Ultralight__`, weight: 100 }, Thin: { selector: `__SF-UI-Display-Condensed-Thin__`, weight: 200 }, Light: { selector: `__SF-UI-Display-Condensed-Light__`, weight: 300 }, Medium: { selector: `__SF-UI-Display-Condensed-Medium__`, weight: 500 }, Semibold: { selector: `__SF-UI-Display-Condensed-Semibold__`, weight: 600 }, Bold: { selector: `__SF-UI-Display-Condensed-Bold__`, weight: 700 }, Heavy: { selector: `__SF-UI-Display-Condensed-Heavy__`, weight: 800 }, Black: { selector: `__SF-UI-Display-Condensed-Black__`, weight: 900 } }, "SF Pro Text": { Regular: { selector: `__SF-UI-Text-Regular__`, weight: 400 }, Light: { selector: `__SF-UI-Text-Light__`, weight: 200 }, Medium: { selector: `__SF-UI-Text-Medium__`, weight: 500 }, Semibold: { selector: `__SF-UI-Text-Semibold__`, weight: 600 }, Bold: { selector: `__SF-UI-Text-Bold__`, weight: 700 }, Heavy: { selector: `__SF-UI-Text-Heavy__`, weight: 800 }, Italic: { selector: `__SF-UI-Text-Italic__`, weight: 400 }, "Light Italic": { selector: `__SF-UI-Text-Light-Italic__`, weight: 200 }, "Medium Italic": { selector: `__SF-UI-Text-Medium-Italic__`, weight: 500 }, "Semibold Italic": { selector: `__SF-UI-Text-Semibold-Italic__`, weight: 600 }, "Bold Italic": { selector: `__SF-UI-Text-Bold-Italic__`, weight: 700 }, "Heavy Italic": { selector: `__SF-UI-Text-Heavy-Italic__`, weight: 800 } }, "SF Pro Text Condensed": { Regular: { selector: `__SF-UI-Text-Condensed-Regular__`, weight: 400 }, Light: { selector: `__SF-UI-Text-Condensed-Light__`, weight: 200 }, Medium: { selector: `__SF-UI-Text-Condensed-Medium__`, weight: 500 }, Semibold: { selector: `__SF-UI-Text-Condensed-Semibold__`, weight: 600 }, Bold: { selector: `__SF-UI-Text-Condensed-Bold__`, weight: 700 }, Heavy: { selector: `__SF-UI-Text-Condensed-Heavy__`, weight: 800 } }, Tahoma: { Regular: { selector: `Tahoma`, weight: void 0 } }, Times: { Regular: { selector: `Times`, weight: void 0 } }, "Times New Roman": { Regular: { selector: `Times New Roman`, weight: void 0 } }, Trebuchet: { Regular: { selector: `Trebuchet MS`, weight: void 0 } }, Verdana: { Regular: { selector: `Verdana`, weight: void 0 } } }, KT = { "__SF-Compact-Display-Regular__": `SFCompactDisplay-Regular|.SFCompactDisplay-Regular`, "__SF-Compact-Display-Ultralight__": `SFCompactDisplay-Ultralight|.SFCompactDisplay-Ultralight`, "__SF-Compact-Display-Thin__": `SFCompactDisplay-Thin|.SFCompactDisplay-Thin`, "__SF-Compact-Display-Light__": `SFCompactDisplay-Light|.SFCompactDisplay-Light`, "__SF-Compact-Display-Medium__": `SFCompactDisplay-Medium|.SFCompactDisplay-Medium`, "__SF-Compact-Display-Semibold__": `SFCompactDisplay-Semibold|.SFCompactDisplay-Semibold`, "__SF-Compact-Display-Heavy__": `SFCompactDisplay-Heavy|.SFCompactDisplay-Heavy`, "__SF-Compact-Display-Black__": `SFCompactDisplay-Black|.SFCompactDisplay-Black`, "__SF-Compact-Display-Bold__": `SFCompactDisplay-Bold|.SFCompactDisplay-Bold`, "__SF-UI-Text-Regular__": `.SFNSText|SFProText-Regular|SFUIText-Regular|.SFUIText`, "__SF-UI-Text-Light__": `.SFNSText-Light|SFProText-Light|SFUIText-Light|.SFUIText-Light`, "__SF-UI-Text-Medium__": `.SFNSText-Medium|SFProText-Medium|SFUIText-Medium|.SFUIText-Medium`, "__SF-UI-Text-Semibold__": `.SFNSText-Semibold|SFProText-Semibold|SFUIText-Semibold|.SFUIText-Semibold`, "__SF-UI-Text-Bold__": `.SFNSText-Bold|SFProText-Bold|SFUIText-Bold|.SFUIText-Bold`, "__SF-UI-Text-Heavy__": `.SFNSText-Heavy|SFProText-Heavy|.SFUIText-Heavy`, "__SF-UI-Text-Italic__": `.SFNSText-Italic|SFProText-Italic|SFUIText-Italic|.SFUIText-Italic`, "__SF-UI-Text-Light-Italic__": `.SFNSText-LightItalic|SFProText-LightItalic|SFUIText-LightItalic|.SFUIText-LightItalic`, "__SF-UI-Text-Medium-Italic__": `.SFNSText-MediumItalic|SFProText-MediumItalic|SFUIText-MediumItalic|.SFUIText-MediumItalic`, "__SF-UI-Text-Semibold-Italic__": `.SFNSText-SemiboldItalic|SFProText-SemiboldItalic|SFUIText-SemiboldItalic|.SFUIText-SemiboldItalic`, "__SF-UI-Text-Bold-Italic__": `.SFNSText-BoldItalic|SFProText-BoldItalic|SFUIText-BoldItalic|.SFUIText-BoldItalic`, "__SF-UI-Text-Heavy-Italic__": `.SFNSText-HeavyItalic|SFProText-HeavyItalic|.SFUIText-HeavyItalic`, "__SF-Compact-Text-Regular__": `SFCompactText-Regular|.SFCompactText-Regular`, "__SF-Compact-Text-Light__": `SFCompactText-Light|.SFCompactText-Light`, "__SF-Compact-Text-Medium__": `SFCompactText-Medium|.SFCompactText-Medium`, "__SF-Compact-Text-Semibold__": `SFCompactText-Semibold|.SFCompactText-Semibold`, "__SF-Compact-Text-Bold__": `SFCompactText-Bold|.SFCompactText-Bold`, "__SF-Compact-Text-Heavy__": `SFCompactText-Heavy|.SFCompactText-Heavy`, "__SF-Compact-Text-Italic__": `SFCompactText-Italic|.SFCompactText-Italic`, "__SF-Compact-Text-Light-Italic__": `SFCompactText-LightItalic|.SFCompactText-LightItalic`, "__SF-Compact-Text-Medium-Italic__": `SFCompactText-MediumItalic|.SFCompactText-MediumItalic`, "__SF-Compact-Text-Semibold-Italic__": `SFCompactText-SemiboldItalic|.SFCompactText-SemiboldItalic`, "__SF-Compact-Text-Bold-Italic__": `SFCompactText-BoldItalic|.SFCompactText-BoldItalic`, "__SF-Compact-Text-Heavy-Italic__": `SFCompactText-HeavyItalic|.SFCompactText-HeavyItalic`, "__SF-UI-Display-Condensed-Regular__": `.SFNSDisplayCondensed-Regular|SFUIDisplayCondensed-Regular|.SFUIDisplayCondensed-Regular`, "__SF-UI-Display-Condensed-Ultralight__": `.SFNSDisplayCondensed-Ultralight|SFUIDisplayCondensed-Ultralight|.SFUIDisplayCondensed-Ultralight`, "__SF-UI-Display-Condensed-Thin__": `.SFNSDisplayCondensed-Thin|SFUIDisplayCondensed-Thin|.SFUIDisplayCondensed-Thin`, "__SF-UI-Display-Condensed-Light__": `.SFNSDisplayCondensed-Light|SFUIDisplayCondensed-Light|.SFUIDisplayCondensed-Light`, "__SF-UI-Display-Condensed-Medium__": `.SFNSDisplayCondensed-Medium|SFUIDisplayCondensed-Medium|.SFUIDisplayCondensed-Medium`, "__SF-UI-Display-Condensed-Semibold__": `.SFNSDisplayCondensed-Semibold|SFUIDisplayCondensed-Semibold|.SFUIDisplayCondensed-Semibold`, "__SF-UI-Display-Condensed-Bold__": `.SFNSDisplayCondensed-Bold|SFUIDisplayCondensed-Bold|.SFUIDisplayCondensed-Bold`, "__SF-UI-Display-Condensed-Heavy__": `.SFNSDisplayCondensed-Heavy|SFUIDisplayCondensed-Heavy|.SFUIDisplayCondensed-Heavy`, "__SF-UI-Display-Condensed-Black__": `.SFNSDisplayCondensed-Black|.SFUIDisplayCondensed-Black`, "__SF-UI-Display-Regular__": `.SFNSDisplay|SFProDisplay-Regular|SFUIDisplay-Regular|.SFUIDisplay`, "__SF-UI-Display-Ultralight__": `.SFNSDisplay-Ultralight|SFProDisplay-Ultralight|SFUIDisplay-Ultralight|.SFUIDisplay-Ultralight`, "__SF-UI-Display-Thin__": `.SFNSDisplay-Thin|SFProDisplay-Thin|SFUIDisplay-Thin|.SFUIDisplay-Thin`, "__SF-UI-Display-Light__": `.SFNSDisplay-Light|SFProDisplay-Light|SFUIDisplay-Light|.SFUIDisplay-Light`, "__SF-UI-Display-Medium__": `.SFNSDisplay-Medium|SFProDisplay-Medium|SFUIDisplay-Medium|.SFUIDisplay-Medium`, "__SF-UI-Display-Semibold__": `.SFNSDisplay-Semibold|SFProDisplay-Semibold|SFUIDisplay-Semibold|.SFUIDisplay-Semibold`, "__SF-UI-Display-Bold__": `.SFNSDisplay-Bold|SFProDisplay-Bold|SFUIDisplay-Bold|.SFUIDisplay-Bold`, "__SF-UI-Display-Heavy__": `.SFNSDisplay-Heavy|SFProDisplay-Heavy|SFUIDisplay-Heavy|.SFUIDisplay-Heavy`, "__SF-UI-Display-Black__": `.SFNSDisplay-Black|SFProDisplay-Black|.SFUIDisplay-Black`, "__SF-UI-Display-Italic__": `.SFNSDisplay-Italic|SFProDisplay-Italic|SFUIDisplay-Italic`, "__SF-UI-Display-Ultralight-Italic__": `.SFNSDisplay-UltralightItalic|SFProDisplay-UltralightItalic|SFUIDisplay-UltralightItalic|.SFUIDisplay-UltralightItalic`, "__SF-UI-Display-Thin-Italic__": `.SFNSDisplay-ThinItalic|SFProDisplay-ThinItalic|SFUIDisplay-ThinItalic|.SFUIDisplay-ThinItalic`, "__SF-UI-Display-Light-Italic__": `.SFNSDisplay-LightItalic|SFProDisplay-LightItalic|SFUIDisplay-LightItalic|.SFUIDisplay-LightItalic`, "__SF-UI-Display-Medium-Italic__": `.SFNSDisplay-MediumItalic|SFProDisplay-MediumItalic|SFUIDisplay-MediumItalic|.SFUIDisplay-MediumItalic`, "__SF-UI-Display-Semibold-Italic__": `.SFNSDisplay-SemiboldItalic|SFProDisplay-SemiboldItalic|SFUIDisplay-SemiboldItalic|.SFUIDisplay-SemiboldItalic`, "__SF-UI-Display-Bold-Italic__": `.SFNSDisplay-BoldItalic|SFProDisplay-BoldItalic|SFUIDisplay-BoldItalic|.SFUIDisplay-BoldItalic`, "__SF-UI-Display-Heavy-Italic__": `.SFNSDisplay-HeavyItalic|SFProDisplay-HeavyItalic|SFUIDisplay-HeavyItalic|.SFUIDisplay-HeavyItalic`, "__SF-UI-Display-Black-Italic__": `.SFNSDisplay-BlackItalic|SFProDisplay-BlackItalic|.SFUIDisplay-BlackItalic`, "__SF-UI-Text-Condensed-Regular__": `.SFNSTextCondensed-Regular|SFUITextCondensed-Regular|.SFUITextCondensed-Regular`, "__SF-UI-Text-Condensed-Light__": `.SFNSTextCondensed-Light|SFUITextCondensed-Light|.SFUITextCondensed-Light`, "__SF-UI-Text-Condensed-Medium__": `.SFNSTextCondensed-Medium|SFUITextCondensed-Medium|.SFUITextCondensed-Medium`, "__SF-UI-Text-Condensed-Semibold__": `.SFNSTextCondensed-Semibold|SFUITextCondensed-Semibold|.SFUITextCondensed-Semibold`, "__SF-UI-Text-Condensed-Bold__": `.SFNSTextCondensed-Bold|SFUITextCondensed-Bold|.SFUITextCondensed-Bold`, "__SF-UI-Text-Condensed-Heavy__": `.SFNSTextCondensed-Heavy|.SFUITextCondensed-Heavy`, "__SF-Compact-Rounded-Regular__": `SFCompactRounded-Regular|.SFCompactRounded-Regular`, "__SF-Compact-Rounded-Ultralight__": `SFCompactRounded-Ultralight|.SFCompactRounded-Ultralight`, "__SF-Compact-Rounded-Thin__": `SFCompactRounded-Thin|.SFCompactRounded-Thin`, "__SF-Compact-Rounded-Light__": `SFCompactRounded-Light|.SFCompactRounded-Light`, "__SF-Compact-Rounded-Medium__": `SFCompactRounded-Medium|.SFCompactRounded-Medium`, "__SF-Compact-Rounded-Semibold__": `SFCompactRounded-Semibold|.SFCompactRounded-Semibold`, "__SF-Compact-Rounded-Bold__": `SFCompactRounded-Bold|.SFCompactRounded-Bold`, "__SF-Compact-Rounded-Heavy__": `SFCompactRounded-Heavy|.SFCompactRounded-Heavy`, "__SF-Compact-Rounded-Black__": `SFCompactRounded-Black|.SFCompactRounded-Black` }, qT = GT, JT = `System Default`, YT = class { constructor() { M(this, `name`, `local`), M(this, `fontFamilies`, []), M(this, `byFamilyName`, new Map), M(this, `fontAliasBySelector`, new Map), M(this, `fontAliases`, new Map) } getFontFamilyByName(e) { return this.byFamilyName.get(e) ?? null } createFontFamily(e) { let t = { name: e, fonts: [], source: this.name }; return this.addFontFamily(t), t } addFontFamily(e) { this.fontFamilies.push(e), this.byFamilyName.set(e.name, e) } importFonts() { let e = []; for (let t of Object.keys(qT)) { let n = qT[t]; if (!n) continue; let r = this.createFontFamily(t); for (let e of Object.keys(n)) { let t = n[e]; if (!t) continue; let { selector: i, weight: a } = t, o = { variant: e, selector: i, weight: a, family: r, cssFamilyName: r.name }; r.fonts.push(o) } e.push(...r.fonts) } for (let [e, t] of Object.entries(KT)) this.addFontAlias(e, t); let { fontFamily: t, aliases: n } = this.getSystemFontFamily(); this.addFontFamily(t); for (let [e, t] of n) this.addFontAlias(e, t); return e.push(...t.fonts), e } addFontAlias(e, t) { this.fontAliases.set(e, t), this.fontAliasBySelector.set(t, e) } getSystemFontFamily() { let e = { name: JT, fonts: [], source: this.name }, t = new Map, n = [400, 100, 200, 300, 500, 600, 700, 800, 900]; for (let r of [`normal`, `italic`]) for (let i of n) { let n = bp(i, r), a = `__SystemDefault-${i}-${r}__`, o = { variant: n, selector: a, style: r, weight: i, family: e, cssFamilyName: e.name }; e.fonts.push(o), t.set(a, `system-ui|-apple-system|BlinkMacSystemFont|Segoe UI|Roboto|Oxygen|Ubuntu|Cantarell|Fira Sans|Droid Sans|Helvetica Neue|sans-serif`) } return { fontFamily: e, aliases: t } } getFontAliasBySelector(e) { return this.fontAliasBySelector.get(e) || null } getFontSelectorByAlias(e) { return this.fontAliases.get(e) || null } isFontFamilyAlias(e) { return !!(e && /^__.*__$/u.exec(e)) } }, XT = { 100: `Thin`, 200: `Extra Light`, 300: `Light`, 400: `Normal`, 500: `Medium`, 600: `Semi Bold`, 700: `Bold`, 800: `Extra Bold`, 900: `Black` }, ZT = class extends Map { constructor() { super(...arguments), M(this, `_hash`, 0) } get hash() { return this._hash } set(e, t) { return this._hash++, super.set(e, t) } delete(e) { return this._hash++, super.delete(e) } clear() { return this._hash++, super.clear() } }, $T = `Variable`, eE = `BI;`, tE = class { constructor() { M(this, `name`, `builtIn`), M(this, `fontFamilies`, []), M(this, `byFamilyName`, new Map), M(this, `assetByKey`, new Map) } importFonts(e) { this.fontFamilies.length = 0, this.byFamilyName.clear(), this.assetByKey.clear(); let t = []; for (let n of e) { if (!this.isValidBuiltInFont(n)) continue; let { properties: e } = n, r = e.font.fontFamily, i = this.createFontFamily(r, e.font.foundryName, e.font.fontVersion), a = e.font.openTypeData, o = e.font.variationAxes, s = Array.isArray(o), c = s ? `variable` : e.font.fontSubFamily || `regular`, l = Tp(n), u = { assetKey: n.key, family: i, selector: this.createSelector(r, c, e.font.fontVersion), variant: c, file: l, hasOpenTypeFeatures: Op(a), variationAxes: kp(o), category: e.font.fontCategory, weight: Mp(c), style: Pp(c), cssFamilyName: Ep(r, s) }; i.fonts.push(u), this.assetByKey.set(n.key, n), t.push(u) } for (let e of this.fontFamilies) e.fonts.sort((e, t) => { let n = Mp(e.variant), r = Mp(t.variant); return !n || !r ? 1 : n - r }); return t } static parseVariant(e) { return { weight: nE[Np(e)], style: Pp(e) } } getFontBySelector(e) { let t = this.parseSelector(e); if (!t) return; let n = this.getFontFamilyByName(t.name); if (n) return n.fonts.find(t => t.selector === e) } getFontFamilyByName(e) { return this.byFamilyName.get(e) ?? null } createFontFamily(e, t, n) { let r = this.byFamilyName.get(e); if (r && r.version === n) return r; let i = { source: this.name, name: e, fonts: [], foundryName: t, version: n }; return this.addFontFamily(i), i } getOpenTypeFeatures(e) { B(e.assetKey, `Font must have an asset key`); let t = this.assetByKey.get(e.assetKey)?.properties?.font?.openTypeData; return Op(t) ? t?.map(e => { if (Ap(e)) return { tag: e.tag, coverage: e.coverage } }) : [] } isValidBuiltInFont(e) { return !e.mimeType.startsWith(`font/`) || e.properties?.kind !== `font` || !e.properties.font || !e.properties.font.fontVersion || !e.properties.font.fontFamily ? !1 : `fontFamily` in e.properties.font } createSelector(e, t, n) { return `${eE}${e}/${t}/${n}` } parseSelector(e) { if (!e.startsWith(eE)) return null; let [t, n] = e.split(eE); if (n === void 0) return null; let [r, i, a] = n.split(`/`); return !r || !i || !a ? null : { name: r, variant: i, source: this.name, isVariable: i.toLowerCase().includes(`variable`) } } addFontFamily(e) { this.fontFamilies.push(e), this.byFamilyName.set(e.name, e) } }, nE = { ultralight: 100, "ultralight-italic": 100, thin: 200, "thin-italic": 200, demi: 200, light: 300, "light-italic": 300, normal: 350, base: 400, regular: 400, classic: 400, "regular-slanted": 400, italic: 400, oblique: 400, dense: 400, brukt: 300, book: 400, "book-italic": 400, text: 400, "text-italic": 400, medium: 500, solid: 500, "medium-oblique": 500, "medium-italic": 500, mittel: 500, semibold: 600, "semibold-italic": 600, bold: 700, "bold-italic": 700, "bold-oblique": 700, fett: 700, ultrabold: 800, "ultrabold-italic": 800, extrabold: 800, "extrabold-italic": 800, black: 900, extralight: 100, "extralight-italic": 100, "black-italic": 900, "extra-italic": 900, "extra-italic-bold": 900, satt: 900, heavy: 900, "heavy-italic": 900, serif: 100, school: 200, expanded: 300, gothique: 500, "dense-light": 200, "dense-regular": 300, "dense-medium": 400, "dense-bold": 500, "solid-light": 600, "solid-regular": 700, "solid-medium": 800, "solid-bold": 900, 53: 400, 55: 600, "narrow-regular": 350, "narrow-black": 850, variable: 1e3, "variable-italic": 1e3 }, rE = ld(`custom-font-source`), iE = `CUSTOM;`, aE = `CUSTOMV2;`, oE = class e { constructor() { M(this, `name`, `custom`), M(this, `fontFamilies`, []), M(this, `byFamilyName`, new Map), M(this, `assetsByKey`, new Map) } deprecatedImportFonts(t) { this.fontFamilies.length = 0, this.byFamilyName.clear(), this.assetsByKey.clear(); let n = []; for (let r of t) { if (!this.isValidCustomFontAsset(r)) continue; let t = r.properties?.font.variationAxes, i = Array.isArray(t), a = Up(r.properties), o = this.createFontFamily(a), s = r.properties?.font.openTypeData, c = i ? `variable` : this.inferVariantName(a), l = Tp(r), u = e.createLegacySelector(a), { family: d, variant: f } = Wp(r.properties.font), p = e.createSelector(d, f), m = { assetKey: r.key, family: o, selector: u, variant: c, file: l, hasOpenTypeFeatures: Op(s), variationAxes: kp(t), owner: qp(r), cssFamilyName: e.cssFontFamilyFromSelector(u), alternativeSelectors: { [p]: { variant: f, cssFamilyName: e.cssFontFamilyFromSelector(p) } } }; o.fonts.push(m), this.assetsByKey.set(r.key, r), n.push(...o.fonts) } return n } importFonts(t, n) { if (!n) return this.deprecatedImportFonts(t); this.fontFamilies.length = 0, this.byFamilyName.clear(), this.assetsByKey.clear(); let r = {}; for (let n of t) { if (!this.isValidCustomFontAsset(n)) continue; let { family: t, variant: i, weight: a, style: o } = Wp(n.properties.font), s = n.properties.font.variationAxes, c = Array.isArray(s), l = n.properties.font.openTypeData, u = Tp(n), d = qp(n), f = Up(n.properties), p = e.createLegacySelector(f), m = this.createFontFamily(t), h = e.createSelector(m.name, i), g = { assetKey: n.key, family: m, selector: h, variant: i, weight: a, style: o, file: u, hasOpenTypeFeatures: Op(l), variationAxes: kp(s), owner: d, alternativeSelectors: { [p]: { variant: c ? `variable` : this.inferVariantName(f), cssFamilyName: e.cssFontFamilyFromSelector(p) } }, cssFamilyName: e.cssFontFamilyFromSelector(h) }, _ = Hp(m.fonts, g); if (_?.projectDuplicate) g.owner === `project` && (m.fonts[_.index] = g, r[h] = g); else if (_) { rE.debug(`Duplicate font found for:`, g, `with existing font:`, _.existingFont); let e = _.existingFont, t = g.file?.endsWith(`.woff2`) ?? !1, n = e.file?.endsWith(`.woff2`) ?? !1; t && !n && (m.fonts[_.index] = g, r[h] = g) } else m.fonts.push(g), r[h] = g; this.assetsByKey.set(n.key, n) } for (let e of this.fontFamilies) e.fonts.length > 0 && Kp(e); return Object.values(r) } static createSelector(e, t) { return `${aE}${e}${t ? ` ${t}` : ``}` } static createLegacySelector(e) { return `${iE}${e}` } static cssFontFamilyFromSelector(e) { return B(zp(e), `Selector must be a custom font selector`), Vp(e) ? e.slice(iE.length) : e.slice(aE.length) } isValidCustomFontAsset(e) { return !e.mimeType.startsWith(`font/`) || e.properties?.kind !== `font` || !e.properties.font ? !1 : `fontFamily` in e.properties.font } getOpenTypeFeatures(e) { B(e.assetKey, `Font must have an asset key`); let t = this.assetsByKey.get(e.assetKey)?.properties?.font?.openTypeData; return Op(t) ? t?.map(e => { if (Ap(e)) return { tag: e.tag, coverage: e.coverage } }) : [] } inferVariantName(e) { let t = [`thin`, `ultra light`, `extra light`, `light`, `normal`, `medium`, `semi bold`, `bold`, `extra bold`, `black`], n = [...t.map(e => `${e} italic`), ...t], r = e.toLowerCase(), i = [...r.split(` `), ...r.split(`-`), ...r.split(`_`)], a = n.find(e => i.includes(e) || i.includes(e.replace(/\s+/gu, ``))); return a ? a.replace(/^\w|\s\w/gu, e => e.toUpperCase()) : `Regular` } createFontFamily(e) { let t = this.byFamilyName.get(e); if (t) return t; let n = { source: this.name, name: e, fonts: [] }; return this.addFontFamily(n), n } addFontFamily(e) { this.fontFamilies.push(e), this.byFamilyName.set(e.name, e) } getFontFamilyByName(e) { return this.byFamilyName.get(e) || null } }, sE = [`display`, `sans`, `serif`, `slab`, `handwritten`, `script`], cE = `FS;`, lE = { thin: 100, hairline: 100, extralight: 200, light: 300, regular: 400, medium: 500, semibold: 600, bold: 700, extrabold: 800, ultra: 800, black: 900, heavy: 900 }, uE = Object.keys(lE), dE = (() => RegExp(`^(?:${[...uE, `italic`, `variable`].join(`|`)})`, `u`))(), fE = class e { constructor() { M(this, `name`, `fontshare`), M(this, `fontFamilies`, []), M(this, `byFamilyName`, new Map) } getFontFamilyByName(e) { return this.byFamilyName.get(e) ?? null } static parseVariant(e) { let t = e.toLowerCase().split(` `), n = uE.find(e => t.includes(e)), r = e.toLowerCase().includes(`italic`) ? `italic` : `normal`; return { weight: n && lE[n] || 400, style: r === `italic` ? r : `normal` } } parseSelector(e) { if (!e.startsWith(cE)) return null; let t = e.split(`-`); if (t.length !== 2) return null; let [n, r] = t; return !n || !r ? null : { name: n.replace(cE, ``), variant: r, source: this.name, isVariable: r.toLowerCase().includes(`variable`) } } static createSelector(e, t) { return `${cE}${e}-${t.toLowerCase()}` } static createMetadataSelector(e) { return `${cE}${e}` } addFontFamily(e) { this.fontFamilies.push(e), this.byFamilyName.set(e.name, e) } async importFonts(t, n) { this.fontFamilies.length = 0, this.byFamilyName.clear(); let r = await Jp(`fontshare`), i = []; for (let a of t) { let t = a.font_styles.filter(e => { let t = e.name.toLowerCase(); return !(!dE.exec(t) || t.split(` `).includes(`wide`)) }).map(t => ({ ...e.parseVariant(t.name), selector: e.createSelector(a.name, t.name), isVariable: t.is_variable, fontshareVariantName: t.name, file: t.file })), o = e.createMetadataSelector(a.name), s = n?.[o], c = a.name, l = this.getFontFamilyByName(c); l || (l = { name: c, fonts: [], source: this.name }, this.addFontFamily(l)); let u = r[e.createMetadataSelector(a.name)]; for (let e of t) { let { variantBold: n, variantBoldItalic: r, variantItalic: o, variantVariable: c, variantVariableItalic: d } = Fp(e, t), f = { family: l, variant: e.fontshareVariantName.toLowerCase(), selector: e.selector, selectorBold: n?.selector, selectorBoldItalic: r?.selector, selectorItalic: o?.selector, selectorVariable: c?.selector, selectorVariableItalic: d?.selector, weight: e.weight, style: e.style, file: e.file, category: Qp(a.category), hasOpenTypeFeatures: u, variationAxes: e.isVariable ? s : void 0, cssFamilyName: Ep(l.name, e.isVariable) }; l.fonts.push(f), i.push(f) } } return i } async getOpenTypeFeatures(t) { return (await Yp(`fontshare`))[e.createMetadataSelector(t.family.name)] } }, pE = `Inter`, mE = `FR;`, hE = { Thin: 100, ExtraLight: 200, Light: 300, "": 400, Medium: 500, SemiBold: 600, Bold: 700, ExtraBold: 800, Black: 900 }, gE = class e { constructor() { M(this, `name`, `framer`), M(this, `fontFamilies`, []), M(this, `byFamilyName`, new Map) } getFontFamilyByName(e) { return this.byFamilyName.get(e) ?? null } addFontFamily(e) { let t = { name: e, fonts: [], source: this.name }; return this.fontFamilies.push(t), this.byFamilyName.set(t.name, t), t } static getDraftFontPropertiesBySelector(e) { if (!e.startsWith(mE) && !e.startsWith(pE)) return null; let [t, n = ``] = e.split(`-`); if (!t) return null; let r = n.includes(`Italic`) ? `italic` : `normal`, i = n.replace(`Italic`, ``); return { cssFamilyName: t, style: r, weight: i && hE[i] || 400, source: `framer`, variant: void 0, category: `sans-serif` } } static createMetadataSelector(e) { return `${mE}${e}` } importFonts(t, n) { this.fontFamilies.length = 0, this.byFamilyName.clear(); let r = []; return t.forEach(t => { let { uiFamilyName: i, ...a } = t, o = e.createMetadataSelector(t.uiFamilyName), s = n?.[o], c = this.getFontFamilyByName(i); c ||= this.addFontFamily(i); let l = t.selector === t.selectorVariable || t.selector === t.selectorVariableItalic, u = { ...a, family: c, variationAxes: l ? s : void 0 }; c.fonts.push(u), r.push(u) }), r } async getOpenTypeFeatures(t) { return (await Yp(`framer`))[e.createMetadataSelector(t.family.name)] } }, _E = `GF;`, vE = class e { constructor() { M(this, `name`, `google`), M(this, `fontFamilies`, []), M(this, `byFamilyName`, new Map) } getFontFamilyByName(e) { return this.byFamilyName.get(e) ?? null } static parseVariant(e) { if (e === `regular`) return { style: `normal`, weight: 400 }; let t = /(\d*)(normal|italic)?/u.exec(e); return t ? { weight: parseInt(t[1] || `400`), style: t[2] === `italic` ? `italic` : `normal` } : {} } parseSelector(e) { if (!e.startsWith(_E)) return null; let t = e.includes(`-variable-`), n = t ? e.split(`-variable-`) : e.split(`-`); if (n.length !== 2) return null; let [r, i] = n; return !r || !i ? null : { name: r.replace(_E, ``), variant: i, source: this.name, isVariable: t } } static createSelector(e, t, n) { return `${_E}${e}-${n ? `variable-` : ``}${t}` } static createMetadataSelector(e) { return `${_E}${e}` } addFontFamily(e) { let t = { name: e, fonts: [], source: this.name }; return this.fontFamilies.push(t), this.byFamilyName.set(t.name, t), t } async importFonts(t, n, r) { this.fontFamilies.length = 0, this.byFamilyName.clear(); let i = await Jp(`google`), a = [], o = em(t, e => e.family), s = em(n, e => e.family); for (let t in o) { let n = o[t]; if (!n) continue; let c = this.getFontFamilyByName(n.family); c ||= this.addFontFamily(n.family); let l = n.variants.map(r => ({ ...e.parseVariant(r), googleFontsVariantName: r, selector: e.createSelector(t, r, !1), isVariable: !1, file: n.files[r] })), u = s[t], d = u?.axes ? u.variants.map(n => ({ ...e.parseVariant(n), googleFontsVariantName: n, selector: e.createSelector(t, n, !0), isVariable: !0, file: u.files[n] })) : [], f = e.createMetadataSelector(n.family), p = r?.[f], m = [...l, ...d], h = m.filter(yp), g = i[e.createMetadataSelector(t)]; for (let e of m) { let { weight: t, style: r, selector: i, googleFontsVariantName: o } = e, { variantBold: s, variantItalic: l, variantBoldItalic: u, variantVariable: d, variantVariableItalic: f } = (yp(e) ? Fp(e, h) : void 0) ?? {}, m = { family: c, variant: o, selector: i, selectorBold: s?.selector, selectorBoldItalic: u?.selector, selectorItalic: l?.selector, selectorVariable: d?.selector, selectorVariableItalic: f?.selector, weight: t, style: r, category: $p(n.category), file: e.file?.replace(`http://`, `https://`), variationAxes: e.isVariable ? p : void 0, hasOpenTypeFeatures: g, cssFamilyName: Ep(c.name, e.isVariable) }; c.fonts.push(m), a.push(m) } } return a } async getOpenTypeFeatures(t) { return (await Yp(`google`))[e.createMetadataSelector(t.family.name)] } }, yE = He(Oh(), 1), bE = 5e3, xE = 3, SE = class extends Error { constructor(e) { super(e), this.name = `FontLoadingError` } }, CE = new Map, wE = new Map, TE = (e, t) => tm(e, t), EE = { "FR;Inter": [{ tag: `opsz`, minValue: 14, maxValue: 32, defaultValue: 14, name: `Optical size` }, { tag: `wght`, minValue: 100, maxValue: 900, defaultValue: 400, name: `Weight` }] }, DE = class { constructor() { M(this, `enabled`, !1), M(this, `bySelector`, new ZT), M(this, `loadedSelectors`, new Set), M(this, `getGoogleFontsListPromise`), M(this, `getFontshareFontsListPromise`), M(this, `getBuiltInFontsListPromise`), M(this, `customFontsImportPromise`, new Promise(e => { this.resolveCustomFontsImportPromise = e })), M(this, `local`), M(this, `google`), M(this, `fontshare`), M(this, `builtIn`), M(this, `framer`), M(this, `custom`), M(this, `bySelectorValuesCache`), M(this, `testing`, { addFont: this.addFont.bind(this) }), this.local = new YT, this.google = new vE, this.fontshare = new fE, this.framer = new gE, this.custom = new oE, this.builtIn = new tE, this.importLocalFonts() } get hash() { return this.bySelector.hash } addFont(e) { if (this.bySelector.set(e.selector, e), e.alternativeSelectors) for (let t of Object.keys(e.alternativeSelectors)) this.bySelector.set(t, e) } getAvailableFonts() { if (!this.bySelectorValuesCache || this.bySelectorValuesCache.hash !== this.bySelector.hash) { let e = new Map; for (let t of this.bySelector.values()) e.set(t, !0); this.bySelectorValuesCache = { result: Array.from(e.keys()), hash: this.bySelector.hash } } return this.bySelectorValuesCache.result } importLocalFonts() { for (let e of this.local.importFonts()) this.addFont(e), this.loadFont(e.selector) } async importGoogleFonts() { return this.getGoogleFontsListPromise ||= Promise.resolve().then(async () => { let { staticFonts: e, variableFonts: t } = await eb.fetchGoogleFontsList(), n = await rm(`google`); for (let r of await this.google.importFonts(e, t, n)) this.addFont(r); return { staticFonts: e, variableFonts: t } }), this.getGoogleFontsListPromise } async importFontshareFonts() { if (!this.getFontshareFontsListPromise) { this.getFontshareFontsListPromise = eb.fetchFontshareFontsList(); let e = await this.getFontshareFontsListPromise, t = await rm(`fontshare`); for (let n of await this.fontshare.importFonts(e, t)) this.addFont(n) } return this.getFontshareFontsListPromise } async importBuiltInFonts() { if (!this.getBuiltInFontsListPromise) { this.getBuiltInFontsListPromise = eb.fetchBuiltInFontsList(); let e = await this.getBuiltInFontsListPromise; for (let t of await this.builtIn.importFonts(e)) this.addFont(t) } return this.getBuiltInFontsListPromise } importFramerFonts(e) { let t = rm(`framer`); this.framer.importFonts(e, t).forEach(e => { this.addFont(e) }) } importCustomFonts(e, t) { this.bySelector.forEach((e, t) => { zp(t) && this.bySelector.delete(t) }); let n = this.custom.importFonts(e, t); for (let e of n) this.addFont(e); this.resolveCustomFontsImportPromise() } getCustomFontsImportPromise() { return this.customFontsImportPromise } getFontFamily(e) { return this[e.source].getFontFamilyByName(e.name) } getFontBySelector(e) { if (!e) return; let t; if (t = this.bySelector.get(e), t) return t.alternativeSelectors && e in t.alternativeSelectors ? { ...t, ...t.alternativeSelectors[e] } : t } getDraftPropertiesBySelector(e) { let t = this.getFontBySelector(e); if (t) return { style: t.style, weight: t.weight, variant: t.variant, cssFamilyName: t.cssFamilyName, source: t.family.source, category: t.category }; let n = this.google.parseSelector(e); if (n) { let e = vE.parseVariant(n.variant); if (yp(e)) return { style: e.style, weight: e.weight, variant: n.variant, cssFamilyName: Dp(n, `google`), source: `google`, category: void 0 } } let r = this.fontshare.parseSelector(e); if (r) { let e = fE.parseVariant(r.variant); if (yp(e)) return { style: e.style, weight: e.weight, variant: r.variant, cssFamilyName: Dp(r, `fontshare`), source: `fontshare`, category: void 0 } } let i = this.builtIn.parseSelector(e); if (i) { let e = tE.parseVariant(i.variant); if (yp(e)) return { style: e.style, weight: e.weight, variant: i.variant, cssFamilyName: Dp(i, `builtIn`), source: `builtIn`, category: void 0 } } return gE.getDraftFontPropertiesBySelector(e) || null } isSelectorLoaded(e) { return this.loadedSelectors.has(e) } async loadFont(e) { let t = this.getFontBySelector(e); if (!t) return 2; if (this.loadedSelectors.has(e)) return 0; let n = t.cssFamilyName, r = t.family.source, i = Rp(t); switch (r) { case `local`: return this.loadedSelectors.add(e), 1; case `framer`: if (ba() || await nm(t.family.name, t.style, t.weight), i) { if (!t.file) return Promise.reject(`Unable to load font: ${e}`); await TE({ family: n, url: t.file, weight: t.weight, style: t.style }, document) } return this.loadedSelectors.add(e), 1; case `google`: case `fontshare`: case `builtIn`: case `custom`: return t.file ? (await TE({ family: n, url: t.file, weight: t.weight, style: t.style }, document), this.loadedSelectors.add(e), 1) : Promise.reject(`Unable to load font: ${e}`); default: V(r) } } async loadFontsFromSelectors(e) { if (!this.enabled) return []; let t = []; e.some(e => e.startsWith(cE)) && t.push(this.importFontshareFonts().catch(e => { Vr(`Failed to load Fontshare fonts:`, e) })), e.some(e => e.startsWith(_E)) && t.push(this.importGoogleFonts().catch(e => { Vr(`Failed to load Google fonts:`, e) })), e.some(e => e.startsWith(eE)) && t.push(this.importBuiltInFonts().catch(e => { Vr(`Failed to load built-in fonts:`, e) })), e.some(zp) && t.push(this.customFontsImportPromise.catch(e => { Vr(`Failed to load custom fonts:`, e) })), t.length > 0 && await Promise.all(t); let n = []; for (let t of e) n.push(this.loadFont(t)); return Promise.allSettled(n) } async loadFonts(e) { return { newlyLoadedFontCount: (await this.loadFontsFromSelectors(e)).filter(e => e.status === `fulfilled` && e.value === 1).length } } async loadMissingFonts(e, t) { let n = e.filter(e => !OE.loadedSelectors.has(e)); n.length !== 0 && (await OE.loadWebFontsFromSelectors(n), n.every(e => OE.loadedSelectors.has(e)) && t && t()) } async loadWebFontsFromSelectors(e) { return this.loadFontsFromSelectors(e) } get defaultFont() { let e = this.getFontBySelector(`Inter`); return B(e, `Cant find Inter font`), e } }, OE = new DE, kE = { "data-1p-ignore": !0, "data-lpignore": !0, "data-form-type": `other`, autocomplete: `off` }, AE = v(function (e, t) { let { autoFocus: n, className: r, inputName: a, max: s, min: l, placeholder: u, required: d, step: f, style: p, type: h, maxLength: g, value: v, defaultValue: y, autofillEnabled: b, onChange: x, onBlur: C, onInvalid: w, onFocus: T, onValid: E, onClear: D, ...O } = e, [k, A] = i(y ?? ``), [ee, j] = i(y), M = c(null); y !== ee && (j(y), A(y ?? ``)); let te = v ?? k, ne = o(async e => { A(e.target.value), x?.(e) }, [x]), N = o(() => { D?.(), _(() => A(``)) }, [D]), re = Aa(E, w, ne, C, T); if (h === `hidden`) return m(P.input, { type: `hidden`, name: a, defaultValue: y }); let ie = b === !1 ? kE : void 0, ae = !!te, oe = !!D && ae; return S(P.div, { ref: t, style: p, className: tc(ME, Vv, r, D && PE), ...O, children: [h === `textarea` ? m(P.textarea, { ref: M, ...ie, ...re, required: d, autoFocus: n, name: a, placeholder: u, className: Bv, value: te, maxLength: g }) : m(P.input, { ref: M, ...ie, ...re, type: h, required: d, autoFocus: n, name: a, placeholder: u, className: tc(Bv, !ae && Hv), value: te, min: l, max: s, step: f, maxLength: g }), oe && m(`button`, { type: `button`, className: NE, onClick: N, "aria-label": `Clear`, children: m(sm, {}) })] }) }), jE = 16, ME = `framer-form-text-input`, NE = `framer-form-text-input-clear`, PE = `framer-form-text-input-has-clear-button`, FE = `<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14"><path d="m1.5 8 7-7M9 5.5l-3 3" stroke="%23999" stroke-width="1.5" stroke-linecap="round"></path></svg>`, IE = `<svg xmlns="http://www.w3.org/2000/svg" transform="scale(-1, 1)" width="14" height="14"><path d="m1.5 8 7-7M9 5.5l-3 3" stroke="%23999" stroke-width="1.5" stroke-linecap="round"></path></svg>`, LE = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16"><path fill="rgb(153, 153, 153)" d="M3 5a2 2 0 0 1 2-2h6a2 2 0 0 1 2 2v2H3Z" opacity=".3"/><path fill="transparent" stroke="rgb(153, 153, 153)" stroke-width="1.5" d="M3.25 5.25a2 2 0 0 1 2-2h5.5a2 2 0 0 1 2 2v5.5a2 2 0 0 1-2 2h-5.5a2 2 0 0 1-2-2ZM3 6.75h9.5"/></svg>`, RE = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16"><path fill="transparent" stroke="rgb(153, 153, 153)" stroke-width="1.5" d="M2.5 8a5.5 5.5 0 1 1 11 0 5.5 5.5 0 1 1-11 0Z"/><path fill="transparent" stroke="rgb(153, 153, 153)" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M7.75 8.25v-3m0 3h2"/></svg>`, zE = Mv(AE, (() => [...Wv, ...qv, ...Gv, Z(`.${Vv}`, { boxShadow: Z.variable(`--framer-input-box-shadow`), borderTopLeftRadius: Z.variable(`--framer-input-border-radius-top-left`), borderTopRightRadius: Z.variable(`--framer-input-border-radius-top-right`), borderBottomRightRadius: Z.variable(`--framer-input-border-radius-bottom-right`), borderBottomLeftRadius: Z.variable(`--framer-input-border-radius-bottom-left`), cornerShape: Z.variable(`--framer-input-corner-shape`), background: Z.variable(`--framer-input-background`), transition: Z.variable(`--framer-input-focused-transition`), transitionProperty: `background, box-shadow` }), Z(`.${ME} .${Bv}::placeholder`, { color: Z.variable(`--framer-input-placeholder-color`) }), Z(`.${ME} .${Bv}[type="date"], .${ME} .${Bv}[type="time"]`, { "-webkit-appearance": `none`, appearance: `none` }), Z(`.${ME} .${Bv}::-webkit-date-and-time-value`, { textAlign: `start` }), Z(`.${ME} textarea`, { display: `flex`, resize: Z.variable(`--framer-textarea-resize`), overflowY: `auto`, minHeight: `inherit`, maxHeight: `inherit`, whiteSpace: `break-spaces` }), Z(`.${ME} textarea::-webkit-resizer`, { background: `no-repeat ${ot(FE)}` }), Z(`.${ME}:dir(rtl) textarea::-webkit-resizer`, { background: `no-repeat ${ot(IE)}` }), Z(`.${ME} textarea::-webkit-scrollbar`, { cursor: `pointer`, background: `transparent` }), Z(`.${ME} textarea::-webkit-scrollbar-thumb:window-inactive`, { opacity: 0 }), Z(`.${ME} textarea::-webkit-scrollbar-corner`, { background: `none`, backgroundColor: `transparent`, outline: `none` }), Z(`.${ME} .${Bv}::-webkit-datetime-edit`, { height: Z.variable(`--framer-input-font-line-height`) }), Z(`.${ME} .${Bv}.${Hv}::-webkit-datetime-edit`, { color: Z.variable(`--framer-input-placeholder-color`), "-webkit-text-fill-color": Z.variable(`--framer-input-placeholder-color`), overflow: `visible` }), Z(`.${ME} .${Bv}[type="date"]::before, .${ME} .${Bv}[type="time"]::before`, { ...Qv, paddingLeft: `${Xv}px`, maskPosition: `${Xv}px center`, backgroundPosition: `${Xv}px center` }), Z(`.${ME} .${Bv}[type="date"]::before`, { maskImage: Z.variable(`--framer-input-icon-mask-image`, ot(LE)), backgroundImage: Z.variable(`--framer-input-icon-image`) }), Z(`.${ME} .${Bv}[type="time"]::before`, { maskImage: Z.variable(`--framer-input-icon-mask-image`, ot(RE)), backgroundImage: Z.variable(`--framer-input-icon-image`) }), Z(`.${ME} .${Bv}::-webkit-calendar-picker-indicator`, { opacity: 0, position: `absolute`, right: 0, top: 0, bottom: 0, padding: Z.variable(`--framer-input-padding`), paddingTop: 0, paddingBottom: 0, width: `${jE}px`, height: `100%` }), Z(`.${ME}:focus-within, .${ME}.${Uv}`, { boxShadow: Z.variable(`--framer-input-focused-box-shadow`, `--framer-input-box-shadow`), background: Z.variable(`--framer-input-focused-background`, `--framer-input-background`) }), Z(`.${ME}:focus-within::after, .${ME}.${Uv}::after`, { borderColor: Z.variable(`--framer-input-focused-border-color`, `--framer-input-border-color`), borderStyle: Z.variable(`--framer-input-focused-border-style`, `--framer-input-border-style`), borderWidth: Z.variable(`--framer-input-focused-border-width`, Kv) }), Z(`.${NE}`, { position: `absolute`, right: 0, top: 0, bottom: 0, width: `${jE}px`, boxSizing: `content-box`, padding: Z.variable(`--framer-input-padding`), border: `none`, background: `transparent`, cursor: `pointer`, color: Z.variable(`--framer-input-placeholder-color`), transition: `color 0.15s ease`, outline: `none` }), Z(`.${NE}:hover, .${NE}:focus-visible`, { color: Z.variable(`--framer-input-font-color`) }), Z(`.${ME}.${PE} .${Bv}`, { paddingRight: `calc(${Z.variable(`--framer-input-padding`)} + ${jE}px + ${Xv}px)` })])(), `framer-lib-form-plain-text-input`), BE = (() => ({ x: void 0, y: void 0, z: 0, translateX: void 0, translateY: void 0, translateZ: 0, rotate: void 0, rotateX: 0, rotateY: 0, rotateZ: void 0, scale: 1, scaleX: 1, scaleY: 1, scaleZ: 1, skew: 0, skewX: 0, skewY: 0, originX: void 0, originY: void 0, originZ: void 0, perspective: 0, transformPerspective: 0 }))(), VE = { opacity: 0 }, HE = { opacity: 1 }, UE = vm(p.forwardRef(function (e, t) { let { background: n, children: r, alt: a, draggable: o, fitImageDimension: s, style: c, ...l } = e, u = { ...c }, d = b(() => uo(n), [n]), [f, h] = i(); p.useLayoutEffect(() => { if (!n?.src || !s || d) return; let e = document.createElement(`img`); e.onload = () => { e.naturalWidth && e.naturalHeight && h({ width: e.naturalWidth, height: e.naturalHeight }) }, e.src = n.src }, [n?.src, s, d]); let g = d ?? f; return s && g && (u[s] = `auto`, u.aspectRatio = g.width / g.height), n && delete u.background, S(fo(e.as), { ...l, style: u, ref: t, draggable: o, children: [n && m(ao, { image: n, alt: a, draggable: o }), r] }) })), GE = (() => !_a() && typeof Document < `u` && typeof Document.parseHTMLUnsafe == `function`)(), KE = /(<([a-z]+)(?:\s+(?!href[\s=])[^=\s]+=(?:'[^']*'|"[^"]*"))*)(?:(\s+href\s*=)(?:'([^']*)'|"([^"]*)"))?((?:\s+[^=\s]+=(?:'[^']*'|"[^"]*"))*>)/gi, qE = `{{ text-placeholder }}`, JE = `rich-text-wrapper`, YE = Pa(v(function (e, n) { let { id: r, name: i, html: a, htmlFromDesign: o, text: l, textFromDesign: u, fonts: d = [], width: f, height: p, left: h, right: g, top: _, bottom: v, center: y, className: x, stylesPresetsClassName: S, visible: C = !0, opacity: w, rotation: T = 0, verticalAlignment: E = `top`, isEditable: D = !1, environment: O = J.current, withExternalLayout: k = !1, positionSticky: A, positionStickyTop: ee, positionStickyRight: j, positionStickyBottom: M, positionStickyLeft: te, __htmlStructure: ne, __fromCanvasComponent: N = !1, _forwardedOverrideId: re, _forwardedOverrides: ie, _usesDOMRect: ae, children: oe, ...se } = e, ce = ra(), le = vo(e), ue = c(null), de = n ?? ue, { navigate: fe, getRoute: pe } = Et(), me = Ot(); gn(e.preload ?? []), wo(e, de); let he = t(ub), ge = bl(), _e = l, ve = re ?? r; if (ve && ie) { let e = ie[ve]; typeof e == `string` && (_e = e) } let ye = ``; if (_e) { let e = bm(_e); ye = ne ? ne.replace(qE, e) : `<p>${e}</p>` } else if (a) ye = a; else if (u) { let e = bm(u); ye = ne ? ne.replace(qE, e) : `<p>${e}</p>` } else o && (ye = o); let F = Wl(), be = b(() => ge || !pe || !me ? ye : xm(ye, pe, me, F), [ye, pe, me, F]); if (s(() => { let e = de.current; if (e === null) return; function t(e) { let t = Rl(e.target, de.current); Ca(e) || !fe || !t || t.getAttribute(`target`) === `_blank` || El(fe, t, F) && e.preventDefault() } return e.addEventListener(`click`, t), () => { e.removeEventListener(`click`, t) } }, [fe, F]), wm(d, N, de), !C) return null; let xe = D && O() === J.canvas, I = { outline: `none`, display: `flex`, flexDirection: `column`, justifyContent: Cm(E), opacity: xe ? 0 : w, flexShrink: 0 }, Se = J.hasRestrictions(), Ce = ea(e, ce || 0, !1), we = ae && (f === `auto` || p === `auto`), Te = e.transformTemplate || !Ce || !Se || N || we ? e.transformTemplate ?? _o(y) : void 0; if (!k) { if (Ce && Se && !we) { let e = O_.getNumber(T).toFixed(4); I.transform = `translate(${Ce.x}px, ${Ce.y}px) rotate(${e}deg)`, I.width = Ce.width, I.minWidth = Ce.width, I.height = Ce.height } else I.left = h, I.right = g, I.top = _, I.bottom = v, I.width = f, I.height = p, I.rotate = T; A ? (!ge || he) && (I.position = `sticky`, I.willChange = `transform`, I.zIndex = 1, I.top = ee, I.right = j, I.bottom = M, I.left = te) : ge && (e.positionFixed || e.positionAbsolute) && (I.position = `absolute`) } return $s(e, I), Xs(e, I), Object.assign(I, e.style), m(P.div, { id: r, ref: de, ...se, style: I, layoutId: le, "data-framer-name": i, "data-framer-component-type": `DeprecatedRichText`, "data-center": y, className: tc(x, S, JE), transformTemplate: Te, dangerouslySetInnerHTML: { __html: be } }) })), XE = { opacity: 1, y: 0, x: 0, scale: 1, rotate: 0, rotateX: 0, rotateY: 0, skewX: 0, skewY: 0, filter: `none` }, ZE = (() => RegExp(`\\p{Regional_Indicator}{2}|\\p{Emoji}\\p{Emoji_Modifier}?\\p{Variation_Selector}?(?:\\u{200d}\\p{Emoji}\\p{Emoji_Modifier}?\\p{Variation_Selector}?)*|.`, `gu`))(), QE = v(function (e, t) { return m(`svg`, { ...e, ref: t, children: e.children }) }), $E = P.create(QE), eD = v(function ({ viewBoxScale: e, viewBox: t, children: n, ...r }, i) { return m($E, { ...r, ref: i, viewBox: t, children: m(P.foreignObject, { width: `100%`, height: `100%`, className: `framer-fit-text`, transform: `scale(${e})`, style: { overflow: `visible`, transformOrigin: `center center` }, children: n }) }) }), tD = [], nD = `RichTextContainer`, rD = v(function (e, n) { let { __fromCanvasComponent: r = !1, _forwardedOverrideId: i, _forwardedOverrides: a, _usesDOMRect: o, anchorLinkOffsetY: s, as: l, bottom: u, center: d, children: f, environment: p = J.current, fonts: h = tD, height: g, isEditable: _ = !1, left: v, name: y, opacity: x, positionSticky: S, positionStickyBottom: C, positionStickyLeft: w, positionStickyRight: T, positionStickyTop: E, right: D, rotation: O = 0, style: k, _initialStyle: A, stylesPresetsClassNames: ee, text: j, top: M, verticalAlignment: te = `top`, visible: ne = !0, width: N, withExternalLayout: re = !1, viewBox: ie, viewBoxScale: ae = 1, effect: oe, ...se } = e, ce = ra(), le = bl(), ue = t(ub), de = vo(e), fe = c(null), pe = n ?? fe; wo(e, pe), wm(h, r, pe); let me = Nm(oe, pe), he = b(() => { if (f) return Bm(f, ee, j, s, void 0, me.getTokenizer()) }, [f, ee, j, s, me]); if (!ne) return null; let P = { opacity: _ && p() === J.canvas ? 0 : x }, ge = Cm(te); ge !== $v.justifyContent && (P.justifyContent = ge); let _e = {}, ve = J.hasRestrictions(), ye = ea(e, ce || 0, !1), F = o && (N === `auto` || g === `auto`), be = e.transformTemplate || !ye || !ve || r || F ? e.transformTemplate ?? _o(d) : void 0; re || (ye && ve && !F ? (_e.x = ye.x + (R(k?.x) ? k.x : 0), _e.y = ye.y + (R(k?.y) ? k.y : 0), _e.left = 0, _e.top = 0, P.rotate = O_.getNumber(O), P.width = ye.width, P.minWidth = ye.width, P.height = ye.height) : (P.left = v, P.right = D, P.top = M, P.bottom = u, P.width = N, P.height = g, P.rotate = O), S ? (!le || ue) && (P.position = `sticky`, P.willChange = `transform`, P.zIndex = 1, P.top = E, P.right = T, P.bottom = C, P.left = w) : le && (e.positionFixed || e.positionAbsolute) && (P.position = `absolute`)), $s(e, P), Xs(e, P), Object.assign(P, A, k, _e), de && (se.layout = `preserve-aspect`); let xe = fo(e.as), I = se[`data-framer-name`] ?? y; return L(e.viewBox) ? e.as === void 0 ? m(eD, { ...se, ref: pe, style: P, layoutId: de, viewBox: ie, viewBoxScale: ae, transformTemplate: be, "data-framer-name": I, "data-framer-component-type": nD, children: he }) : m(xe, { ...se, ref: pe, style: P, layoutId: de, transformTemplate: be, "data-framer-name": I, "data-framer-component-type": nD, children: m(eD, { viewBox: ie, viewBoxScale: ae, style: { width: `100%`, height: `100%` }, children: he }) }) : m(xe, { ...se, ref: pe, style: P, layoutId: de, transformTemplate: be, "data-framer-name": I, "data-framer-component-type": nD, children: he }) }), iD = Pa(v(function ({ children: e, html: t, htmlFromDesign: n, ...r }, i) { let a = t || e || n; if (L(a)) { !r.stylesPresetsClassName && z(r.stylesPresetsClassNames) && (r.stylesPresetsClassName = Object.values(r.stylesPresetsClassNames).join(` `)); let e = { [L(t) ? `html` : `htmlFromDesign`]: a }; return m(YE, { ...r, ...e, ref: i }) } if (!r.stylesPresetsClassNames && L(r.stylesPresetsClassName)) { let [e, t, n, i, a] = r.stylesPresetsClassName.split(` `); e === void 0 || t === void 0 || n === void 0 || i === void 0 || a === void 0 ? console.warn(`Encountered invalid stylesPresetsClassNames: ${r.stylesPresetsClassNames}`) : r.stylesPresetsClassNames = { h1: e, h2: t, h3: n, p: i, a } } return m(rD, { ...r, ref: i, children: g(a) ? a : void 0 }) })), aD = `framer/asset-reference,`, oD = ({ id: e, path: t, transform: n, repeat: r, width: i, height: a, offsetX: o, offsetY: s }) => { let c = Qm(t); return m(`pattern`, { id: e, width: r ? i : `100%`, height: r ? a : `100%`, patternContentUnits: r ? void 0 : `objectBoundingBox`, patternUnits: r ? `userSpaceOnUse` : void 0, x: r ? o : void 0, y: r ? s : void 0, children: m(`image`, { width: r ? i : 1, height: r ? a : 1, href: c, preserveAspectRatio: `none`, transform: r ? void 0 : n, x: r ? 0 : void 0, y: r ? 0 : void 0 }, c) }) }, sD = va(), cD = class { constructor(e, t, n, r, i = 0) { this.id = e, this.svg = t, this.innerHTML = n, this.viewBox = r, this.count = i } }, lD = `position: absolute; overflow: hidden; bottom: 0; left: 0; width: 0; height: 0; z-index: 0; contain: strict`, uD = class {
        constructor() { M(this, `entries`, new Map), M(this, `vectorSetItems`, new Map) } debugGetEntries() { return this.entries } subscribe(e, t, n, r) { if (!e || e === ``) return ``; let i = this.entries.get(e); if (!i) { n ||= `svg${String(vb(e))}_${String(e.length)}`; let a = e, o, s = $m(e); s && (t && eh(s, n), s.id = n, o = ah(s), s.removeAttribute(`xmlns`), s.removeAttribute(`xlink`), s.removeAttribute(`xmlns:xlink`), a = s.outerHTML), i = this.createDOMElementFor(a, n, o, r), this.entries.set(e, i) } return i.count += 1, i.innerHTML } getViewBox(e) { if (!(!e || e === ``)) return this.entries.get(e)?.viewBox } unsubscribe(e) { if (!e || e === ``) return; let t = this.entries.get(e); t && (--t.count, !(t.count > 0) && setTimeout(() => this.maybeRemoveEntry(e), 5e3)) } maybeRemoveEntry(e) { let t = this.entries.get(e); t && (t.count > 0 || (this.entries.delete(e), this.removeDOMElement(t))) } removeDOMElement(e) { sD && (document?.getElementById(e.id))?.remove() } getOrCreateTemplateContainer() { let e = document.getElementById(`svg-templates`); if (e) return e; let t = document.createElement(`div`); return t.id = `svg-templates`, t.ariaHidden = `true`, t.style.cssText = lD, document.body.appendChild(t), t } maybeAppendTemplate(e, t) { if (document.getElementById(e)) return; let n = document.createElement(`div`); n.innerHTML = t; let r = n.firstElementChild; r && (r.id = e, this.getOrCreateTemplateContainer().appendChild(r)) } createDOMElementFor(e, t, n, r) { sD && this.maybeAppendTemplate(t, e); let i = n ? `0 0 ${n.width} ${n.height}` : void 0, a = i ? ` viewBox="${i}"` : ``; return new cD(t, e, `<svg style="width:100%;height:100%;${r ? `overflow: visible;` : ``}"${a}><use href="#${t}"/></svg>`, i) } template(e, t) { return this.vectorSetItems.get(e) || (this.vectorSetItems.set(e, { svg: t, count: 0 }), !sD) || this.maybeAppendTemplate(e, t), `#${e}` } subscribeToTemplate(e) { let t = this.vectorSetItems.get(e); if (t) return t.count++, () => { let t = this.vectorSetItems.get(e); t && (t.count--, !(t.count > 0) && setTimeout(() => { this.vectorSetItems.get(e)?.count || (this.vectorSetItems.delete(e), sD && document?.getElementById(e)?.remove()) }, 5e3)) } } clear() { this.entries.clear() } generateTemplates() {
            let e = []; return e.push(`<div id="svg-templates" style="${lD}" aria-hidden="true">`), this.entries.forEach(t => e.push(t.svg)), this.vectorSetItems.forEach(t => e.push(t.svg)), e.push(`</div>`), e.join(`
`)
        }
    }, dD = new uD, fD = (() => ({ cm: 96 / 2.54, mm: 96 / 2.54 / 10, Q: 96 / 2.54 / 40, in: 96, pc: 96 / 6, pt: 96 / 72, px: 1, em: 16, ex: 8, ch: 8, rem: 16 }))(), pD = v(function (e, t) { let n = ra(), r = vo(e), i = p.useRef(null), a = t ?? i, o = WT(); return wo(e, i), m(hD, { ...e, innerRef: a, parentSize: n, layoutId: r, providedWindow: o }) }), mD = 5e4, hD = (() => { var e; return e = class extends _b { constructor() { super(...arguments), M(this, `container`, p.createRef()), M(this, `svgElement`, null), M(this, `setSVGElement`, e => { this.svgElement = e, this.setLayerElement(e) }), M(this, `previouslyRenderedSVG`, ``), M(this, `unmountedSVG`, ``) } static frame(e) { return ea(e, e.parentSize || 0) } get frame() { return ea(this.props, this.props.parentSize || 0) } componentDidMount() { if (this.unmountedSVG) { let { svgContentId: e } = this.props, t = e ? `svg${e}` : null; dD.subscribe(this.unmountedSVG, !e, t), this.previouslyRenderedSVG = this.unmountedSVG } this.props.svgContentId || lh(this.container, this.props) } componentWillUnmount() { dD.unsubscribe(this.previouslyRenderedSVG), this.unmountedSVG = this.previouslyRenderedSVG, this.previouslyRenderedSVG = `` } componentDidUpdate(e) { if (super.componentDidUpdate(e), this.props.svgContentId) return; let { fill: t } = this.props; sb.isImageObject(t) && sb.isImageObject(e.fill) && t.src !== e.fill.src && ko(this.svgElement, `fill`, null, !1), lh(this.container, this.props) } collectLayout(e, t) { if (this.props.withExternalLayout) { t.width = `100%`, t.height = `100%`, t.aspectRatio = `inherit`; return } let n = this.frame, { rotation: r, intrinsicWidth: i, intrinsicHeight: a, width: o, height: s } = this.props, c = O_.getNumber(r); if (e.opacity = H(this.props.opacity) ? this.props.opacity : 1, J.hasRestrictions() && n) { Object.assign(e, { transform: `translate(${n.x}px, ${n.y}px) rotate(${c.toFixed(4)}deg)`, width: `${n.width}px`, height: `${n.height}px` }), Zi(this.props) && (e.position = `absolute`); let r = n.width / (i || 1), o = n.height / (a || 1); t.transformOrigin = `top left`; let { zoom: s, target: l } = Z_; if (l === J.export) { let e = s > 1 ? s : 1; t.transform = `scale(${r * e}, ${o * e})`, t.zoom = 1 / e } else t.transform = `scale(${r}, ${o})`; i && a && (t.width = i, t.height = a); return } let { left: l, right: u, top: d, bottom: f } = this.props; Object.assign(e, { left: l, right: u, top: d, bottom: f, width: o, height: s, rotate: c }), Object.assign(t, { left: 0, top: 0, bottom: 0, right: 0, position: `absolute` }) } render() { let { id: e, visible: t, style: n, fill: r, svg: i, intrinsicHeight: a, intrinsicWidth: o, title: s, description: c, layoutId: l, className: u, variants: d, withExternalLayout: f, innerRef: p, svgContentId: h, height: g, opacity: _, width: v, requiresOverflowVisible: y, ...b } = this.props; if (!f && (!t || !e)) return null; let x = e ?? l ?? `svg`, C = this.frame, w = C || { width: o || 100, height: a || 100 }, T = { ...n, imageRendering: `pixelated`, flexShrink: 0 }, D = {}; this.collectLayout(T, D), Js(this.props, T), $s(this.props, T), _b.applyWillChange(this.props, T, !1); let O = null; if (typeof r == `string` || q.isColorObject(r)) { let e = q.isColorObject(r) ? r.initialValue || q.toRgbString(r) : r; T.fill = e, T.color = e } else if (Tb.isLinearGradient(r)) { let t = r, n = `${encodeURI(e || ``)}g${Tb.hash(t)}`; T.fill = `url(#${n})`; let { stops: i, x1: a, x2: o, y1: s, y2: c } = Wm(t, x); O = m(`svg`, { ref: this.setSVGElement, width: `100%`, height: `100%`, style: { position: `absolute` }, role: `presentation`, children: m(`linearGradient`, { id: n, x1: a, x2: o, y1: s, y2: c, children: i.map((e, t) => m(`stop`, { offset: e.position, stopColor: e.color, stopOpacity: e.alpha }, t)) }) }) } else if (Db.isRadialGradient(r)) { let t = r, n = `${encodeURI(e || ``)}g${Db.hash(t)}`; T.fill = `url(#${n})`; let i = Gm(t, x); O = m(`svg`, { ref: this.setSVGElement, width: `100%`, height: `100%`, style: { position: `absolute` }, role: `presentation`, children: m(`radialGradient`, { id: n, cy: t.centerAnchorY, cx: t.centerAnchorX, r: t.widthFactor, children: i.stops.map((e, t) => m(`stop`, { offset: e.position, stopColor: e.color, stopOpacity: e.alpha }, t)) }) }) } else if (sb.isImageObject(r)) { let e = Xm(r, w, x); e && (T.fill = `url(#${e.id})`, O = m(`svg`, { ref: this.setSVGElement, width: `100%`, height: `100%`, style: { position: `absolute` }, role: `presentation`, children: m(`defs`, { children: m(oD, { ...e }) }) })) } let k = { "data-framer-component-type": `SVG` }, A = !C; A && Object.assign(k, mo(this.props.center)); let ee = !y && !O && !T.fill && !T.background && !T.backgroundImage && i.length < mD && !oh(i) && !sh(i), j = null; if (ee) T.backgroundSize = `100% 100%`, T.backgroundImage = ot(i), dD.unsubscribe(this.previouslyRenderedSVG), this.previouslyRenderedSVG = ``; else { let e = h ? `svg${h}` : null, t = dD.subscribe(i, !h, e, y); dD.unsubscribe(this.previouslyRenderedSVG), this.previouslyRenderedSVG = i, ch(T) && (T.overflow = `hidden`), j = S(E, { children: [O, m(`div`, { className: `svgContainer`, style: D, ref: this.container, dangerouslySetInnerHTML: { __html: t } }, sb.isImageObject(r) ? r.src : ``)] }) } let M = fo(this.props.as), { href: te, target: ne, rel: N, onClick: re, onTap: ie } = this.props, ae = s || c; return m(M, { ...k, ...b, layoutId: l, transformTemplate: A ? _o(this.props.center) : void 0, id: e, ref: p, style: T, className: u, variants: d, tabIndex: this.props.tabIndex, role: ae ? `img` : void 0, "aria-label": s, "aria-description": c, "aria-hidden": ae ? void 0 : `true`, onTap: ie, onClick: re, href: te, target: ne, rel: N, children: j }) } }, M(e, `supportsConstraints`, !0), M(e, `defaultSVGProps`, { left: void 0, right: void 0, top: void 0, bottom: void 0, style: void 0, _constraints: { enabled: !0, aspectRatio: null }, parentSize: 0, rotation: 0, visible: !0, svg: ``, shadows: [] }), M(e, `defaultProps`, { ..._b.defaultProps, ...e.defaultSVGProps }), e })(), gD = Pa(pD), _D = 1e3, vD = `explicitInter`, Ve.prototype.addChild = function ({ transformer: e = e => e }) { let t = N(e(this.get())); return this.onChange(n => t.set(e(n))), t }
})); export { dt as $, xS as A, HT as At, Mx as B, Ex as C, pp as Ct, rw as D, _p as Dt, kl as E, aS as Et, tc as F, uh as G, fh as H, OE as I, lg as J, Ha as K, Px as L, Va as M, Gy as N, iD as O, hc as Ot, Pv as P, Ea as Q, jx as R, KS as S, Et as St, J as T, mp as Tt, mh as U, jv as V, ph as W, ct as X, kr as Y, yD as Z, Uh as _, Br as _t, bS as a, Jf as at, kn as b, Ff as bt, hx as c, Bf as ct, zE as d, Ot as dt, Fh as et, yx as f, _l as ft, qh as g, pr as gt, VS as h, mr as ht, cS as i, NT as it, dh as j, mn as jt, gD as k, Sh as kt, Ii as l, Gc as lt, UE as m, bl as mt, Wc as n, MS as nt, pv as o, dD as ot, WS as p, Wf as pt, If as q, Uc as r, zr as rt, px as s, gr as st, zl as t, br as tt, xC as u, Ft as ut, nC as v, nc as vt, AT as w, Mv as wt, cd as x, Pt as xt, S_ as y, Qf as yt, Nx as z };
//# sourceMappingURL=framer.753l6WVm.mjs.map